(*
# Map JSONs
Utilities to help load and parse json files related to {ref}`Map`.
*)
{$DEFINE SRLT_MAPJSON_INCLUDED}
{$INCLUDE_ONCE SRLT/osrs.simba}

type
  TMapObjectJSON = type TJSONItem;

(*
## Objects.GetFile
```pascal
function TMapObjectJSON.GetFile(chunk: TPoint; plane: Integer): TJSONItem;
```
Internal method to return a objects JSON file associated with the specified `chunk` and `plane`.
*)
function TMapObjectJSON.GetFile(chunk: TPoint; plane: Integer): TJSONItem;
var
  filename, cachename: String;
begin
  if Map.Loader._UnzipQueue > 0 then
    if not SleepUntil(Map.Loader._UnzipQueue <= 0, 100, 30000) then
      raise GetDebugLn('MapJSON', 'Unzipping files timed out.');

  filename := PATH_SEP + ToStr(chunk.X) + '-' + ToStr(chunk.Y) + '.json';
  cachename := Map.Loader.CacheDir + 'objects' + PATH_SEP + ToStr(plane) + filename;

  if FileExists(cachename) then;
    Result := LoadJSON(cachename);
end;

(*
## Objects.GetJSON
```pascal
function TMapObjectJSON.GetJSON(chunks: TPointArray; plane: Integer): TJSONItem;
```
Internal method to return all objects JSON data associated with the specified
`chunks` and `plane` merged into a single `TJSONItem`.
*)
function TMapObjectJSON.GetJSON(chunks: TPointArray; plane: Integer): TJSONItem;
var
  i, j, n, l: Integer;
  json: TJSONItem;
  id: Integer;
begin
  Result := NewJSONArray();

  for i := 0 to High(chunks) do
  begin
    json := Self.GetFile(chunks[i], plane);
    if json = nil then Continue;

    for j := 0 to json.Count-1 do
    begin
      id := json.Items[j].Items[0].AsInt;
      for n := 0 to Result.Count-1 do
        if Result.Items[n].Items[0].AsInt = id then
        begin
          for l := 0 to json.Items[j].Items[5].Count-1 do
            Result.Items[n].Items[5].AddArray('', json.Items[j].Items[5].Items[l].Clone());
          Continue(2);
        end;
      Result.Add('', json.Items[j].Clone());
    end;
    json.Free();
  end;
end;

(*
## Objects.Load
```pascal
function TMapObjectJSON.Load(regions: array of TRSMapRegion): TJSONItem;
```
Internal method to load all objects JSON data associated into the `TMapObjectJSON`
with the specified `regions` merged into a single `TJSONItem`.
*)
procedure TMapObjectJSON.Load(regions: array of TRSMapRegion);
var
  region: TRSMapRegion;
  json: TJSONItem;
  i, j, n, id: Integer;
begin
  for region in regions do
  begin
    json := Self.GetJSON(region.Chunks, region.Plane);

    for i := 0 to json.Count-1 do
    begin
      id := json.Items[i].Items[0].AsInt;
      for j := 0 to Self.Count-1 do
        if Self.Items[j].Items[0].AsInt = id then
        begin
          for n := 0 to json.Items[i].Items[5].Count-1 do
            Self.Items[j].Items[5].AddArray('', json.Items[i].Items[5].Items[n].Clone());
          Continue(2);
        end;
      Self.Add('', json.Items[i].Clone());
    end;

    json.Free();
  end;
end;


procedure TMapObjectJSON.Print();
var
  i, j, count: Integer;
  str: String;
begin
  str += '[' + LINE_SEP;
  for i := 0 to Self.Count-1 do
  begin
    str += '  {' + LINE_SEP;
    str += '    "id": ' + Self.Items[i].Items[0].ToJSON() + ',' + LINE_SEP;
    str += '    "name": ' + Self.Items[i].Items[1].ToJSON() + ',' + LINE_SEP;
    str += '    "type": ' + Self.Items[i].Items[2].ToJSON() + ',' + LINE_SEP;
    str += '    "category": ' + Self.Items[i].Items[3].ToJSON() + ',' + LINE_SEP;
    str += '    "actions": [';
    count := Self.Items[i].Items[4].Count-1;
    for j := 0 to count do
    begin
      str += '"' + Self.Items[i].Items[4].Items[j].AsString + '"';
      if j < count then str += ',';
    end;
    str += '],' + LINE_SEP;

    str += '    "coordinates": [';
    count := Self.Items[i].Items[5].Count-1;
    for j := 0 to count do
    begin
      str += '[' + Self.Items[i].Items[5].Items[j].Items[0].AsString + ',' + Self.Items[i].Items[5].Items[j].Items[1].AsString + ']';
      if j < count then str += ',';
    end;
    str += '],' + LINE_SEP;

    str += '    "size": [' + Self.Items[i].Items[6].Items[0].AsString + ',';
    str += Self.Items[i].Items[6].Items[0].AsString + ',';
    str += Self.Items[i].Items[6].Items[0].AsString + '],' + LINE_SEP;

    str += '    "rotations": [';
    count := Self.Items[i].Items[7].Count-1;
    for j := 0 to count do
    begin
      str += Self.Items[i].Items[7].Items[j].AsString;
      if j < count then str += ',';
    end;
    str += '],' + LINE_SEP;

    str += '    "colors": [';
    count := Self.Items[i].Items[8].Count-1;
    for j := 0 to count do
    begin
      str += Self.Items[i].Items[8].Items[j].AsString;
      if j < count then str += ',';
    end;
    str += ']' + LINE_SEP;
    str += '  }';
    if i <= Self.Count-2 then str += ',';
    str += LINE_SEP;
  end;
  str += ']';
  WriteLn str;
end;


var
  ObjectsJSON: TMapObjectJSON;

type
  TMapNPCJSON = type TJSONItem;

(*
## NPCsJSON.GetFile
```pascal
function TMapNPCJSON.GetFile(chunk: TPoint; plane: Integer): TJSONItem;
```
Internal method to return a npcs JSON file associated with the specified
`chunk` and `plane`.
*)
function TMapNPCJSON.GetFile(chunk: TPoint; plane: Integer): TJSONItem;
var
  filename, cachename: String;
begin
  if Map.Loader._UnzipQueue > 0 then
    if not SleepUntil(Map.Loader._UnzipQueue <= 0, 100, 30000) then
      raise GetDebugLn('MapJSON', 'Unzipping files timed out.');

  filename := PATH_SEP + ToStr(chunk.X) + '-' + ToStr(chunk.Y) + '.json';
  cachename := Map.Loader.CacheDir + 'npcs' + PATH_SEP + ToStr(plane) + filename;

  if FileExists(cachename) then;
    Result := LoadJSON(cachename);
end;

(*
## NPCsJSON.GetJSON
```pascal
function TMapNPCJSON.GetJSON(chunks: TPointArray; plane: Integer): TJSONItem;
```
Internal method to return all npcs JSON data associated with the specified
`chunks` and `plane` merged into a single `TJSONItem`.
*)
function TMapNPCJSON.GetJSON(chunks: TPointArray; plane: Integer): TJSONItem;
var
  i, j, n, l: Integer;
  json: TJSONItem;
  id: Integer;
begin
  Result := NewJSONArray();

  for i := 0 to High(chunks) do
  begin
    json := Self.GetFile(chunks[i], plane);
    if json = nil then Continue;

    for j := 0 to json.Count-1 do
    begin
      id := json.Items[j].Items[0].AsInt;
      for n := 0 to Result.Count-1 do
        if Result.Items[n].Items[0].AsInt = id then
        begin
          for l := 0 to json.Items[j].Items[7].Count-1 do
            Result.Items[n].Items[7].AddArray('', json.Items[j].Items[7].Items[l].Clone());
          Continue(2);
        end;
      Result.Add('', json.Items[j].Clone());
    end;
    json.Free();
  end;
end;

(*
## NPCsJSON.Load
```pascal
function TMapNPCJSON.Load(regions: array of TRSMapRegion): TJSONItem;
```
Internal method to load all npcs JSON data associated into the `TMapNPCJSON`
with the specified `regions` merged into a single `TJSONItem`.
*)
procedure TMapNPCJSON.Load(regions: array of TRSMapRegion);
var
  region: TRSMapRegion;
  json: TJSONItem;
  i, j, n, id: Integer;
begin
  for region in regions do
  begin
    json := Self.GetJSON(region.Chunks, region.Plane);

    for i := 0 to json.Count-1 do
    begin
      id := json.Items[i].Items[0].AsInt;
      for j := 0 to Self.Count-1 do
        if Self.Items[j].Items[0].AsInt = id then
        begin
          for n := 0 to json.Items[i].Items[7].Count-1 do
            Self.Items[j].Items[7].AddArray('', json.Items[i].Items[7].Items[n].Clone());
          Continue(2);
        end;
      Self.Add('', json.Items[i].Clone());
    end;

    json.Free();
  end;
end;

procedure TMapNPCJSON.Print();
var
  i, j, count: Integer;
  str: String;
begin
  str += '[' + LINE_SEP;
  for i := 0 to Self.Count-1 do
  begin
    str += '  {' + LINE_SEP;
    str += '    "id": ' + Self.Items[i].Items[0].AsString + ',' + LINE_SEP;
    str += '    "name": ' + Self.Items[i].Items[1].AsString + ',' + LINE_SEP;
    str += '    "level": ' + Self.Items[i].Items[2].AsString + ',' + LINE_SEP;
    str += '    "category": ' + Self.Items[i].Items[3].AsString + ',' + LINE_SEP;
    str += '    "minimapdot": ' + Self.Items[i].Items[4].AsString + ',' + LINE_SEP;
    str += '    "actions": [';
    count := Self.Items[i].Items[5].Count-1;
    for j := 0 to count do
    begin
      str += '"' + Self.Items[i].Items[5].Items[j].AsString + '"';
      if j < count then str += ',';
    end;
    str += '],' + LINE_SEP;

    str += '    "size": [' + Self.Items[i].Items[6].Items[0].AsString + ',';
    str += Self.Items[i].Items[6].Items[0].AsString + ',';
    str += Self.Items[i].Items[6].Items[0].AsString + '],' + LINE_SEP;

    str += '    "coordinates": [';
    count := Self.Items[i].Items[7].Count-1;
    for j := 0 to count do
    begin
      str += '[' + Self.Items[i].Items[7].Items[j].Items[0].AsString + ',' + Self.Items[i].Items[7].Items[j].Items[1].AsString + ']';
      if j < count then str += ',';
    end;
    str += '],' + LINE_SEP;

    str += '    "colors": [';
    count := Self.Items[i].Items[8].Count-1;
    for j := 0 to count do
    begin
      str += Self.Items[i].Items[8].Items[j].AsString;
      if j < count then str += ',';
    end;
    str += ']' + LINE_SEP;
    str += '  }';
    if i <= Self.Count-2 then str += ',';
    str += LINE_SEP;
  end;
  str += ']';
  WriteLn str;
end;

var
  NPCsJSON: TMapNPCJSON;
