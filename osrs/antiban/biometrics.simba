

{$DEFINE WL_BIOMETRICS_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  EBiometric = enum(
    MULTIPLIER,
    SLEEP_H, SLEEP_M, SLEEP_S, SLEEP_LENGTH, BREAKS,
    MIN_CLICKTIME, MAX_CLICKTIME, MOUSE_SPEED, MOUSE_GRAVITY, MOUSE_WIND,
    FKEYS, ESCAPE, CHAT_KEYBOARD,
    CHOOSEOPTION,
    SPAM_CLICK,
    PATTERN,
    BANK_CONSUME,
    RATING, LIKES, DISLIKES
  );


  TBiometrics = record
    Index: Integer;
    Hash: TByteArray;
  end;


function TBiometrics.GetHash(): TByteArray;
var
  i: Integer;
  hash: String;
begin
  if Self.Index <> PlayerIndex then Self.Hash := [];
  if Self.Hash <> [] then Exit(Self.Hash);

  if (PlayerIndex > High(Players)) or (Players[PlayerIndex].Username = '') then
  begin
    for i := 0 to Ord(High(EBiometric)) do
      Self.Hash += Random(256);

    hash := String.CreateFromBytes(Self.Hash);
    WriteLn GetDebugLn('Biometrics', 'Random hash created: ' + hash, ELogLevel.WARN);
    WriteLn GetDebugLn('Biometrics', 'Add an account for a permanent one.', ELogLevel.WARN);

    Exit(Self.Hash);
  end;

  hash := HashString(EHashAlgo.SHA1, Players[PlayerIndex].Username);
  WriteLn GetDebugLn('Players', 'Current account seed: ' + hash, ELogLevel.SUCCESS);

  Self.Hash := hash.ToBytes();
  Result := Self.Hash;
end;


function TBiometrics.GetBiometric(biometric: EBiometric): Integer;
begin
  Result := Self.GetHash[biometric];
end;


function TBiometrics.GetProbability(biometric: EBiometric): Single;
begin
  Result := Self.GetBiometric(biometric) / 255;
end;



function TBiometrics.RandomDouble(input: Double): Double;
const
  DEV: Double := input * Self.GetProbability(EBiometric.MULTIPLIER);
begin
  Result := GaussRand(input, DEV);
end;

function TBiometrics.RandomInteger(input: Integer): Integer;
begin
  Result := Round(Self.RandomDouble(input));
end;


function TBiometrics.RandomModeDouble(input, minimum, maximum: Double): Double;
const
  DEV: Double := input * Self.GetProbability(EBiometric.MULTIPLIER);
begin
  Result := Min(Max(minimum, GaussRand(RandomMode(input, minimum, maximum), DEV)), maximum);
end;

function TBiometrics.RandomModeInteger(input, minimum, maximum: Integer): Integer;
begin
  Result := Round(Self.RandomModeDouble(input, minimum, maximum));
end;



function TBiometrics.RandomBoolean(): Boolean;
begin
  Result := RandomBoolean(Self.RandomDouble(0.5));
end;

function TBiometrics.RandomBoolean(behaviour: EBiometric): Boolean; overload;
begin
  Result := RandomBoolean(Self.GetProbability(behaviour));
end;

function TBiometrics.RandomBoolean(probability: Double): Boolean; overload;
begin
  Result := RandomBoolean(Self.RandomDouble(probability));
end;



function TBiometrics.GetSleepHour(): String;
var
  sleep: Double;
begin
  sleep := 23;
  sleep += 4     * Self.GetProbability(EBiometric.SLEEP_H) * ONE_HOUR;
  sleep += 59.99 * Self.GetProbability(EBiometric.SLEEP_M) * ONE_MINUTE;
  sleep += 59.99 * Self.GetProbability(EBiometric.SLEEP_S) * ONE_SECOND;

  if sleep > ONE_DAY then sleep -= ONE_DAY;
  Result := FormatMilliseconds(Round(sleep), 'h:m:s');
end;


function TBiometrics.GetSleepLength(): Single;
begin
  Result := 6 + 4 * Self.GetProbability(EBiometric.SLEEP_LENGTH);
end;



procedure TBiometrics.Sleep(time: UInt32);
begin
  Sleep(Max(0, Self.RandomInteger(time)));
end;

procedure TBiometrics.Sleep(minimum, maximum: UInt32; weight: ERandomDir = ERandomDir.MEAN); overload;
var
  a, b: UInt32;
begin
  a := Max(0, Self.RandomModeInteger(minimum, minimum, maximum));
  b := Max(0, Self.RandomModeInteger(maximum, minimum, maximum));
  Sleep(a, b, weight);
end;



procedure TBiometrics.Click(button: EMouseButton; clicks: UInt32 = 3; probability: Single = 0.08);
var
  i: Integer;
begin
  Mouse.Click(button);
  if not Self.RandomBoolean(probability) then Exit;

  for i := 1 to Self.RandomModeInteger(clicks div 2, 1, clicks) do
  begin
    Mouse.Click(Target.MouseXY.Random(5), button);
    Sleep(0, 100, ERandomDir.LEFT);
  end;
end;

var

  Biometrics: TBiometrics;
