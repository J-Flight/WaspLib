(*
## Minimap
Methods to interact with the minimap.
```{figure} ../../images/minimap.png
The minimap interface.
```
*)

{$DEFINE SRLT_MINIMAP_INCLUDED}
{$INCLUDE_ONCE SRLT/osrs.simba}

type
(*
### ERSMinimapDots
```pascal
ERSMinimapDot  = enum(PLAYER, NPC, ITEM);
```
Enum representing the available minimap dots.
*)
  ERSMinimapDot  = enum(PLAYER, NPC, ITEM);
  ERSMinimapDots = set of ERSMinimapDot;
  TRSMinimapDotArray = array [ERSMinimapDot] of TPointArray;

(*
### ERSMinimapOrb
```pascal
ERSMinimapOrb  = enum(HITPOINTS, PRAYER, ENERGY, SPECIAL);
```
Enum representing the 4 available minimap orbs.
*)
  ERSMinimapOrb  = enum(HITPOINTS, PRAYER, ENERGY, SPECIAL);

(*
### TRSMinimap
Main record used to interact with the {ref}`Minimap`.
*)
  TRSMinimap = record
    Orbs: TCircleArray;
    Bounds: TBox;
    Center: TPoint;
    Polygon: TPolygon;

    Compass: record
      PreviousRadians: Single;
      Circle: TCircle;
    end;

    {%codetools on}
    Masks: record //Thanks to Olly
      const RESIZABLE: TImage = ImageFromString('IMG:AQAAAJgAAACYAAAAAAAAAJDjPwEAAAAAwQIJAAEAAACQ4z8BAAAAALEMAQABAAAAkOmCAQAAAACQoM4JAAAAAGACAABgAgAAkOmCAQAAAAABAAAAmAAAAJgAAAAgAAAAAAAAAAAAAAAAAAAAAwAAACAIEAgICAAIGAAAAAAAAAAAAAAAAAAAAAAAAAAAiVBORw0KGgoAAAANSUhEUgAAAJgAAACYCAIAAACXoLd2AAAABnRSTlMAAAAAAABupgeRAAACi0lEQVR4nO3cQZLiMBBEUbj/pXszM00w2NhSqSor9X8QbFhYzrfrxjwej6fLa6zyY4fdfvkJMtmMaetPoIBngFp/AjW8o8qnaAmpXPk4DSB7VT6XImTfyqdTgfSofkYIA9sO0rstIPfJGXK3DCF3zgSSnn/fG0PSa10h6f+aQdJ5PSDpSuqQdD1dSLqbIiSNpQVJM6lA0nz1kBRVJSTFVgNJK8qGpHXlQdLqMiApJyBNWgtJma2CpPziIakqIE2KhKTagDQpBpIUmoUknYA0aRyS1ALSpBFI0gxIk+5BknJAmnQVkvQD0qTvkNQlIE0C0qQzSOoVkCYBaRKQPgFpEpAmAWkSkD4BaRKQJr1DUtOA9AlIk34hqXVAmvQHkroHpEkgEhERERERERERERG9xB/OTeIfyyYBaRJfvjIJSJOANIhHBkwC0iQgTQLSJCBNAtIhHnQ1CUiTeNDVJCAd+vDzLNQxIE0C0iR++cqhJ5AeAWnSISSWjXqHA7JpQJr0BRLLFn1QA7JjlyCxFO8zGZDtugGJpWyHXkcfYKnZCCSWap1JnUNiKdUUJJYifTECsksBkFiW9x0ISP0uAQEp2EWUEUgscxogBFKrYUIghZpUvAeJ5aLmFW9DYhleiCKQxUUpjkBiGVWg4iAkliFJQGI5WaziFCSWM2lBYjlWuGIAJJYDiUJieTddSERv1QASziu1gcTyvE6QWJ7UDBLLo/pBYvnWwp1XQ2L5r7UjJ0Bi+UhYGMjVJS2cc5k9OVO3zbzYVpbZwyZfbwfOmklLrurKWTlm4bWdOOtnLD9Bd+byiXpAKouWb9ISUoezfAQHyELL8ht3g8y0LL9Tc8illuW3thdkFG35sWNePwzzFBo2j8O9AAAAAElFTkSuQmCC');
      const FIXED:     TImage = ImageFromString('IMG:AQAAAJEAAACXAAAAAAAAAIDjPwEAAAAA7joBAAEAAACQ4z8BAAAAALEMAQABAAAArNaCAQAAAADsLIQBAAAAAEQCAABEAgAArNaCAQAAAAABAAAAkQAAAJcAAAAgAAAAAAAAAAAAAAAAAAAAAwAAACAIEAgICAAIGAAAAAAAAAAAAAAAAAAAAAAAAAAAiVBORw0KGgoAAAANSUhEUgAAAJEAAACXCAIAAACa4y5pAAAABnRSTlMAAAAAAABupgeRAAACqElEQVR4nO3bS27kMBAE0db9L+3FDGDD7taHLDIzyQjoAKp8MHojv16vY6HnPPnrlZ0pf4NClZ7kp61mNjP5sdlm2uTnJ5m5JR/E18w/+UQuZonta5beXmYrtYXZeq1stnarme3TCmZ7Fmy2c5FmlGRGPwswo79Zm9GnTM3oPC8zup+FGT1NbEZtycyoJ4EZ9TfVjKqaZEa1YZbXcDMa0UAzGtcQMxpdsRnNCbO8ysxoZgVmNL8uM1KFWV6NZqQNs7wem5FDmOX1wIx8umVGbmGW14UZeYZZXh/NyDnM8sIsrzdm5B9meWGWF2aRYZbXtxmlhFlemGUGWF6YERFRevyW5YVZXpjlhVlemOWFWV6Y5YVZXpjlhVlemOWFWV6Y5fX/2wJK6cAsroNveOLCLC/M8uJ7/bwwywuzsPg/z7wwywuzvDDLC7O8fpuRf/ydhXVgFhdmeb03g822A7O4MMvrzAw2ww7M4sIsr2sz2Kz6q4OZe3fNYDPpLQ1m1j0zg03eJxfMfGsxg03YCcqFGWySzkWuzWCb3CUHZnbVmME2rTsWd81gm9BNiAdmsA3tvsIzM+RG9HT/FjPYCmsYv9EMtpLalm83Q66nns17zWBrqHPwAjPwbla1c6UZcp+qXbjeDLZflc87xAy5fw0adqDZ5mzjVh1rtqfc6D1nmG3FNmHMSWY7yE2bcarZqnKTBxSYLcY2fz2N2Rpyqt2UZtFswtHEZoly8rkszILY5EMZmUWwySeyMzNnk49jambLJp/F2syQTT5IgJkVm3yKGDMTNvkIYWZyNvn5kWZCNvnhwWYSNvnJmGGGmcGjfwMrNvmxmGGGmcejfwMfNvmZS5lNYJMfuKDZODn5UYublbPJz8EMM+NnT61ss042+ctvavbmmHWdvp8vL+MYGlUk74gAAAAASUVORK5CYII=');
    end;
    const DotIMGs: array [ERSMinimapDot] of TImage = [
      ImageFromString('IMG:AQAAAAIAAAACAAAAAAAAAFzsuAkAAAAACAAAAAAAAAAgAAAAAAAAAMBkSgABAAAAAAAAAAAAAAAgAAAAAAAAAOD7MgcAAAAArlsBAAEAAACQU1wAAAAAAJAcugYAAAAAtnayBgAAAACIHLoGAAAAAFzsuAkAAAAAXOy4CQAAAAAg/DIHAAAAAHBgAQABiVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAIAAAD91JpzAAAABnRSTlMAAAAAAABupgeRAAAAEUlEQVR4nGP4BwYMQPDmzRsARBgIuYq1W6UAAAAASUVORK5CYII='),
      ImageFromString('IMG:AQAAAAIAAAACAAAAAAAAANf7QpQykwAAEDgu0v9/AADABkYIAAAAABgAAAAAAAAAAAAAAAAAAADAAV4AAQAAAND7MgcAAAAAf00BAAEAAAAX+0KUMpMAAIRosgYAAAAAAAAAAAAAAACEaLIGAAAAABD8MgcAAAAAkaIAAAEAAAAQ/DIHAAAAAAAAAAAAiVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAIAAAD91JpzAAAABnRSTlMAAAAAAABupgeRAAAAFElEQVR4nGP484fp61cGEHj7lgEAL5AFvzCPessAAAAASUVORK5CYII='),
      ImageFromString('IMG:AQAAAAIAAAACAAAAAAAAANf7QpQykwAAEDgu0v9/AABgG7AHAAAAABgAAAAAAAAAAAAAAAAAAADAAV4AAQAAAND7MgcAAAAAf00BAAEAAAAX+0KUMpMAAIRosgYAAAAAAAAAAAAAAACEaLIGAAAAABD8MgcAAAAAkaIAAAEAAAAQ/DIHAAAAAAAAAAAAiVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAIAAAD91JpzAAAABnRSTlMAAAAAAABupgeRAAAAFUlEQVR4nGP4p6Dwh42NAQg+MjAAABzlAzh9c63TAAAAAElFTkSuQmCC')
    ];
    const FLAG: TImage = ImageFromString('IMG:AQAAAAIAAAACAAAAAAAAAIDjPwEAAAAA7joBAAEAAACQ4z8BAAAAALEMAQABAAAAgH8GCQAAAAAAiAYJAAAAAAgAAAAIAAAAgH8GCQAAAAABAAAAAgAAAAIAAAAYAAAAAAAAAAAAAAAAAAAAAwAAABgIEAgICAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAiVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAIAAAD91JpzAAAAFUlEQVR4nGP4z8AQayzIcCyMBUgBABrmA2K2r4OdAAAAAElFTkSuQmCC');
    {%codetools on}
  end;

(*
### Minimap.SetupInterface
```pascal
procedure TRSMinimap.SetupInterface();
```
Internal method used to setup the {ref}`TRSMinimap` coordinates.

This is automatically called for you on the {ref}`Minimap variable`.
*)
procedure TRSMinimap.SetupInterface();
var
  tpa: TPointArray;
begin
  case RSClient.Mode of
    ERSMode.RESIZABLE_CLASSIC, ERSMode.RESIZABLE_MODERN:
    begin
      Self.Bounds.X1 := Target.Bounds.X2 - 157;
      Self.Bounds.X2 := Target.Bounds.X2 - 6;
      Self.Bounds.Y1 := Target.Bounds.Y1 + 8;
      Self.Bounds.Y2 := Target.Bounds.Y1 + 159;
    end;

    ERSMode.FIXED:
    begin
      Self.Bounds.X1 := Target.Bounds.X2 - 194;
      Self.Bounds.X2 := Target.Bounds.X2 - 50;
      Self.Bounds.Y1 := Target.Bounds.Y1 + 9;
      Self.Bounds.Y2 := Target.Bounds.Y1 + 159;
    end;
  end;

  SetLength(Self.Orbs, Ord(High(ERSMinimapOrb))+1);

  with Self.Bounds do
    case RSClient.Mode of
      ERSMode.RESIZABLE_CLASSIC, ERSMode.RESIZABLE_MODERN:
      begin
        Self.Compass.Circle := [X1 - 2,  Y1 + 14,  17];
        Self.Orbs[ERSMinimapOrb.HITPOINTS] := [X1 - 13, Y1 + 55,  12];
        Self.Orbs[ERSMinimapOrb.PRAYER]    := [X1 - 13, Y1 + 90,  12];
        Self.Orbs[ERSMinimapOrb.ENERGY]    := [X1 - 3,  Y1 + 121, 12];
        Self.Orbs[ERSMinimapOrb.SPECIAL]   := [X1 + 19, Y1 + 148, 12];
        tpa := [[0, -76], [21, -73], [40, -64], [56, -51], [68, -33], [75, -1], [68, 31], [50, 43], [40, 62], [21, 71], [0, 74], [-21, 71], [-40, 62], [-56, 49], [-68, 31], [-75, -1], [-68, -33], [-56, -51], [-40, -64], [-21, -73]];
      end;

      ERSMode.FIXED:
      begin
        Self.Compass.Circle := [X1 - 8,  Y1 + 12,  17];
        Self.Orbs[ERSMinimapOrb.HITPOINTS] := [X1 - 13, Y1 + 49,  12];
        Self.Orbs[ERSMinimapOrb.PRAYER]    := [X1 - 13, Y1 + 84,  12];
        Self.Orbs[ERSMinimapOrb.ENERGY]    := [X1 - 3,  Y1 + 116, 12];
        Self.Orbs[ERSMinimapOrb.SPECIAL]   := [X1 + 19, Y1 + 142, 12];
        tpa := [[21, -71], [39, -62], [55, -49], [67, -32], [70, 0], [66, 19], [57, 32], [41, 43], [20, 58], [12, 71], [0, 74], [-11, 72], [-24, 55], [-47, 39], [-60, 31], [-66, 22], [-71, 0], [-72, -14], [-67, -32], [-55, -49], [-39, -62], [-21, -71], [0, -74]];
      end;
    end;

  Self.Center := Self.Bounds.Center;
  Self.Polygon := tpa.Offset(Self.Center);
end;

(*
### Minimap.Contains
```pascal
function TRSMinimap.Contains(pt: TPoint): Boolean;
```
Returns True/False if a point `pt` is on the minimap.

Example:
```pascal
WriteLn Minimap.Contains([100,100]);
```
*)
function TRSMinimap.Contains(pt: TPoint): Boolean;
begin
  Result := Self.Polygon.Contains(pt);
end;

(*
### Minimap.Filter
```pascal
function TRSMinimap.Filter(tpa: TPointArray): TPointArray;
```
Returns a TPA of the points from `tpa` that are within the minimap.

Example:
```pascal
tpa := TPointArray.CreateFromBox(Minimap.Bounds);
ShowOnClient(Minimap.Filter(tpa));
```
*)
function TRSMinimap.Filter(tpa: TPointArray): TPointArray;
begin
  Result := tpa.ExtractPolygon(Self.Polygon);
end;


(*
### Minimap.RandomPoint
```pascal
function TRSMinimap.RandomPoint(pt: TPoint; randomness: Integer): TPoint;
```
Generates a random point on the minimap based on the point `pt` passed.
The distance of this random point will be within `randomness` amount of distance
from `pt`.

Example:
```pascal
while True do
  ShowOnClient(Minimap.RandomPoint(Minimap.Center, 30));
```
*)
function TRSMinimap.RandomPoint(pt: TPoint; randomness: Integer): TPoint;
begin
  if not Self.Polygon.Contains(pt) then
    raise GetDebugLn('Minimap', ToStr(pt) + ' is not a valid point to generate a random point.');

  repeat
    Result := pt.Random(-randomness, randomness);
  until Self.Polygon.Contains(Result);
end;



(*
### Minimap.GetCompassAngle
```pascal
function TRSMinimap.GetCompassAngle(asDegrees: Boolean = True): Single;
```
Returns the minimap compass angle either in radians or degrees.
By default, degrees are used.

Credits: slacky

Example:
```pascal
WriteLn Minimap.GetCompassAngle();
```
*)
function TRSMinimap.GetCompassAngle(asDegrees: Boolean = True): Single;
var
  dotpts: TPointArray;
  g: T2DPointArray;
begin
  with Self.Compass.Circle do
  begin
    dotpts := Target.FindColor(ColorTolerance($2220A1, 0.811, EColorSpace.HSL, [2.608, 0.137, 0.256]), Bounds); // red
    if dotpts = [] then Exit;

    g := dotpts.ExtractDist([X,Y], 10, Radius).Cluster(4);

    if Length(g) < 3 then Exit;

    if (g[0].Mean().DistanceTo(g[1].Mean()) > 25) then Swap(g[0], g[2]);
    if (g[0].Mean().DistanceTo(g[2].Mean()) > 25) then Swap(g[0], g[1]);

    if Abs(DeltaAngle(ArcTan2(g[1,0].Y - Y, g[1,0].X - X)+PI/2, ArcTan2(g[0,0].Y - Y, g[0,0].X - X), 2*PI)) > PI/2 then
      Swap(g[1], g[2]);

    Result := RadNormalize(ArcTan2(g[1].Mean().Y - g[2].Mean().Y, g[1].Mean().X - g[2].Mean().X));

    Self.Compass.PreviousRadians := Result;

    if asDegrees then
      Result := radToDeg(Result);
  end;
end;


(*
### Minimap.SetCompassAngle
```pascal
function TRSMinimap.SetCompassAngleEx(degrees, accuracy: Single): Boolean;
function TRSMinimap.SetCompassAngle(degrees: Single): Boolean;
function TRSMinimap.SetCompassAngle(minDegrees, maxDegrees: Single; accuracy: Single = 5): Boolean; overload;
```
Sets the current compass angle.
If you specify a minimum and a maximum angle a gaussian distribution will be used.

Example:
```pascal
Minimap.SetCompassAngle(180);
```
*)
function TRSMinimap.SetCompassAngleEx(degrees, accuracy: Single): Boolean;
const
  DEG_PER_PIXEL = 2.83;
var
  available: TBox;
  remaining: Integer;
  left2right: Boolean;
  destination: TPoint;
  pixels: Integer;
  timeout: UInt64;
begin
  available := Target.Bounds.Expand(-10);
  degrees := DegNormalize(degrees);
  timeout := GetTickCount() + RandomMean(6000, 8000);

  repeat
    remaining := Round(DeltaAngle(Self.GetCompassAngle(), degrees));
    if Abs(remaining) <= accuracy then Exit(True);

    pixels := Round(Abs(DeltaAngle(Self.GetCompassAngle(), degrees)) * DEG_PER_PIXEL);
    left2right := InRange(remaining, 1, 180) or (remaining < -180);

    if left2right then
    begin
      if (not available.Contains(Target.MouseXY)) or ((Target.MouseY + 200 > available.Y2) or (Target.MouseX + pixels > available.X2)) then
        Target.MouseMove([available.X1, available.Y1, available.X1 + 200, available.Y1 + 200]);

      destination.X := Target.MouseX + pixels;
    end
    else
    begin
      if (not available.Contains(Target.MouseXY)) or ((Target.MouseY + 200 > available.Y2) or (Target.MouseX - pixels < available.X1)) then
        Target.MouseMove([available.X2 - 200, available.Y1, available.X2, available.Y1 + 200]);

      destination.X := Target.MouseX - Pixels;
    end;

    destination.Y := Random(Target.MouseY + 100, available.Y2);

    Target.MouseDown(EMouseButton.MIDDLE);
    Target.MouseMove(destination);
    Target.MouseUp(EMouseButton.MIDDLE);

    Sleep(100, 1000, ERandomDir.LEFT);
  until GetTickCount() > timeout;

  WriteLn GetDebugLn('Minimap', 'SetCompassAngle timed out.', EErrorLevel.WARN);
  //TODO:
  //if not RSClient.IsLoggedIn() then
  //  Login.LoginPlayer()
  //else
  //  Self.DebugLn('Make sure the setting "Middle mouse button controls the camera" is enabled in the game settings.');
end;

function TRSMinimap.SetCompassAngle(degrees: Single): Boolean;
begin
  Result := Self.SetCompassAngleEx(degrees, 5);
end;

function TRSMinimap.SetCompassAngle(minDegrees, maxDegrees: Single; accuracy: Single = 5): Boolean; overload;
var
  degrees: Single;
begin
  degrees := RandomMean(DegNormalize(minDegrees), DegNormalize(maxDegrees));
  Result := Self.SetCompassAngleEx(degrees, accuracy);
end;


(*
### Minimap.GetLevel
```pascal
function TRSMinimap.GetLevel(orb: ERSMinimapOrb): Integer;
```
Returns the level of the specified orb.

Example:
```pascal
WriteLn Minimap.GetLevel(ERSMinimapOrb.PRAYER);
```
*)
function TRSMinimap.GetLevel(orb: ERSMinimapOrb): Integer;
begin
  raise GetDebugLn('Minimap.GetLevel' , 'TODO');
  //TODO:
  //Result := OCR.RecognizeNumber([Self.Orbs[orb].X-35, Self.Orbs[orb].Y-1, Self.Orbs[orb].X-15, Self.Orbs[orb].Y+9], Self.OrbOCR, RSFonts.PLAIN_11);
end;


(*
### Minimap Orb Status
```pascal
function TRSMinimap.Poisoned(): Boolean;
function TRSMinimap.Envenomed(): Boolean;
function TRSMinimap.RunEnabled(): Boolean;
function TRSMinimap.HasStamina(): Boolean;
function TRSMinimap.PrayerEnabled(): Boolean;
function TRSMinimap.SpecialEnabled(): Boolean;
function TRSMinimap.HasSpecialWeapon(): Boolean;
```
Returns a status from a minimap orb.

Example:
```pascal
WriteLn Minimap.Poisoned();
```
*)
function TRSMinimap.Poisoned(): Boolean;
begin
  Result := Target.HasColor(16391, 3, 1, Self.Orbs[ERSMinimapOrb.HITPOINTS].Bounds);
end;

function TRSMinimap.Envenomed(): Boolean;
begin
  Result := Target.HasColor(1515790, 9, 1, Self.Orbs[ERSMinimapOrb.HITPOINTS].Bounds);
end;

function TRSMinimap.RunEnabled(): Boolean;
begin
  Result := Target.HasColor(ColorTolerance($58B1CB, 4.504, EColorSpace.HSV, [1.869, 0.609, 0.524]), 1, Self.Orbs[ERSMinimapOrb.ENERGY].Bounds);
end;

function TRSMinimap.HasStamina(): Boolean;
begin
  Result := Target.HasColor(ColorTolerance($2D61C1, 1.475, EColorSpace.HSV, [2.455, 0.300, 0.247]), 1, Self.Orbs[ERSMinimapOrb.ENERGY].Bounds);
end;

function TRSMinimap.PrayerEnabled(): Boolean;
begin
  Result := Target.HasColor(ColorTolerance($2188AB, 10.980, EColorSpace.HSV, [1.317, 1.076, 0.609]), 1, Self.Orbs[ERSMinimapOrb.PRAYER].Bounds);
end;

function TRSMinimap.SpecialEnabled(): Boolean;
begin
  Result := Target.HasColor(ColorTolerance($999273, 1.308, EColorSpace.RGB, [0.122, 0.640, 2.240]), 1, Self.Orbs[ERSMinimapOrb.SPECIAL].Bounds);
end;

function TRSMinimap.HasSpecialWeapon(): Boolean;
begin
  Result := Target.HasColor(ColorTolerance($A68F56, 5.999, EColorSpace.RGB, [0.270, 1.494, 1.237]), 1, Self.Orbs[ERSMinimapOrb.SPECIAL].Bounds);
end;


(*
### Minimap.Toggle
```pascal
function TRSMinimap.Toggle(orb: ERSMinimapOrb): Boolean;
```
Toggles a minimap orb. All orbs can be toggled except `ERSMinimapOrb.HITPOINTS`.

Example:
```pascal
if not Minimap.PrayerEnabled() then
  Minimap.Toggle(ERSMinimapOrb.PRAYER);
```
*)
function TRSMinimap.Toggle(orb: ERSMinimapOrb): Boolean;
var
  state: Boolean;
begin
  case orb of
    ERSMinimapOrb.HITPOINTS: Exit;
    ERSMinimapOrb.PRAYER:  state := Self.PrayerEnabled();
    ERSMinimapOrb.ENERGY:  state := Self.RunEnabled();
    ERSMinimapOrb.SPECIAL:
      if not Self.HasSpecialWeapon() then
        Exit
      else
        state := Self.SpecialEnabled();
  end;

  Mouse.Click(Self.Orbs[orb], EMouseButton.LEFT);

  case orb of
    ERSMinimapOrb.HITPOINTS: Exit;
    ERSMinimapOrb.PRAYER:  Result := Self.PrayerEnabled() <> state;
    ERSMinimapOrb.ENERGY:  Result := Self.RunEnabled() <> state;
    ERSMinimapOrb.SPECIAL: Result := Self.SpecialEnabled() <> state;
  end;
end;


(*
### Minimap.FindFlag
```pascal
function TRSMinimap.FindFlag(out pt: TPoint): Boolean;
```
Returns True/False if the minimap walking flag is visible on the minimap.
`pt` will return the coordinate where the flag was found.

Example:
```pascal
if Minimap.FindFlag(flagPt) then
  ShowOnClient(TCircle.Create(flagPt.X, flagPt.Y, 6));
```
*)
function TRSMinimap.FindFlag(out pt: TPoint): Boolean;
begin
  pt := Target.FindImage(Self.FLAG, 0, Self.Bounds);
  Result := Self.Polygon.Contains(pt);
end;

(*
### Minimap.HasFlag
```pascal
function TRSMinimap.HasFlag(): Boolean;
```
Returns True/False if the minimap walking flag is visible on the minimap.
Same as `Minimap.FindFlag()` but without the need for parameters.

Example:
```pascal
WriteLn Minimap.HasFlag();
```
*)
function TRSMinimap.HasFlag(): Boolean;
var
  p: TPoint;
begin
  Result := Self.FindFlag(p);
end;

(*
### Minimap.WaitFlag
```pascal
function TRSMinimap.WaitFlag(time: Integer = 600; interval: Integer = -1): Boolean;
```
Returns True/False if the minimap walking flag becomes (or already is) visible
within `time` milliseconds.

Example:
```pascal
pt := Minimap.RandomPoint(Minimap.Center, 30);
Mouse.Click(pt, EMouseButton.LEFT);
WriteLn Minimap.WaitFlag(2000);
```
*)
function TRSMinimap.WaitFlag(time: Integer = 600; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.HasFlag(), interval, time);
end;


(*
### Minimap.Normalize
```pascal
function TRSMinimap.Normalize(pt: TPoint; angle: Single): TPoint;
function TRSMinimap.NormalizeEx(vector: Vector2; angle: Single): Vector2;
```
Normalizes minimap coordinates to 0º.
Basically, whatever `pt` or `vector` you pass into this, will be rotated to it's
position on the minimap at 0º.
`angle` should be in radians.

Example:
```pascal
pt := Minimap.RandomPoint(Minimap.Center, 30);
angle := Minimap.GetCompassAngle(False);
pt := Minimap.Normalize(pt, angle);
ShowOnClient(TCircle.Create(pt.X, pt.Y, 6));
```
*)
function TRSMinimap.Normalize(pt: TPoint; angle: Single): TPoint;
begin
  with pt.Rotate(-angle, Self.Center) do
  begin
    Result.X := Round((X - Self.Center.X) / 4) * 4 + Self.Center.X;
    Result.Y := Round((Y - Self.Center.Y) / 4) * 4 + Self.Center.Y;
  end;
end;

function TRSMinimap.NormalizeEx(vector: Vector2; angle: Single): Vector2;
begin
  with vector.Rotate(-angle, Self.Center) do
  begin
    Result.X := Round((X - Self.Center.X) / 4) * 4 + Self.Center.X;
    Result.Y := Round((Y - Self.Center.Y) / 4) * 4 + Self.Center.Y;
  end;
end;


(*
### Minimap.GetDots
```pascal
function TRSMinimap.GetDots(dot: ERSMinimapDot; bounds: TBox): TPointArray;
function TRSMinimap.GetDots(dot: ERSMinimapDot): TPointArray; overload;
function TRSMinimap.GetDots(dots: ERSMinimapDots; bounds: TBox): TRSMinimapDotArray; overload;
function TRSMinimap.GetDots(dots: ERSMinimapDots = [ERSMinimapDot.PLAYER, ERSMinimapDot.NPC, ERSMinimapDot.ITEM]): TRSMinimapDotArray; overload;
```
Returns minimap dots found.
You can specify which dots you want to look for in `dot` or `dots`.
You can also optionalyl specify `bounds` to returns minimap dots from just a region of the minimap.

Example:
```pascal
tpa := Minimap.GetDots(ERSMinimapDot.NPC);
for pt in tpa do
  boxes += TBox.Create(pt, 6, 6);
ShowOnClient(boxes);
```
*)
function TRSMinimap.GetDots(dot: ERSMinimapDot; bounds: TBox): TPointArray;
const
  COLORS: array [ERSMinimapDot] of array [0..1] of TColor = [
    [$FEFEFE, $ECECEC], [$02FCFC, $00EDED], [$0606FC, $0000F1]
  ];
var
  img: TImage;
  y,x: Integer;
begin
  bounds := bounds.Clip(Self.Polygon.Bounds());
  img := TImage.CreateFromTarget(bounds);

  for y := 0 to img.Height-2 do
    for x := 0 to img.Width-2 do
      if (img.Pixel[x,y] = COLORS[dot][0]) and (img.Pixel[x+1,y] = COLORS[dot][1]) then
        Result += [x + bounds.X1+2, y + bounds.Y1-1];
  img.Free();
end;

function TRSMinimap.GetDots(dot: ERSMinimapDot): TPointArray; overload;
begin
  Result := Self.GetDots(dot, Self.Polygon.Bounds());
end;

function TRSMinimap.GetDots(dots: ERSMinimapDots; bounds: TBox): TRSMinimapDotArray; overload;
var
  dot: ERSMinimapDot;
  angle: Single;
begin
  angle := Self.GetCompassAngle(False);
  for dot in dots do
    Result[dot] := Target.FindImageEx(Self.DotIMGs[dot], 0, -1, bounds.Clip(Self.Polygon.Bounds()));
end;

function TRSMinimap.GetDots(dots: ERSMinimapDots = [ERSMinimapDot.PLAYER, ERSMinimapDot.NPC, ERSMinimapDot.ITEM]): TRSMinimapDotArray; overload;
begin
  Result := Self.GetDots(dots, Self.Polygon.Bounds());
end;


(*
### Minimap.CleanImage
```pascal
function TRSMinimap.CleanImage(img: TImage): TImage;
```
Cleans a TImage of the minimap you pass into it.
"Clean" means that minimap dots are removed and the colors around it will be
blended in.

Example:
```pascal
rawIMG := TImage.CreateFromTarget(Minimap.Bounds);
cleanIMG := Minimap.CleanImage(rawIMG);
rawIMG.Free();

cleanIMG.Show();
cleanIMG.Free();
```
*)
function TRSMinimap.CleanImage(img: TImage): TImage;

  procedure _Paint(p: TPoint);
  var
    area: TBox;
    pixel: Integer;
    x, y: Integer;
  begin
    area := TBox.Create(p.X - 2, p.Y - 2, p.X + 2, p.Y + 3);
    area := area.Clip([0,0,img.Width-1, img.Height-1]);

    for y := area.Y1 to area.Y2 do
      for x := area.X1 to area.X2 do
      begin
        pixel := img.Pixel[x, y];

        if SimilarColors($FFFFFF, pixel, 30) then
          img.Pixel[x, y] := 0;

        if SimilarColors($00FFFF, pixel, 30) then
          img.Pixel[x, y] := 0;

        if SimilarColors($0000FF, pixel, 30) then
          img.Pixel[x, y] := 0;

        if SimilarColors($000000, pixel, 1) then
          img.Pixel[x, y] := 0;
      end;
  end;

var
  dots: TRSMinimapDotArray;
  dot: ERSMinimapDot;
  topLeft, p: TPoint;
  tpa: TPointArray;
begin
  topLeft := Self.Polygon.Bounds().TopLeft;

  dots := Self.GetDots();
  for dot := ERSMinimapDot.PLAYER to ERSMinimapDot.ITEM do
    for p in dots[dot] do
      _Paint(p.Offset(-topLeft.X, -topLeft.Y));
  _Paint(img.Center); // our own player

  //idk what the heck is this 3 lines
  img.ReplaceColor(255,0);
  img.ReplaceColor(284358,0);
  img.ReplaceColor(1127261,0);

  img.DrawColor := 0;

  case RSClient.Mode of
    ERSMode.FIXED: img.DrawImage(Self.Masks.FIXED, [0,0]);
    ERSMode.RESIZABLE_CLASSIC, ERSMode.RESIZABLE_MODERN: img.DrawImage(Self.Masks.RESIZABLE, [0,0]);
  end;

  tpa := img.FindColor($0, 0).SortFrom(img.Center);

  Result := img.Blend(tpa, 5);
  Result.Pad(10);
end;

(*
### Minimap.GetCleanImage
```pascal
function TRSMinimap.GetCleanImage(angle: Single = $FFFF): TImage;
```
Returns a clean TImage of the minimap. Read `Minimap.CleanImage()` for more information.
The image returns is also rotated to 0º.

Example:
```pascal
img := Minimap.GetCleanImage();
img.Show();
img.Free();
```
*)
function TRSMinimap.GetCleanImage(angle: Single = $FFFF): TImage;
begin
  if angle = $FFFF then angle := Self.GetCompassAngle(False);
  with TImagePool.Create() do
  try
    Result := TImage.CreateFromTarget(Self.Bounds);
    Result.ReplaceColor(0, 1);
    Result := Self.CleanImage(Result);
    Result := Result.Rotate(EImageRotateAlgo.BILINEAR, angle, False);
  finally
    Free([Result]);
  end;
end;

(*
### Minimap.ScaleMinimap
```pascal
function TRSMinimap.ScaleMinimap(img: TImage; scaling: Integer; radius: Integer = 67): TImage;
```
Scales down a minimap TImage passed in the `img` parameter.

Example:
```pascal
cleanIMG := TImage.GetCleanImage();
scaledIMG := Minimap.ScaleMinimap(cleanIMG, 4);
cleanIMG.Free();

scaledIMG.Show();
scaledIMG.Free();
```
*)
function TRSMinimap.ScaleMinimap(img: TImage; scaling: Integer; radius: Integer = 67): TImage;
var
  center: TPoint;
  tmp, blend: TImage;
  tpa: TPointArray;
begin
  with TImagePool.Create() do
  try
    tmp := img.Copy();

    center := tmp.Center;
    if RSClient.Mode = ERSMode.FIXED then
      center := center.Offset(0, -8).Rotate(-Self.GetCompassAngle(False), center);

    tmp.DrawColor := $0;
    tmp.DrawCircleInverted(center, radius);

    radius += 3;

    tmp.Crop(Box(center, radius, radius));
    tpa := tmp.FindColor($0, 0).SortFrom(tmp.Center);

    blend := tmp.Blend(tpa, 3);

    blend.DrawColor := $0;
    blend.DrawCircleInverted(blend.Center, radius);

    Result := blend.Downsample(scaling);
  finally
    Free([Result]);
  end;
end;


(*
### Minimap.IsPlayerMoving
```pascal
function TRSMinimap.IsPlayerMoving(minShift: Integer = 500): Boolean;
```
Returns whether the player is moving or not according to the specified minimum pixel shift.

Example:
```pascal
WriteLn Minimap.IsPlayerMoving();
```
*)
function TRSMinimap.IsPlayerMoving(minShift: Integer = 500): Boolean;
begin
  with Self.Center do
    Result := Target.GetPixelDifference(300, TBox.Create([X,Y], 40, 40)) >= minShift;
end;

var
(*
### Minimap variable
Global {ref}`TRSMinimap` variable.
*)
  Minimap: TRSMinimap;
