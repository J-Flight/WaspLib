

{$DEFINE WL_BANK_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  ERSBankButtons = enum(WORN, MENU);


  ERSBankArrangement = enum(SWAP, INSERT);


  ERSWithdrawMode = enum(ITEM, NOTE);


  ERSBankDynamicButtons = enum(PLACEHOLDERS, SEARCH, DEPOSIT_INVENTORY, DEPOSIT_WORN);


  ERSBankInteraction = enum(WITHDRAW, DEPOSIT);


  TBankPosition = record
    Tab: Integer;
    Scroll: Integer;
    Slot: TBox;
  end;


  TRSBank = record
    Bounds: TBox;
    Slots: TRSSlotInterface;
    Items: TRSItemInterface;
    Title: TRSInterfaceTitle;
    Scroll: TRSScrollBar;

    CachedQuantity: Integer;

    Incenerator, PotionStorage, SlotsArea: TBox;

    Tabs, SlotBoxes: TBoxArray;

    Buttons: array [ERSBankButtons] of TRSButton;
    ArrangementButtons: array [ERSBankArrangement] of TRSButton;
    WithdrawModeButtons: array [ERSWithdrawMode] of TRSButton;
    QuantityButtons: array [ERSItemQuantity] of TRSButton;
    DynamicButtons: array [ERSBankDynamicButtons] of TRSButton;
    ButtonsOffset: Integer;

    JagexAccountAd: record
      NotNow, MoreInfo: TBox;
    end;

    Depleted: Boolean;

    {%codetools on}
    Cache: record
      Quantity: Integer;
      Items: TStringMap<TBankPosition>;
    end;
    _IsOpenHelperBox: TBox;
    {%codetools on}
    Banks: TRSObjectArray;
    Bankers: TRSNPCArray;
  end;


function TRSBank.FindItemBoundaries(): TBoxArray;
var
  tpa, final: TPointArray;
  atpa: T2DPointArray;
  b: TBox;
  color: Integer;
begin
  final := Target.FindColor(RSColors.ITEM_BORDER, 1, Self.SlotsArea);
  if final = [] then Exit;

  for color in RSColors.STACK_COLORS do
  begin
    tpa := Target.FindColor(color, 0, Self.SlotsArea);
    if tpa <> [] then final += tpa;
  end;

  atpa := final.Cluster(200, 3);

  for tpa in atpa do
  begin
    b := tpa.Bounds();
    if b.Height <= 5 then Continue;

    Result += TBoxArray.Create([Self.SlotsArea.X1, b.Y1], 8, 1, 31, Min(Self.SlotsArea.Y2-b.Y1, 31), [17, 1]);
  end;
end;

function TRSBank.IsOpen(): Boolean; forward;


procedure TRSBank.SetupInterface();
var
  i: Integer;
begin
  case RSClient.Mode of
    ERSMode.FIXED: Self.Bounds := MSInterface.CreateBounds([0, 2, 0, -1], 488, 800);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Bounds := MSInterface.CreateBounds([0, 2, 0, -2], 488, 800);
  end;

  Self.Scroll.Area.X1 := Self.Bounds.X1 + 5;
  Self.Scroll.Area.Y1 := Self.Bounds.Y1 + 77;
  Self.Scroll.Area.X2 := Self.Bounds.X2 - 22;
  Self.Scroll.Area.Y2 := Self.Bounds.Y2 - 44;

  Self.Scroll.Setup();
  Self.Title.Setup(Self.Bounds);

  Self.Tabs := TBoxArray.Create(Self.Bounds.TopLeft.Offset(47, 42), 10, 1, 35, 28, [5, 0]);
  Self.SlotBoxes := TBoxArray.Create(Self.Bounds.TopLeft.Offset(57, 77), 8, (Self.Bounds.Height - 135) div 35, 31, 31, [17, 5]);

  Self.SlotsArea.X1 := Self.Bounds.X1 + 57;
  Self.SlotsArea.Y1 := Self.Bounds.Y1 + 77;
  Self.SlotsArea.X2 := Self.Bounds.X2 - 63;
  Self.SlotsArea.Y2 := Self.Bounds.Y2 - 44;

  with Self.SlotsArea.Center.Offset(0,-1) do
    Self.JagexAccountAd.NotNow := [X-120, Y+43, X-49, Y+66];

  with Self.SlotsArea.Center.Offset(0,-1) do
    Self.JagexAccountAd.MoreInfo := [X+39, Y+43, X+108, Y+66];

  Self.Incenerator.X1 := Self.Bounds.X1 + 5;
  Self.Incenerator.Y1 := Self.Bounds.Y2 - 113;
  Self.Incenerator.X2 := Self.Bounds.X1 + 51;
  Self.Incenerator.Y2 := Self.Bounds.Y2 - 44;

  Self.PotionStorage.X1 := Self.Bounds.X1 + 8;
  Self.PotionStorage.Y1 := Self.Bounds.Y2 - 156;
  Self.PotionStorage.X2 := Self.Bounds.X1 + 51;
  Self.PotionStorage.Y2 := Self.Bounds.Y2 - 118;

  Self.Slots.Setup('Bank.Slots', Self.SlotBoxes, @Self.FindItemBoundaries);
  Self.Items.Setup('Bank.Items', @Self.Slots, [0, 1], @Self.IsOpen);

  Self._IsOpenHelperBox.X1 := Self.Bounds.X1 + 235;
  Self._IsOpenHelperBox.Y1 := Self.Bounds.Y2 - 42;
  Self._IsOpenHelperBox.X2 := Self.Bounds.X2 - 156;
  Self._IsOpenHelperBox.Y2 := Self.Bounds.Y2 - 26;

  for i := 0 to 1 do
  begin
    Self.Buttons[i].EnabledColors             := [[$0F1043, 0], [$23269F, 0.227]];
    Self.ArrangementButtons[i].EnabledColors  := [[$0F1043, 0], [$23269F, 0.227]];
    Self.WithdrawModeButtons[i].EnabledColors := [[$0F1043, 0], [$23269F, 0.227]];
  end;

  for i := 0 to 4 do
    Self.QuantityButtons[i].EnabledColors := [[$0F1043, 0], [$23269F, 0.227]];

  for i := 0 to 3 do
    Self.DynamicButtons[i].EnabledColors := [[$0F1043, 0], [$23269F, 0.227]];

  with Self.Bounds do
  begin
    Self.Buttons[ERSBankButtons.WORN].Bounds := TBox.Create(X1+12, Y1+43, X1+36, Y1+67);
    Self.Buttons[ERSBankButtons.MENU].Bounds := TBox.Create(X2-36, Y1+43, X2-12, Y1+67);

    Self.ArrangementButtons[ERSBankArrangement.SWAP].Bounds := TBox.Create(X1+5, Y2-26, X1+54, Y2-5);
    Self.ArrangementButtons[ERSBankArrangement.INSERT].Bounds := TBox.Create(X1+55, Y2-26, X1+104, Y2-5);

    Self.WithdrawModeButtons[ERSWithdrawMode.ITEM].Bounds := TBox.Create(X1+105, Y2-26, X1+154, Y2-5);
    Self.WithdrawModeButtons[ERSWithdrawMode.NOTE].Bounds := TBox.Create(X1+155, Y2-26, X1+204, Y2-5);

    for i := 0 to 4 do
      Self.QuantityButtons[i].Bounds := TBox.Create(X1+205 + 25 * i, Y2-26, X1+229 + 25 * i, Y2-5);

    for i := 0 to 3 do
      Self.DynamicButtons[i].Bounds := TBox.Create(X1+331 + 35 * i + 4 * i, Y2-41, X1+366 + 35 * i + 4 * i, Y2-6);
    Self.DynamicButtons[ERSBankDynamicButtons.DEPOSIT_WORN].Bounds := Self.DynamicButtons[ERSBankDynamicButtons.DEPOSIT_WORN].Bounds.Offset([-2,0]);
  end;
end;


procedure TRSBank.UpdateButtons(offset: Integer);
var
  i: Integer;
begin
  if Self.ButtonsOffset = offset then Exit;
  Self.ButtonsOffset := offset;

  for i := 0 to 1 do
  begin
    Self.Buttons[i].Bounds            := Self.Buttons[i].Bounds.Offset([offset, 0]);
    Self.ArrangementButtons[i].Bounds := Self.ArrangementButtons[i].Bounds.Offset([offset, 0]);
    Self.WithdrawModeButtons[i].Bounds    := Self.WithdrawModeButtons[i].Bounds.Offset([offset, 0]);
  end;

  for i := 0 to 4 do
    Self.QuantityButtons[i].Bounds := Self.QuantityButtons[i].Bounds.Offset([offset, 0]);

  for i := 0 to 3 do
    Self.DynamicButtons[i].Bounds := Self.DynamicButtons[i].Bounds.Offset([offset, 0]);
end;



function TRSBank.HasJagexAccountAd(): Boolean;
begin
  Result := (Target.CountColor($0000FF, 0, Self.JagexAccountAd.NotNow) = 98) and
            (Target.CountColor($0DC10D, 0, Self.JagexAccountAd.MoreInfo) = 112);
end;


function TRSBank.CloseJagexAccountAd(): Boolean;
begin
  Mouse.Click(Self.JagexAccountAd.NotNow, EMouseButton.LEFT);
  Result := SleepUntil(not Self.HasJagexAccountAd(), 50, 600);
end;



function TRSBank.IsOpen(): Boolean;
var
  count: Integer;
  tpa: TPointArray;
  offset: Integer;
begin
  if BankPin.IsOpen() then
  begin
    if not BankPin.WaitLoading(3000) then
      raise GetDebugLn('BankPin', 'Bank pin buttons don''t seem to have loaded in 3 seconds.');

    if not BankPin.Enter(Players.GetPin()) then
      raise GetDebugLn('BankPin', 'Failed to enter bank pin.');
  end;

  count := Target.CountColor($0, 0, Self._IsOpenHelperBox);
  tpa := Target.FindColor(RSColors.TEXT_ORANGE, 0, Self._IsOpenHelperBox);
  Result := ((count = 94) and (Length(tpa) = 116)) or Self.Title.IsTitle('Bank') or Self.Title.IsTitle('Equip');

  if Result then
  begin
    if tpa = [] then
    begin
      if not Self.HasJagexAccountAd() then Exit;
      if not Self.CloseJagexAccountAd() then Exit;
      Exit(Self.IsOpen()); //ad closed, restart
    end;

    offset := tpa.First.X;
    offset -= Self.Bounds.X1+244;
    Self.UpdateButtons(offset);
  end;
end;


function TRSBank.WaitOpen(time: Integer; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(), interval, time);
end;


function TRSBank.Close(escape: Boolean): Boolean;
begin
  Result := Self.Title.Close(escape);
end;

function TRSBank.Close(escapeProbability: Single = -1): Boolean; overload;
begin
  Result := Self.Title.Close(escapeProbability);
end;




function TRSBank.CountTabs(): Integer;
var
  i: Integer;
begin
  for i := 9 downto 1 do
    if Target.HasColor(RSColors.ITEM_BORDER, 0, 1, Self.Tabs[i]) then
      Exit(i);
end;


function TRSBank.GetCurrentTab(): Integer;
var
  i: Integer;
begin
  for i := 0 to 9 do
    with Self.Tabs[i] do
      if not Target.HasColor($516471, 0, 1, [X1+4, Y2+3, X2-4, Y2+5]) then
        Exit(i);
end;


function TRSBank.OpenTab(tab: Integer): Boolean;
  function _TabChanged(tab: Integer): Boolean;
  begin
    if tab <> 0 then
      Exit(tab = Self.GetCurrentTab());

    //when search is open tab 0 is returned.
    Result := not Chat.FindQuery('Show items');
  end;

begin
  if not Self.IsOpen() then Exit;

  if tab = Self.GetCurrentTab() then
  begin
    if tab <> 0 then Exit(True);
    if not Chat.FindQuery('Show items') then Exit(True);
  end;

  Mouse.Click(Self.Tabs[tab], EMouseButton.LEFT);
  Result := SleepUntil(_TabChanged(tab), RandomMode(100, 50, 1500), 600);
  Sleep(200, 300);
end;




function TRSBank.SetArrangement(arrangement: ERSBankArrangement): Boolean;
begin
  if Self.ArrangementButtons[arrangement].Enabled() then Exit(True);
  Result := Self.ArrangementButtons[arrangement].Enable();
  if Result then Sleep(600, 800);
end;


function TRSBank.SetWithdrawMode(noted: Boolean): Boolean;
var
  btn: ERSWithdrawMode;
begin
  if noted then btn := ERSWithdrawMode.NOTE
  else btn := ERSWithdrawMode.ITEM;

  if Self.WithdrawModeButtons[btn].Enabled() then Exit(True);
  Result := Self.WithdrawModeButtons[btn].Enable();
  if Result then Sleep(600, 800);
end;


function TRSBank.SetQuantity(quantity: ERSItemQuantity): Boolean;
begin
  if Self.QuantityButtons[quantity].Enabled() then Exit(True);
  Result := Self.QuantityButtons[quantity].Enable();
  if Result then Sleep(600, 800);
end;




function TRSBank.IsSearchOpen(): Boolean;
begin
  Result := Chat.FindQuery('Show items', True);
end;


function TRSBank.WaitSearchOpen(time: Integer = 600; interval: Integer = -1): Boolean;
begin
  Result := Chat.WaitQuery('Show items', True, time, interval);
end;


function TRSBank.OpenSearch(waitTime: Integer = 0): Boolean;
begin
  Self.DynamicButtons[ERSBankDynamicButtons.SEARCH].Click();
  if waitTime <= 0 then
    Exit(Self.IsSearchOpen());
  Result := Self.WaitSearchOpen(waitTime);
  Sleep(200, 300);
end;


function TRSBank.ClearSearch(): Boolean;
begin
  if not Self.Title.IsTitle('Showing items:') then Exit(True);

  if Biometrics.RandomBoolean() then
    Self.DynamicButtons[ERSBankDynamicButtons.SEARCH].Click()
  else
    Mouse.Click(Self.Tabs[0], EMouseButton.LEFT);
  Result := SleepUntil(not Self.Title.IsTitle('Showing items:'), RandomMode(100, 50, 1500), 600);
end;


function TRSBank.Search(item: TRSItem): Boolean;
var
  txt: String;
  i, j: Integer;
begin
  txt := item.SimplifyName();

  if Self.Title.IsTitle('Showing items: ' + txt) then Exit(True);
  if not Self.ClearSearch() then Exit;
  if not Self.OpenSearch(Random(2000, 2500)) then Exit;

  for i := 1 to Length(txt) do
  begin
    Keyboard.KeyPress(Target.KeyCodeFromChar(txt[i]));
    Sleep(100, 200);

    if i = j then Break;

    if (j = 0) and Self.Items.Contains(item) then
      j := i + Random(2, 4);
  end;

  Result := SleepUntil(Self.Items.Contains(item), 300, 2000);
end;


function TRSBank.CloseSearch(): Boolean;
begin
  Result := Self.ClearSearch() and
            Chat.AnswerQuery('Show items', '', Random(2000, 2500));
end;



function TRSBank.HasIncinerator(): Boolean;
begin
  with Self.Incenerator do
    Result := Target.HasColor(ColorTolerance($517F9E, 2.132, EColorSpace.HSV, [2.437, 0.309, 0.256]), 1, [X1, Y1+55, X2, Y2]);
end;


function TRSBank.InceneratorTooltipVisible(): Boolean;
begin
  with Self.Incenerator do
    Result := Target.HasColor($A0FFFF, 0, 1, [X1+6, Y1+76, X2, Y2+35]);
end;


function TRSBank.CloseInceneratorTooltip(): Boolean;
var
  boxes: TBoxArray;
begin
  if not Self.Incenerator.Contains(Target.MouseXY) then
    Exit(True);

  boxes := Self.Incenerator.Invert(Self.Bounds).SortFrom(Target.MouseXY);
  Async.MouseMove(boxes[RandomLeft(0, High(boxes))].RandomPoint());
  Result := SleepUntil(not Self.InceneratorTooltipVisible(), 100, 1000);
  Async.MouseStop();
end;



function TRSBank.HasPotionStorage(): Boolean;
begin
  Result := Target.HasColor(ColorTolerance($517F9E, 2.132, EColorSpace.HSV, [2.437, 0.309, 0.256]), 1, Self.PotionStorage);
end;


function TRSBank.PotionStorageIsOpen(): Boolean;
begin
  Result := Target.HasColor($1F98FF, 0,  3000, Self.SlotsArea);
end;


{%codetools off}

function TRSBank._FindTabText(tpa: TPointArray; out bounds: TBox): Boolean;
var
  atpa: T2DPointArray;
begin
  if tpa = [] then Exit;
  atpa := tpa.Cluster(6).ExcludeDimensions(24, 8, 26, 8);
  if atpa = [] then Exit;

  atpa := atpa.SortByY(False)[0].Cluster(1.5);
  bounds := atpa.SortByX(False)[0].Bounds();

  bounds.X1 -= 1;
  bounds.Y1 -= 1;
  bounds.X2 += 1;
  bounds.Y2 += 3;
  Result := True;
end;
{%codetools on}


function TRSBank.FindTab(item: TRSItem): Integer;
var
  bounds: TBox;
begin
  if not Self.Search(item) then Exit(-1);
  if not Self.Items.Find(item, bounds)  then Exit(-1);

  bounds := [Self.Bounds.X1 + 56, Self.Bounds.Y1 + 77, Self.Bounds.X1 + 84, bounds.Y1];
  if bounds.Height < 8 then Exit(0);

  if Self._FindTabText(Target.FindColor(RSColors.TEXT_LIGHT_YELLOW, 0, bounds), bounds) then
    Result := OCR.RecognizeNumber(bounds, RSFonts.PLAIN_11, [RSColors.TEXT_LIGHT_YELLOW], 0);
  if Self._FindTabText(Target.FindColor(RSColors.TEXT_WHITE, 0, bounds), bounds) then
    Result := OCR.RecognizeNumber(bounds, RSFonts.PLAIN_11, [RSColors.TEXT_WHITE], 0);
end;


function TRSBank.FindScroll(item: TRSItem): Integer;
var
  next: Integer;
  down: Boolean;
begin
  if not Self.Scroll.CanScroll() then Exit(-1);

  Result := Self.Scroll.GetLevel();
  down := (Result > 0) or RandomBoolean(0.5);

  if Self.Items.Contains(item) then Exit;

  repeat
    if down then next := Result - 5
    else next := Result + 5;

    Result := Self.Scroll.SetLevel(next);
    if Self.Items.Contains(item) then Exit;

    if not Self.IsOpen() then Exit(-1); //failsafe
  until not InRange(Result, 1, 99);

  down := not down;
  repeat
    if down then next := Result - 5
    else next := Result + 5;

    Result := Self.Scroll.SetLevel(next);
    if Self.Items.Contains(item) then Exit;

    if not Self.IsOpen() then Exit(-1);
  until not InRange(Result, 1, 99);

  Result := -1;
end;


function TRSBank._InteractionHelper(mode: ERSBankInteraction; slot: TBox; amount: Integer; useQuantityButton: Boolean): Boolean;
var
  quantity: ERSItemQuantity;
  amountStr, modeStr: String;
begin
  amountStr := ToString(amount);
  quantity := ERSItemQuantity.Integer2Quantity(amount);

  if mode = ERSBankInteraction.DEPOSIT then
    modeStr := 'Deposit-'
  else
    modeStr := 'Withdraw-';

  if useQuantityButton then
  begin
    if not Self.SetQuantity(quantity) then Exit;

    Mouse.Move(slot);
    if quantity <> ERSItemQuantity.CUSTOM then
    begin
      Mouse.Click(EMouseButton.LEFT);
      Exit(True);
    end;

    if MainScreen.IsUpText(modeStr + amountStr) then
    begin
      Mouse.Click(EMouseButton.LEFT);
      Exit(True);
    end;

    if not ChooseOption.Select(modeStr + 'X') then Exit;
    Exit(Chat.AnswerQuery('Enter amount', amountStr, RandomLeft(1400, 2400)));
  end;

  Mouse.Move(slot);

  if (quantity <> ERSItemQuantity.CUSTOM) then
  begin
    if Self.QuantityButtons[quantity].Enabled() then
    begin
      Mouse.Click(EMouseButton.LEFT);
      Exit(True);
    end;
  end
  else
  if MainScreen.IsUpText(modeStr + amountStr) then
  begin
    Mouse.Click(EMouseButton.LEFT);
    Exit(True);
  end;

  if (quantity = ERSItemQuantity.ALL) then
    Exit(ChooseOption.Select(modeStr + 'All'));

  Result := ChooseOption.Select(modeStr + amountStr + ' ', True, False) or
            (ChooseOption.Select(modeStr + 'X') and Chat.AnswerQuery('Enter amount', amountStr, RandomLeft(1400, 2400)));
end;


function TRSBank.Find(item: TRSItem; out data: TBankPosition; attempts: Int32 = 3): Boolean;
begin
  if attempts = 0 then Exit(False);

  if Self.Items.Find(item, data.Slot) then
  begin
    if not Self.DynamicButtons[ERSBankDynamicButtons.SEARCH].Enabled() then
    begin
      data.Tab := Self.GetCurrentTab();
      data.Scroll := Self.Scroll.GetLevel();
      Self.Cache.Items.Value[item] := data;
      Exit(True);
    end;

    if Self.WaitSearchOpen(600) then
      if not Self.CloseSearch() then Exit(Self.Find(item, data, Dec(attempts))); //unknown state, reset search
  end;

  data.Tab := Self.FindTab(item);
  if data.Tab = -1 then
    Exit(Self.Find(item, data, Dec(attempts)));
  Self.OpenTab(data.Tab);

  if Self.Items.Find(item, data.Slot) then
  begin
    data.Scroll := Self.Scroll.GetLevel();
    Self.Cache.Items.Value[item] := data;
    Exit(True);
  end;

  data.Scroll := Self.FindScroll(item);
  if data.Scroll = -1 then
    Exit(Self.Find(item, data, Dec(attempts)));

  if not Self.Items.Find(item, data.Slot) then
    Exit(Self.Find(item, data, Dec(attempts)));

  Result := True;
  Self.Cache.Items.Value[item] := data;
end;



function TRSBank.Withdraw(item: TRSBankItem; useQuantityButton, useCache: Boolean = True; waitConfirmation: Boolean = False): Boolean;
var
  data: TBankPosition;
  tmp: TRSItem;
  count: Integer;
  attempt: Integer;
begin
  if useCache and Self.Cache.Items.Exists(item.Item) then
    data := Self.Cache.Items.Value[item.Item]
  else if not Self.Find(item.Item, data) then
    Exit;

  if not Self.OpenTab(data.Tab) then Exit;
  if not InRange(Self.Scroll.GetLevel() - data.Scroll, -5, 5) then
    Self.Scroll.SetLevel(data.Scroll);

  tmp := item.ToItem();

  for attempt := 0 to 2 do
  begin
    count := Self.Slots.ReadStack(data.Slot);

    if not Self.SetWithdrawMode(item.Noted) then Continue;
    if Self._InteractionHelper(ERSBankInteraction.WITHDRAW, data.Slot, item.Quantity, useQuantityButton) then
    begin
      if not waitConfirmation then
        Exit(True);

      Self.Slots.WaitFade(data.Slot);
      Sleep(200);

      if SleepUntil(Self.Slots.ReadStack(data.Slot) < count, 200, 4200) then
        Exit(True);
    end;
  end;
end;

function TRSBank.Withdraw(item: TRSItem; useQuantityButton: Boolean = True; useCache: Boolean = True): Boolean; overload;
begin
  Result := Self.Withdraw(item.ToBankItem(), useQuantityButton, useCache);
end;


function TRSBank.Deposit(item: TRSBankItem; useQuantityButton: Boolean = True): Boolean;
var
  slot: TBox;
begin
  if Inventory.Items.Find(item.ToItem(), slot) then
    Result := Self._InteractionHelper(ERSBankInteraction.DEPOSIT, slot, item.Quantity, useQuantityButton);
end;

function TRSBank.Deposit(item: TRSItem; useQuantityButton: Boolean = True): Boolean; overload;
var
  slot: TBox;
begin
  if Inventory.Items.Find(item, slot) then
    Result := Self._InteractionHelper(ERSBankInteraction.DEPOSIT, slot, 1, useQuantityButton);
end;



function TRSBank.DepositDifferent(items: TRSItemArray; useQuantityButton: Boolean = True): Boolean;
var
  slots: TIntegerArray;
  slot: Integer;
begin
  slots := Inventory.Items.FindDifferent(items);
  if slots = [] then Exit(True);

  for slot in slots do
    if not Self._InteractionHelper(ERSBankInteraction.DEPOSIT, Inventory.Slots.Box(slot), 1, useQuantityButton) then
      Exit;
  Result := True;
end;



function TRSBank.IsDepleted(item: TRSBankItem; attempts: Integer = 3): Boolean;
var
  data: TBankPosition;
begin
  if attempts = 0 then Exit;

  if Self.Find(item.Item, data) then
  begin
    if Max(1, TRSItem.ReadStack(data.Slot)) < Min(item.Quantity, 28) then
    begin
      Self.Depleted := Self.IsOpen();
      Exit(True);
    end;

    Exit(False);
  end;

  Result := Self.IsDepleted(item, attempts-1);

  Self.Depleted := Result and Self.IsOpen();
end;

procedure TRSBank._SetupMapObjects();
begin
  Self.Banks.Setup(ObjectsJSON.GetByAction('Bank'));
  Self.Bankers.Setup(NPCsJSON.GetByAction('Bank'));
end;



function TRSBank.Hover(walk: Boolean = True): Boolean;
var
  obj: TRSObject;
  npc: TRSNPC;
  me: TPoint;
begin
  if (Self.Banks = []) or (Self.Bankers = []) then
    Self._SetupMapObjects();

  me := Map.Position();
  obj := Self.Banks[Self.Banks.ClosestIndex(me)];
  npc := Self.Bankers[Self.Bankers.ClosestIndex(me)];

  if obj.DistanceTo(me) < npc.DistanceTo(me) then
  begin
    if walk then Exit(obj.WalkHover());
    Exit(obj.Hover());
  end;

  if walk then Exit(npc.WalkHover());
  Result := npc.Hover();
end;


function TRSBank.Open(walk: Boolean = True): Boolean;
var
  obj: TRSObject;
  npc: TRSNPC;
  me: TPoint;
begin
  if MSInterface.IsOpen() then
  begin
    if Self.IsOpen() then Exit(True);
    MSInterface.Close(True);
  end;

  if (Self.Banks = []) or (Self.Bankers = []) then
    Self._SetupMapObjects();

  me := Map.Position();
  obj := Self.Banks[Self.Banks.ClosestIndex(me)];
  npc := Self.Bankers[Self.Bankers.ClosestIndex(me)];

  if obj.DistanceTo(me) < npc.DistanceTo(me) then
  begin
    if walk then Result := obj.WalkSelect(['Bank B', 'Bank E', 'Bank G'])
    else Result := obj.Select(['Bank B', 'Bank E', 'Bank G']);

    if not Result then
    begin
      Result := MainScreen.IsUpText('Bank') and ChooseOption.Select(['Bank B', 'Bank E']);
      if not Result then Exit;
    end;

    obj.Walker^.WaitMoving();
    Result := Self.WaitOpen(3000);
    Exit;
  end;

  if walk then Result := npc.WalkSelect(['Bank B', 'Bank E'])
  else Result := npc.Select(['Bank B', 'Bank E']);

  if not Result then
  begin
    Result := MainScreen.IsUpText('Bank') and ChooseOption.Select(['Bank B', 'Bank E']);
    if not Result then Exit;
  end;

  npc.Walker^.WaitMoving();
  Result := Self.WaitOpen(3000);
end;


procedure TRSBank.Draw(img: TImage);
var
  i: Integer;
begin
  if not Self.IsOpen() then Exit;

  for i := 0 to 1 do
  begin
    Self.Buttons[i].Draw(img);
    Self.ArrangementButtons[i].Draw(img);
    Self.WithdrawModeButtons[i].Draw(img);
  end;

  img.DrawColor := $FFFFFF;
  for i := 0 to Self.CountTabs() do
    img.DrawBox(Self.Tabs[i]);

  img.DrawColor := $FFFF00;
  img.DrawBoxArray(Self.FindItemBoundaries(), False);
  Self.Scroll.Draw(img);

  for i := 0 to 4 do
    Self.QuantityButtons[i].Draw(img);

  for i := 0 to 3 do
    Self.DynamicButtons[i].Draw(img);
end;

procedure TRSBank.ShowOnTarget();
var
  img: TImage;
begin
  img := Target.GetImage();
  Self.Draw(img);
  img.Show();
end;


var

  Bank: TRSBank;
