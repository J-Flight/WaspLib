

{$DEFINE WL_MAINSCREEN_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TRSMainScreen = record
    Bounds: TBox;
    Center: TPoint;
    TopLeft, TopRight, BottomRight, BottomLeft: TPoint;

    UpTextImageBuffer: TImage;
    UptextBounds, ServerMsgBounds: TBox;
    UptextOCR: TPixelOCR;

    HighestPitch: Boolean;

    Mask: TBooleanMatrix;
  end;


procedure TRSMainScreen.SetupInterface();
var
  y, x: Integer;
begin
  case RSClient.Mode of
    ERSMode.FIXED:
      with RSClient.Bounds do
        Self.Bounds := TBox.Create(X1+4,4,X1+515,337);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Bounds := RSClient.Bounds;
  end;

  Self.Center := Self.Bounds.Center;

  Self.TopLeft     := Self.Bounds.TopLeft;
  Self.TopRight    := Self.Bounds.TopRight;
  Self.BottomRight := Self.Bounds.BottomRight;
  Self.BottomLeft  := Self.Bounds.BottomLeft;

  if RSClient.Client = ERSClient.OFFICIAL then
  begin
    Self.UptextBounds.X1 := Self.Bounds.X1;
    Self.UptextBounds.Y1 := Self.Bounds.Y1 + 1;
    Self.UptextBounds.X2 := Self.Bounds.X1 + 497;
    Self.UptextBounds.Y2 := Self.Bounds.Y1 + 19;
  end
  else
  begin
    Self.UptextBounds.X1 := Self.Bounds.X1 + 3;
    Self.UptextBounds.Y1 := Self.Bounds.Y1 + 3;
    Self.UptextBounds.X2 := Self.Bounds.X1 + 500;
    Self.UptextBounds.Y2 := Self.Bounds.Y1 + 21;
  end;

  Self.ServerMsgBounds.X1 := Self.Bounds.X1 + 2;
  Self.ServerMsgBounds.Y1 := Self.Bounds.Y1 + 2;
  Self.ServerMsgBounds.X2 := Self.ServerMsgBounds.X1 + 129;
  Self.ServerMsgBounds.Y2 := Self.ServerMsgBounds.Y1 + 20;

  Self.Mask := [];
  SetLength(Self.Mask, Self.Bounds.Y2+1, Self.Bounds.X2+1);
  for y := Self.Bounds.Y1 to Self.Bounds.Y2 do
    for x := Self.Bounds.X1 to Self.Bounds.X2 do
      Self.Mask[y,x] := True;
end;



procedure TRSMainScreen.AddMask(tpa: TPointArray);
var
  pt: TPoint;
begin
  for pt in tpa.ExtractBox(Self.Bounds) do
    Self.Mask[pt.Y, pt.X] := False;
end;

procedure TRSMainScreen.AddMask(box: TBox); overload;
begin
  Self.AddMask(TPointArray.CreateFromBox(box, True));
end;

procedure TRSMainScreen.AddMask(circle: TCircle); overload;
begin
  Self.AddMask(TPointArray.CreateFromCircle(circle.Center, circle.Radius, True));
end;





property TRSMainScreen.UpText: String;
var
  img: TImage;
begin
  img := Target.GetImage(Self.UptextBounds);
  Result := Self.UptextOCR.Recognize(img, RSFonts.BOLD_SHADOW, [0,0]);
  {$IFDEF WL_DEBUG_UPTEXT}
  WriteLn GetDebugLn('MainScreen', 'UpText: ' + Result);
  {$ENDIF}
end;




function TRSMainScreen.IsUpText(strings: TStringArray; caseSensitive: Boolean = True; similarity: Single = 0.85; timeout: Integer = -1): Boolean;
  function _IsUpText(): Boolean;
  var
    upText, str, tmp: String;
    i: Integer;
  begin
    if caseSensitive then
      upText := Self.UpText
    else
      upText := LowerCase(Self.UpText);

    for str in strings do
    begin
      if not caseSensitive then str := LowerCase(str);

      //shift string until best match is found.
      for i := 1 to Length(upText)-Length(str) do
      begin
        tmp := Copy(upText, i, Length(str));
        if str.Similarity(tmp) >= similarity then
          Exit(True);
      end;
    end;
  end;

var
  t: Integer;
begin
  if (timeout = -1) then
    t := Time() + Round(RandomMode(100, 85, 250))
  else
    t := Time() + timeout;

  repeat
    if _IsUpText() then
    begin
      Sleep(50);
      if _IsUpText() then
        Exit(True);
    end;

    Sleep(25);
  until Time() >= t;
end;

function TRSMainScreen.IsUpText(text: String; caseSensitive: Boolean = True; similarity: Single = 0.85; timeout: Integer = -1): Boolean; overload;
begin
  Result := Self.IsUpText([text], caseSensitive, similarity, timeout);
end;





property TRSMainScreen.ServerMessage: String;
var
  black: TPointArray;
begin
  black := Target.FindColor($0, 0, Self.ServerMsgBounds);
  if Length(black) < 500 then Exit;
  Result := OCR.Recognize(black.Bounds(), RSFonts.PLAIN_12, [$FFFFFF], 0);
end;


function TRSMainScreen.IsServerMessage(text: String; caseSensitive: Boolean = True; similarity: Single = 0.85): Boolean; overload;
var
  msg: String;
begin
  if caseSensitive then
    msg := Self.ServerMessage
  else
  begin
    text := LowerCase(text);
    msg := LowerCase(Self.ServerMessage);
  end;

  if msg = '' then Exit;

  msg := Copy(msg, 1, Length(text));
  Result := text.Similarity(msg) >= similarity;
end;



procedure TRSMainScreen.SetHighestPitch();
var
  i, area: Integer;
begin
  Keyboard.KeyDown(EKeyCode.UP);

  area := Self.Bounds.Area * 100;
  for i := 1 to 10 do // 2500ms timeout
    if (Target.GetPixelDifference(250, Self.Bounds).Length / area) < 10 then // less than 10% of the screen changed in 250ms
      Break;

  Keyboard.KeyUp(EKeyCode.UP);
  Self.HighestPitch := True;
end;



function TRSMainScreen.IsVisible(pt: TPoint): Boolean;
begin
  Result := pt <> pt;
end;

function TRSMainScreen.IsVisible(tpa: TPointArray): Boolean; overload;
var
  pt: TPoint;
begin
  for pt in tpa do
    if Self.IsVisible(pt) then
      Exit(True);
end;



function TRSMainScreen.Filter(tpa: TPointArray): TPointArray;
begin
  Result := tpa;
end;


{%codetools off}
function TRSMainScreen._RedClicked(area: TBox): Boolean;
begin
  Result := Target.HasColor($0000FF, 0, 1, area) or Target.HasColor($0401C8, 0, 1, area);
end;
{%codetools on}


function TRSMainScreen.RedClicked(): Boolean;
var
  area: TBox;
begin
  area := TBox.Create(Target.MouseXY, 10, 10).Clip(Self.Bounds);
  Result := Self._RedClicked(area);
end;


function TRSMainScreen.WaitRedClick(time: Integer = 250): Boolean;
var
  area: TBox;
begin
  area := TBox.Create(Target.MouseXY, 10, 10).Clip(Self.Bounds);
  Result := SleepUntil(Self._RedClicked(area), 50, time);
end;


{%codetools off}
function TRSMainScreen._YellowClicked(area: TBox): Boolean;
begin
  Result := Target.HasColor(65535, 0, 1, area);
end;
{%codetools on}


function TRSMainScreen.YellowClicked(): Boolean;
var
  area: TBox;
begin
  area := TBox.Create(Target.MouseXY, 10, 10).Clip(Self.Bounds);
  Result := Self._YellowClicked(area);
end;


function TRSMainScreen.WaitYellowClick(time: Integer = 250): Boolean;
var
  area: TBox;
begin
  area := TBox.Create(Target.MouseXY, 10, 10).Clip(Self.Bounds);
  Result := SleepUntil(Self._YellowClicked(area), 50, time);
end;


var

  MainScreen: TRSMainScreen;


function TBiometrics.YellowClick(button: EMouseButton; clicks: UInt32 = 3): Boolean;
var
  i: Integer;
begin
  Mouse.Click(button);
  Result := MainScreen.YellowClicked();

  if Random() > Self.RandomModeDouble(0.08, 0.05, 0.1) then
    Exit;

  for i := 1 to Self.RandomModeInteger(clicks div 2, 1, clicks) do
  begin
    Mouse.Click(Mouse.Position.Random(5), button);
    Sleep(0, 100, ERandomDir.LEFT);
  end;

  Result := MainScreen.YellowClicked() and not MainScreen.RedClicked();
end;


function TBiometrics.RedClick(button: EMouseButton; clicks: UInt32 = 3): Boolean;
var
  i: Integer;
begin
  Mouse.Click(button);
  Result := MainScreen.RedClicked();

  if Random() > Self.RandomModeDouble(0.08, 0.05, 0.1) then
    Exit;

  for i := 1 to Self.RandomModeInteger(clicks div 2, 1, clicks) do
  begin
    Mouse.Click(Mouse.Position.Random(5), button);
    Sleep(0, 100, ERandomDir.LEFT);
  end;

  Result := MainScreen.RedClicked() and not MainScreen.YellowClicked();
end;
