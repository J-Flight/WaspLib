(*
# FairyRing
Fairy rings interface.
*)

{$DEFINE WL_FAIRYRING_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
  ERSFairyRingDial = enum(LEFT, MIDDLE, RIGHT);

  TRSFairyRing = record
    Bounds: TBox;
    Title: TRSInterfaceTitle;
    Scroll: TRSScrollBar;

    TeleportButton: TBox;

    Dials: array [ERSFairyRingDial] of String;
    DialBoxes, DialHole, RotateLeftBoxes, RotateRightBoxes: TBoxArray;
    Item: TRSItem;
  end;

(*
## FairyRing.Setup
```pascal
procedure FairyRing.Setup();
```
Initializes TRSFairyRing variables.

```{note}
This is automatically called on the **FairyRing** variable.
```
*)
procedure TRSFairyRing.Setup();
begin
  Self.Dials[ERSFairyRingDial.LEFT] := 'ADCB';
  Self.Dials[ERSFairyRingDial.MIDDLE] := 'ILKJ';
  Self.Dials[ERSFairyRingDial.RIGHT] := 'PSRQ';
end;

function TRSFairyRing.IsOpen(): Boolean; forward;

procedure TRSFairyRing.SetupInterface();
var
  b: TBox;
begin
  case RSClient.Mode of
    ERSMode.FIXED: Self.Bounds := MSInterface.CreateBounds([0, 2, 0, 0], 500, 316);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Bounds := MSInterface.CreateBounds([0, 1, 0, 0], 500, 316);
  end;

  with Self.Bounds do
  begin
    Self.Title.Bounds := [X1+178, Y1+25, X2-178, Y1+50];
    Self.Title.CloseButton := [X2-27, Y1+1, X2-6, Y1+21];
    Self.TeleportButton := [X1+170, Y2-65, X2-170, Y2-28];
  end;

  Self.Title.TitleColor := RSFonts.BROWN;

  Self.Title.IsOpen := @Self.IsOpen;
  Self.Title.Font := @RSFonts.QUILL_8;

  with GameTab.Bounds do
    Self.Scroll.Area := [X1+3, Y1+41, X2-19, Y2-6];
  Self.Scroll.Setup();

  Self.DialBoxes := TBoxArray.Create(Self.Bounds.TopLeft + [2,80], 3, 1, 159, 155, [11,0]);
  Self.DialBoxes[2].X1 -= 2;
  Self.DialBoxes[2].X2 -= 2;

  for b in Self.DialBoxes do
  begin
    Self.DialHole += [b.X1+58, b.Y2-55, b.X2-58, b.Y2-10];
    Self.RotateLeftBoxes += [b.X1, b.Y1, b.X2-80, b.Y2];
    Self.RotateRightBoxes += [b.X1+80, b.Y1, b.X2, b.Y2];
  end;
end;


(*
## FairyRing.IsOpen
```pascal
function TRSFairyRing.IsOpen(): Boolean;
```
Returns true/false whether the FairyRing interface is open or not.

Example:
```pascal
WriteLn FairyRing.IsOpen();
```
*)
function TRSFairyRing.IsOpen(): Boolean;
begin
  Result := Self.Title.IsTitle('Choose a combination');
end;

(*
## FairyRing.WaitOpen
```pascal
function TRSFairyRing.WaitOpen(time: Integer; interval: Integer = -1): Boolean;
```
Returns true if the fairy ring interface is open within `time` milliseconds.

## Example:
```pascal
WriteLn FairyRing.WaitOpen();
```
*)
function TRSFairyRing.WaitOpen(time: Integer; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(), interval, time);
end;


(*
## FairyRing.Close
```pascal
function TRSFairyRing.Close(escape: Boolean): Boolean;
function TRSFairyRing.Close(escapeProbability: Double = BioHash): Boolean; overload;
```
Closes the FairyRing interface, depending on `escape` the function will either
click the button or press escape.

Example:
```pascal
WriteLn FairyRing.Close();
```
*)
function TRSFairyRing.Close(escape: Boolean): Boolean;
begin
  Result := Self.Title.Close(escape);
end;

function TRSFairyRing.Close(escapeProbability: Single = -1): Boolean; overload;
begin
  Result := Self.Title.Close(escapeProbability);
end;


(*
## FairyRing.HandleItem
```pascal
function TRSFairyRing.HandleItem(): Boolean;
```
Magically finds, caches for next usages and equips dramen or lunar staff with the minimum tab opening possible.
If no item is found, we will assume the user has the elite lumbridge and draynor diary complete for next uses.

Example:
```pascal
 if FairyRing.HandleItem() then
WriteLn FairyRing.Item;
```
*)
function TRSFairyRing.HandleItem(attempts: Int32 = 2): Boolean;
begin
end;



(*
## FairyRing.Open
```pascal
function TRSFairyRing.Open(walk: Boolean = True): Boolean;
```
Attempts to open the closest fairy ring RSObject.

Example:
```pascal
 WriteLn FairyRing.Open();
```
*)
function TRSFairyRing.Open(walk: Boolean = True): Boolean;
begin
  if MSInterface.IsOpen() and not MSInterface.Close() then
    Exit;

  if Self.IsOpen() then
    Exit(True);

  if not Self.HandleItem() then
    Exit;


  //if walk then
  //  Result := Self.FairyRings.WalkSelect(['onfigure'])
  //else
  //  Result := Self.FairyRings.Select(['onfigure']);

  if not Result then
    Exit;

  Minimap.WaitMoving();
  Result := SleepUntil(Self.IsOpen(), RandomMode(100, 50, 1500), 2000);
end;

(*
## FairyRing.IsLetterValid
```pascal
function TRSFairyRing.IsLetterValid(letter: Char; dial: ERSFairyRingDial): Boolean;
```
Checks if the **letter** passed on is valid for the given **dial**.

Example:
```pascal
 WriteLn FairyRing.IsLetterValid('z', ERSFairyRingDial.LEFT);
```
*)
function TRSFairyRing.IsLetterValid(letter: Char; dial: ERSFairyRingDial): Boolean;
begin
  Result := Self.Dials[dial].Contains(letter);
end;

(*
## FairyRing.IsCodeValid
```pascal
function TRSFairyRing.IsCodeValid(fairyCode: String): Boolean;
```
Checks if the a given **fairyCode** is a valid fairy ring code.

Example:
```pascal
 WriteLn FairyRing.IsCodeValid('abc');
```
*)
function TRSFairyRing.IsCodeValid(fairyCode: String): Boolean;
var
  i: Int32;
begin
  if Length(fairyCode) <> 3 then
    Exit;

  for i := 1 to Length(fairyCode) do
    if not Self.IsLetterValid(fairyCode[i], ERSFairyRingDial(i-1)) then
      Exit;

  Result := True;
end;


(*
## FairyRing.Spin
```pascal
procedure TRSFairyRing.SpinLeft(dial: ERSFairyRingDial);
procedure TRSFairyRing.SpinRight(dial: ERSFairyRingDial);
```
Spins the given **dial** left or right. By default it waits for the rotation to finish but it can be skipped with **skipWait**.

Example:
```pascal
 WriteLn FairyRing.SpinLeft(ERSFairyRingDial.LEFT);
```
*)
procedure TRSFairyRing.SpinLeft(dial: ERSFairyRingDial);
begin
  Mouse.Click(Self.RotateLeftBoxes[dial], EMouseButton.LEFT);
end;

procedure TRSFairyRing.SpinRight(dial: ERSFairyRingDial);
begin
  Mouse.Click(Self.RotateRightBoxes[dial], EMouseButton.LEFT);
end;


(*
## FairyRing.Letter
```pascal
property TRSFairyRing.Letter(dial: ERSFairyRingDial): Char;
property TRSFairyRing.Letter(character: Char; dial: ERSFairyRingDial): Boolean;
```
Returns or sets the letter of a fairy ring dial.

Example:
```pascal
WriteLn FairyRing.Letter[ERSFairyRingDial.RIGHT];
WriteLn FairyRing.Letter['p', ERSFairyRingDial.RIGHT];
WriteLn FairyRing.Letter[ERSFairyRingDial.RIGHT];
```
*)
property TRSFairyRing.Letter(dial: ERSFairyRingDial): Char;
var
  count: integer;
begin
  count := Target.CountColor([$49153B, 6.713, EColorSpace.HSV, [1.631, 0.429, 0.942]], Self.DialHole[dial]);

  case dial of
    ERSFairyRingDial.LEFT:
    case count of
      172: Result := 'A';
      198: Result := 'D';
      80 : Result := 'C';
      125: Result := 'B';
      else Result := 'n';
    end;

    ERSFairyRingDial.Middle:
    case count of
      52 : Result := 'L';
      98 : Result := 'K';
      66 : Result := 'J';
      65 : Result := 'I';
      else Result := 'n';
    end;

    ERSFairyRingDial.Right:
    case count of
      100 : Result := 'S';
      81 : Result := 'R';
      63 : Result := 'Q';
      85 : Result := 'P';
      else Result := 'n';
    end;
  end;
end;

property TRSFairyRing.Letter(character: Char; dial: ERSFairyRingDial): Boolean;
  function _FindChar(str: String; character: Char): Integer;
  begin
    for Result := 1 to Length(str) do
      if character = str[Result] then
        Exit;
    Result := -1;
  end;
type
  TDialSpin = record
    Moves: Integer;
    Direction: Boolean;
  end;
var
  current: Char;
  available: String;
  i, j: Integer;
  spins: TDialSPin;
begin
  if not Self.IsLetterValid(character, dial) then
    raise GetDebugLn('FairyRing', '"' + UpperCase(character) + '" is not a valid letter for fairy ring ' + ToStr(dial) + ' dial.');

  current := Self.Letter[dial];
  if current = character then
    Exit(True);

  available := Self.Dials[dial];
  i := _FindChar(available, current);
  j := _FindChar(available, character);

  case i - j of
    -3, 1: if Biometrics.RandomBoolean(0.8) then spins := [1, False] else spins := [3, True];
    -2, 2: if Biometrics.RandomBoolean(0.5) then spins := [2, False] else spins := [2, True];
    -1, 3: if Biometrics.RandomBoolean(0.8) then spins := [1, True] else spins := [3, False];
  end;

  for i := 1 to spins.Moves do
  begin
    if spins.Direction then
      Self.SpinRight(dial)
    else
      Self.SpinLeft(dial);
    Biometrics.Sleep(100, 300);
  end;

  Result := True;
end;


(*
## FairyRing.Code
```pascal
property TRSFairyRing.Code: String;
property TRSFairyRing.Code(code: String): Boolean;
```
Returns the current fairy ring code or sets the new one in the dials.

Example:
```pascal
WriteLn FairyRing.Code;
WriteLn FairyRing.Code['DLP'];
WriteLn FairyRing.Code;
```
*)
property TRSFairyRing.Code: String;
var
  dial: ERSFairyRingDial;
begin
  for dial := Low(ERSFairyRingDial) to High(ERSFairyRingDial) do
    Result += Self.Letter[dial];
end;

property TRSFairyRing.Code(fairyCode: String): Boolean;
var
  attempt, i: Integer;
begin
  fairyCode := fairyCode.Replace(' ', '').ToUpper();
  if not Self.IsCodeValid(fairyCode) then
    raise GetDebugLn('FairyRing', '"' + fairyCode + '" is not a valid fairy ring code.');

  for attempt := 0 to 2 do
  begin
    if fairyCode = Self.Code then
      Exit(True);

    for i := 0 to 2 do
    begin
      if not Self.Letter[fairyCode[i+1], ERSFairyRingDial(i)] then
        Continue(2);
      Biometrics.Sleep(150, 1200);
    end;

    if SleepUntil(fairyCode = Self.Code, 300, 3000) then
      Exit(True);
  end;
end;

(*
## FairyRing.ClickTeleport
```pascal
function TRSFairyRing.ClickTeleport(): Boolean;
```
Clicks the fairy ring the teleport button.

Example:
```pascal
WriteLn FairyRing.ClickTeleport();
```
*)
function TRSFairyRing.ClickTeleport(): Boolean;
begin
  if not Self.IsOpen() then
    Exit;
  Mouse.Click(Self.TeleportButton, EMouseButton.LEFT);
  Result := SleepUntil(not Self.IsOpen(), 300, 3000);
end;


(*
## FairyRing.GetLogCodes
```pascal
function TRSFairyRing.GetLogCodes(out boxes: TBoxArray): TStringArray;
function TRSFairyRing.GetLogCodes(): TStringArray; overload;
```
Returns the visible codes in the fairy ring travel log.

Example:
```pascal
 WriteLn FairyRing.GetLogCodes();
```
*)
function TRSFairyRing.GetLogCodes(out boxes: TBoxArray): TStringArray;
const
  COLORS: TColorArray = [$3F3FFF, $7F7FFF];
var
  tpa: TPointArray;
  atpa: T2DPointArray;
  i: Int32;
  str: String;
begin
  tpa := Target.FindColor($3F3FFF, 0, Self.Scroll.Area) +
         Target.FindColor($7F7FFF, 0, Self.Scroll.Area);
  if tpa = [] then
    Exit;

  atpa := tpa.Cluster(8, 1).SortByY(True);

  boxes := atpa.BoundsArray();
  for i := 0 to High(boxes) do
  begin
    str := OCR.Recognize(boxes[i], RSFonts.PLAIN_12, COLORS, 0);
    Result += str.Replace(' ', '');

    boxes[i].X2 := Self.Scroll.Area.X2 - 22;
    if i = High(boxes) then
      boxes[i].Y2 := Self.Scroll.Area.Y2 - 6
    else
      boxes[i].Y2 := boxes[i+1].Y1 - 7;
  end;
end;

function TRSFairyRing.GetLogCodes(): TStringArray; overload;
const
  COLORS: TColorArray = [$3F3FFF, $7F7FFF];
var
  tpa: TPointArray;
  atpa: T2DPointArray;
  i: Int32;
  str: String;
  boxes: TBoxArray;
begin
  tpa := Target.FindColor($3F3FFF, 0, Self.Scroll.Area) +
         Target.FindColor($7F7FFF, 0, Self.Scroll.Area);
  if tpa = [] then
    Exit;

  atpa := tpa.Cluster(8, 1).SortByY(True);

  boxes := atpa.BoundsArray();
  for i := 0 to High(boxes) do
  begin
    str := OCR.Recognize(boxes[i], RSFonts.PLAIN_12, COLORS, 0);
    Result += str.Replace(' ', '');
  end;
end;


(*
## FairyRing.FindLogCode
```pascal
function TRSFairyRing.FindLogCode(code: String; out b: TBox): Boolean;
function TRSFairyRing.FindLogCode(code: String): Boolean; overload;
```
Finds the code specified in the travel log. Codes casing is ignored.

Example:
```pascal
 WriteLn FairyRing.FindLogCode('cip');
```
*)
function TRSFairyRing.FindLogCode(code: String; out b: TBox): Boolean;
  function _DoScrolling(code: String; direction: Boolean; out b: TBox): Boolean;
  var
    limit, i: Int32;
    boxes: TBoxArray;
  begin
    if direction then
      limit := 100;

    Mouse.Move(Self.Scroll.Area, True);
    while Self.Scroll.CanScroll() and (Self.Scroll.GetLevel() <> limit) do
    //begin
    //  Mouse.Scroll(Antiban.GetUniqueInt(4, 2, 7), direction);
    //  i := Self.GetLogCodes(boxes).Find(code);
    //  if i > -1 then
    //  begin
    //    b := boxes[i];
    //    Exit(True);
    //  end;
    //  Antiban.BioWait(150, 300);
    //end;
  end;

var
  i, scroll: Int32;
  direction: Boolean;
  boxes: TBoxArray;
begin
  code := code.Replace(' ', '').ToUpper();
  if not Self.IsCodeValid(code) then
    raise GetDebugLn('FairyRing', '"' + code + '" is not a valid fairy ring code.');

  i := Self.GetLogCodes(boxes).IndexOf(code);
  if i > -1 then
  begin
    b := boxes[i];
    Exit(True);
  end;

  //scroll := Self.TravelLog.GetScrollPosition();
  direction := InRange(scroll, 0, 3);
  if not direction then
    direction := not InRange(scroll, 97, 100) and Biometrics.RandomBoolean();

  if _DoScrolling(code, direction, b) then
    Exit(True);

  if InRange(scroll, 0, 3) or InRange(scroll, 97, 100) then
    Exit; //scrolled everything and was not found.

  Result := _DoScrolling(code, not direction, b);
end;

function TRSFairyRing.FindLogCode(code: String): Boolean; overload;
var
  b: TBox;
begin
  Result := Self.FindLogCode(code, b);
end;


(*
## FairyRing.ClickLogCode
```pascal
function TRSFairyRing.ClickLogCode(code: String): Boolean;
```
Finds and clicks the code specified in the travel log. Codes casing is ignored.

Example:
```pascal
 WriteLn FairyRing.ClickLogCode('cip');
```
*)
function TRSFairyRing.ClickLogCode(code: String): Boolean;
var
  b: TBox;
begin
  code := code.Replace(' ', '').ToUpper();
  if Self.Code = code then
    Exit(True);

  if Self.FindLogCode(code, b) then
  begin
    Mouse.Click(b, EMouseButton.LEFT);
    Result := SleepUntil(Self.Code = code, 300, 5000);
  end;
end;


(*
## FairyRing.HandleInterface
```pascal
function TRSFairyRing.HandleInterface(code: String): Boolean;
```
Completely handles the fairy ring interface to set a code and teleport.
Will use both the log and the dials depending on the user biohash.

Example:
```pascal
 WriteLn FairyRing.HandleInterface('cip');
```
*)
function TRSFairyRing.HandleInterface(fairyCode: String): Boolean;
begin
  if Biometrics.RandomBoolean(0.7) then  //use travel log or dial code...
  begin
    if not Self.ClickLogCode(fairyCode) then
      Exit;
  end
  else if not Self.Code[fairyCode] then
    Exit;

  Result := Self.ClickTeleport(); //TODO: Add some kind of teleport confirmation
end;


(*
## FairyRing.Teleport
```pascal
function TRSFairyRing.Teleport(code: String; walk: Boolean = True): Boolean;
```
Teleports the user to the specified fairy ring code.
If the fairy ring interface is not open, the **RSObject** will be used to find the closest one and open it.
If the code is on the right click context menu, it will be used.
You can also optional pass in "Zanaris" or "BKS" to go to zanaris.

Example:
```pascal
 WriteLn FairyRing.Teleport('cip');
```
*)
function TRSFairyRing.Teleport(code: String; cuboid: TCuboid): Boolean;
var
  contextMenuTeleport: Boolean;
begin
  if MSInterface.IsOpen() and not MSInterface.Close() then
    Exit;

  code := code.Replace(' ', '',).ToUpper();
  if code = 'ZANARIS' then
    code := 'BKS';

  if Self.IsOpen() then
    Exit(Self.HandleInterface(code));

  if code = 'BKS' then
    code := 'Zanaris';

  Mouse.Move(cuboid.ShapeFill().RandomMean());
  if not MainScreen.IsUpText('Fairy ring') then
    Exit;

  contextMenuTeleport := ChooseOption.Select(code, False, False);
  if not contextMenuTeleport then
    if not ChooseOption.Select('onfigure', False, True) then
      Exit;

  Minimap.WaitMoving();

  if contextMenuTeleport then
    Exit(True);

  if SleepUntil(Self.IsOpen(), RandomMode(100, 50, 1500), 3000) then
    Result := Self.HandleInterface(code);
end;

(*
## var FairyRing
Global FairyRing variable.
*)
var
  FairyRing: TRSFairyRing;
