(*
# FairyRing
Methods to interact with the Fairy rings interface:
```{figure} ../../images/fairyring.png
```
*)

{$DEFINE WL_FAIRYRING_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
(*
## ERSFairyRingDial
```pascal
ERSFairyRingDial = enum(LEFT, MIDDLE, RIGHT);
```
Enum representing the {ref}`FairyRing` dials available.
*)
  ERSFairyRingDial = enum(LEFT, MIDDLE, RIGHT);

(*
## TRSFairyRing
Record responsible with interacting with the {ref}`FairyRing`.
*)
  TRSFairyRing = record
    Bounds: TBox;
    Title: TRSInterfaceTitle;
    Scroll: TRSScrollBar;

    TeleportButton: TBox;

    Dials: array [ERSFairyRingDial] of String;
    DialBoxes, DialHoles, RotateLeftBoxes, RotateRightBoxes: TBoxArray;
    Item: TRSItem;
  end;

(*
## FairyRing.Setup
```pascal
procedure FairyRing.Setup();
```
Initializes TRSFairyRing variables.

```{note}
This is automatically called on the `FairyRing` variable.
```
*)
procedure TRSFairyRing.Setup();
begin
  Self.Dials[ERSFairyRingDial.LEFT] := 'ADCB';
  Self.Dials[ERSFairyRingDial.MIDDLE] := 'ILKJ';
  Self.Dials[ERSFairyRingDial.RIGHT] := 'PSRQ';
end;

function TRSFairyRing.IsOpen(): Boolean; forward;

procedure TRSFairyRing.SetupInterface();
var
  b: TBox;
begin
  case RSClient.Mode of
    ERSMode.FIXED: Self.Bounds := MSInterface.CreateBounds([0, 2, 0, 0], 500, 316);
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Bounds := MSInterface.CreateBounds([0, 1, 0, 0], 500, 316);
  end;

  with Self.Bounds do
  begin
    Self.Title.Bounds := [X1+178, Y1+25, X2-178, Y1+50];
    Self.Title.CloseButton := [X2-27, Y1+1, X2-6, Y1+21];
    Self.TeleportButton := [X1+170, Y2-65, X2-170, Y2-28];
  end;

  Self.Title.TitleColor := RSFonts.BROWN;

  Self.Title.IsOpen := @Self.IsOpen;
  Self.Title.Font := @RSFonts.QUILL_8;

  with GameTab.Bounds do
    Self.Scroll.Area := [X1+3, Y1+41, X2-19, Y2-6];
  Self.Scroll.Setup();

  Self.DialBoxes := TBoxArray.Create(Self.Bounds.TopLeft + [2,80], 3, 1, 159, 155, [11,0]);
  Self.DialBoxes[2].X1 -= 2;
  Self.DialBoxes[2].X2 -= 2;

  for b in Self.DialBoxes do
  begin
    Self.DialHoles += [b.X1+58, b.Y2-55, b.X2-58, b.Y2-10];
    Self.RotateLeftBoxes += [b.X1, b.Y1, b.X2-80, b.Y2];
    Self.RotateRightBoxes += [b.X1+80, b.Y1, b.X2, b.Y2];
  end;
end;


(*
## FairyRing.IsOpen
```pascal
function TRSFairyRing.IsOpen(): Boolean;
```
Returns true/false whether the FairyRing interface is open or not.

Example:
```pascal
WriteLn FairyRing.IsOpen();
```
*)
function TRSFairyRing.IsOpen(): Boolean;
begin
  Result := Self.Title.IsTitle('Choose a combination');
end;

(*
## FairyRing.WaitOpen
```pascal
function TRSFairyRing.WaitOpen(time: Integer; interval: Integer = -1): Boolean;
```
Returns true if the fairy ring interface is open within `time` milliseconds.

## Example:
```pascal
WriteLn FairyRing.WaitOpen();
```
*)
function TRSFairyRing.WaitOpen(time: Integer; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(), interval, time);
end;


(*
## FairyRing.Close
```pascal
function TRSFairyRing.Close(escape: Boolean): Boolean;
function TRSFairyRing.Close(escapeProbability: Double = BioHash): Boolean; overload;
```
Closes the {ref}`FairyRing` interface, depending on `escape` the function will either
press escape or click the close button:
```{figure} ../../images/fairyring_closebtn.png
```

Example:
```pascal
WriteLn FairyRing.Close();
```
*)
function TRSFairyRing.Close(escape: Boolean): Boolean;
begin
  Result := Self.Title.Close(escape);
end;

function TRSFairyRing.Close(escapeProbability: Single = -1): Boolean; overload;
begin
  Result := Self.Title.Close(escapeProbability);
end;


(*
## FairyRing.HandleItem
```pascal
function TRSFairyRing.HandleItem(): Boolean;
```
Magically finds, caches for next usages and equips dramen or lunar staff with the minimum tab opening possible.
If no item is found, we will assume the user has the elite lumbridge and draynor diary complete for next uses.

Example:
```pascal
 if FairyRing.HandleItem() then
WriteLn FairyRing.Item;
```
*)
function TRSFairyRing.HandleItem(attempts: Int32 = 2): Boolean;
begin
  Result := attempts = 2; //Todo...
end;



(*
## FairyRing.Open
```pascal
function TRSFairyRing.Open(cuboid: TCuboid): Boolean;
```
Attempts to open the closest fairy ring RSObject.

Example:
```pascal
 WriteLn FairyRing.Open();
```
*)
function TRSFairyRing.Open(cuboid: TCuboid): Boolean;
begin
  if MSInterface.IsOpen() and not MSInterface.Close() then
    Exit;

  if Self.IsOpen() then
    Exit(True);

  if not Self.HandleItem() then
    Exit;

  if not MainScreen.Interact(cuboid.ShapeFill().RandomMean(), ['onfigure']) then
    Exit;

  Minimap.WaitMoving();
  Result := SleepUntil(Self.IsOpen(), RandomMode(100, 50, 1500), 2000);
end;

(*
## FairyRing.IsLetterValid
```pascal
function TRSFairyRing.IsLetterValid(letter: Char; dial: ERSFairyRingDial): Boolean;
```
Checks if the `letter` passed on is valid for the given `dial`.

Example:
```pascal
WriteLn FairyRing.IsLetterValid('z', ERSFairyRingDial.LEFT);
```
*)
function TRSFairyRing.IsLetterValid(letter: Char; dial: ERSFairyRingDial): Boolean;
begin
  Result := Self.Dials[dial].Contains(letter);
end;

(*
## FairyRing.IsCodeValid
```pascal
function TRSFairyRing.IsCodeValid(fairyCode: String): Boolean;
```
Checks if the a given `fairyCode` is a valid fairy ring code.

Example:
```pascal
WriteLn FairyRing.IsCodeValid('abc');
```
*)
function TRSFairyRing.IsCodeValid(fairyCode: String): Boolean;
var
  i: Int32;
begin
  if Length(fairyCode) <> 3 then
    Exit;

  for i := 1 to Length(fairyCode) do
    if not Self.IsLetterValid(fairyCode[i], ERSFairyRingDial(i-1)) then
      Exit;

  Result := True;
end;


(*
## FairyRing.Spin
```pascal
procedure TRSFairyRing.SpinLeft(dial: ERSFairyRingDial);
procedure TRSFairyRing.SpinRight(dial: ERSFairyRingDial);
```
Spins the given `dial` left or right.

Example:
```pascal
WriteLn FairyRing.SpinLeft(ERSFairyRingDial.LEFT);
```

If you want, you can see the left and right dial blick boxes with the following
code:
```pascal
{$I WaspLib/osrs.simba}
begin
  ShowOnTarget(FairyRing.RotateLeftBoxes + FairyRing.RotateRightBoxes);
end.
```
```{figure} ../../images/fairyring_dialspinboxes.png
```
*)
procedure TRSFairyRing.SpinLeft(dial: ERSFairyRingDial);
begin
  Mouse.Click(Self.RotateLeftBoxes[dial], EMouseButton.LEFT);
end;

procedure TRSFairyRing.SpinRight(dial: ERSFairyRingDial);
begin
  Mouse.Click(Self.RotateRightBoxes[dial], EMouseButton.LEFT);
end;


(*
## FairyRing.Letter
```pascal
property TRSFairyRing.Letter(dial: ERSFairyRingDial): Char;
property TRSFairyRing.Letter(character: Char; dial: ERSFairyRingDial): Boolean;
```
Returns or sets the letter of a fairy ring dial.

Example:
```pascal
WriteLn FairyRing.Letter[ERSFairyRingDial.RIGHT];
WriteLn FairyRing.Letter['p', ERSFairyRingDial.RIGHT];
WriteLn FairyRing.Letter[ERSFairyRingDial.RIGHT];
```

The letter in question that will be read or set is the one that is in the dial
"hole":
```pascal
{$I WaspLib/osrs.simba}
begin
  ShowOnTarget(FairyRing.DialHoles);
end.
```
```{figure} ../../images/fairyring_dialholes.png
```
*)
property TRSFairyRing.Letter(dial: ERSFairyRingDial): Char;
var
  count: integer;
begin
  count := Target.CountColor([$49153B, 6.713, EColorSpace.HSV, [1.631, 0.429, 0.942]], Self.DialHoles[dial]);

  case dial of
    ERSFairyRingDial.LEFT:
    case count of
      172: Result := 'A';
      198: Result := 'D';
      80 : Result := 'C';
      125: Result := 'B';
      else Result := 'n';
    end;

    ERSFairyRingDial.Middle:
    case count of
      52 : Result := 'L';
      98 : Result := 'K';
      66 : Result := 'J';
      65 : Result := 'I';
      else Result := 'n';
    end;

    ERSFairyRingDial.Right:
    case count of
      100 : Result := 'S';
      81 : Result := 'R';
      63 : Result := 'Q';
      85 : Result := 'P';
      else Result := 'n';
    end;
  end;
end;

property TRSFairyRing.Letter(character: Char; dial: ERSFairyRingDial): Boolean;
  function _FindChar(str: String; character: Char): Integer;
  begin
    for Result := 1 to Length(str) do
      if character = str[Result] then
        Exit;
    Result := -1;
  end;
type
  TDialSpin = record
    Moves: Integer;
    Direction: Boolean;
  end;
var
  current: Char;
  available: String;
  i, j: Integer;
  spins: TDialSPin;
begin
  if not Self.IsLetterValid(character, dial) then
    raise GetDebugLn('FairyRing', '"' + UpperCase(character) + '" is not a valid letter for fairy ring ' + ToStr(dial) + ' dial.');

  current := Self.Letter[dial];
  if current = character then
    Exit(True);

  available := Self.Dials[dial];
  i := _FindChar(available, current);
  j := _FindChar(available, character);

  case i - j of
    -3, 1: if Biometrics.RandomBoolean(0.8) then spins := [1, False] else spins := [3, True];
    -2, 2: if Biometrics.RandomBoolean(0.5) then spins := [2, False] else spins := [2, True];
    -1, 3: if Biometrics.RandomBoolean(0.8) then spins := [1, True] else spins := [3, False];
  end;

  for i := 1 to spins.Moves do
  begin
    if spins.Direction then
      Self.SpinRight(dial)
    else
      Self.SpinLeft(dial);
    Biometrics.Sleep(100, 300);
  end;

  Result := True;
end;


(*
## FairyRing.Code
```pascal
property TRSFairyRing.Code: String;
property TRSFairyRing.Code(code: String): Boolean;
```
Returns the current fairy ring code or sets the new one in the dials.

Example:
```pascal
WriteLn FairyRing.Code;
WriteLn FairyRing.Code['DLP'];
WriteLn FairyRing.Code;
```
*)
property TRSFairyRing.Code: String;
var
  dial: ERSFairyRingDial;
begin
  for dial := Low(ERSFairyRingDial) to High(ERSFairyRingDial) do
    Result += Self.Letter[dial];
end;

property TRSFairyRing.Code(fairyCode: String): Boolean;
var
  attempt, i: Integer;
begin
  fairyCode := fairyCode.Replace(' ', '').ToUpper();
  if not Self.IsCodeValid(fairyCode) then
    raise GetDebugLn('FairyRing', '"' + fairyCode + '" is not a valid fairy ring code.');

  for attempt := 0 to 2 do
  begin
    if fairyCode = Self.Code then
      Exit(True);

    for i := 0 to 2 do
    begin
      if not Self.Letter[fairyCode[i+1], ERSFairyRingDial(i)] then
        Continue(2);
      Biometrics.Sleep(150, 1200);
    end;

    if SleepUntil(fairyCode = Self.Code, 300, 3000) then
      Exit(True);
  end;
end;

(*
## FairyRing.ClickTeleport
```pascal
function TRSFairyRing.ClickTeleport(): Boolean;
```
Clicks the fairy ring the teleport button:
```{figure} ../../images/fairyring_teleportbtn.png
```

Example:
```pascal
WriteLn FairyRing.ClickTeleport();
```
*)
function TRSFairyRing.ClickTeleport(): Boolean;
begin
  if not Self.IsOpen() then
    Exit;
  Mouse.Click(Self.TeleportButton, EMouseButton.LEFT);
  Result := SleepUntil(not Self.IsOpen(), 300, 3000);
end;

(*
## FairyRing TravelLog
This next section is about the fairy ring travel log {ref}`GameTab` menu:
```{figure} ../../images/fairyring_travellog.png
```
*)

(*
### FairyRing.GetLogCodes
```pascal
function TRSFairyRing.GetLogCodes(out boxes: TBoxArray): TStringArray;
function TRSFairyRing.GetLogCodes(): TStringArray; overload;
```
Returns the visible codes in the fairy ring travel log.

Example:
```pascal
{$I WaspLib/osrs.simba}
var
  logs: TStringArray;
  boxes: TBoxArray;
begin
  logs := FairyRing.GetLogCodes(boxes);
  if logs <> [] then
  begin
    WriteLn logs;
    ShowOnTarget(boxes);
  end;
end.
```
```{figure} ../../images/fairyring_logs.png
```
*)
function TRSFairyRing.GetLogCodes(out boxes: TBoxArray): TStringArray;
var
  tpa: TPointArray;
  atpa: T2DPointArray;
  i: Int32;
  str: String;
begin
  tpa := Target.FindColor([$5F5FFF, 0.559, EColorSpace.RGB, [2.824, 0.089, 0.089]], Self.Scroll.Area);
  if tpa = [] then
    Exit;

  atpa := tpa.Cluster(9, 1.5).SortByY(True);

  boxes := atpa.BoundsArray();
  for i := 0 to High(boxes) do
  begin
    str := OCR.Recognize(boxes[i], RSFonts.PLAIN_12, [$3F3FFF, $7F7FFF], 0);
    Result += str.Replace(' ', '');

    boxes[i].X1 := Self.Scroll.Area.X1 + 21;
    boxes[i].X2 := Self.Scroll.Area.X2;
    if i = High(boxes) then
      boxes[i].Y2 := Self.Scroll.Area.Y2 - 6
    else
      boxes[i].Y2 := Min(boxes[i+1].Y1 - 8, boxes[i].Y1+37);
  end;
end;

function TRSFairyRing.GetLogCodes(): TStringArray; overload;
var
  boxes: TBoxArray;
begin
  Result := Self.GetLogCodes(boxes);
end;


(*
### FairyRing.FindLogCode
```pascal
function TRSFairyRing.FindLogCode(code: String; out b: TBox): Boolean;
function TRSFairyRing.FindLogCode(code: String): Boolean; overload;
```
Finds the code specified in the travel log. Codes casing is ignored.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  b: TBox;
begin
  if FairyRing.FindLogCode('ALQ', b) then
    ShowOnTarget(b);
end.
```
```{figure} ../../images/fairyring_findlog.png
```
*)
function TRSFairyRing.FindLogCode(fairyCode: String; out bounds: TBox): Boolean;
  function _DoScrolling(fairyCode: String; direction: Boolean; out bounds: TBox): Boolean;
  var
    limit, i: Int32;
    boxes: TBoxArray;
  begin
    if direction then
      limit := 100;

    Mouse.Move(Self.Scroll.Area, True);
    repeat
      Mouse.Scroll(Biometrics.RandomModeInteger(4, 2, 7), direction);
      Biometrics.Sleep(400, 800);
      i := Self.GetLogCodes(boxes).IndexOf(fairyCode);
      if i > -1 then
      begin
        bounds := boxes[i];
        Exit(True);
      end;
    until not Self.Scroll.CanScroll() or (Self.Scroll.GetLevel() = limit);
  end;
var
  i, scroll: Int32;
  direction: Boolean;
  boxes: TBoxArray;
begin
  fairyCode := fairyCode.Replace(' ', '').ToUpper();
  if not Self.IsCodeValid(fairyCode) then
    raise GetDebugLn('FairyRing', '"' + fairyCode + '" is not a valid fairy ring code.');

  i := Self.GetLogCodes(boxes).IndexOf(fairyCode);
  if i > -1 then
  begin
    bounds := boxes[i];
    Exit(True);
  end;

  scroll := Self.Scroll.GetLevel();
  direction := InRange(scroll, 0, 3);
  if not direction then
    direction := not InRange(scroll, 97, 100) and Biometrics.RandomBoolean();

  if _DoScrolling(fairyCode, direction, bounds) then
    Exit(True);

  if InRange(scroll, 0, 3) or InRange(scroll, 97, 100) then
    Exit; //scrolled everything and was not found.

  Result := _DoScrolling(fairyCode, not direction, bounds);
end;

function TRSFairyRing.FindLogCode(code: String): Boolean; overload;
var
  b: TBox;
begin
  Result := Self.FindLogCode(code, b);
end;


(*
### FairyRing.ClickLogCode
```pascal
function TRSFairyRing.ClickLogCode(fairyCode: String): Boolean;
```
Finds and clicks the `fairyCode` specified in the travel log.
Codes casing is ignored.

Example:
```pascal
WriteLn FairyRing.ClickLogCode('cip');
```
*)
function TRSFairyRing.ClickLogCode(fairyCode: String): Boolean;
var
  b: TBox;
begin
  fairyCode := fairyCode.Replace(' ', '').ToUpper();
  if Self.Code = fairyCode then
    Exit(True);

  if Self.FindLogCode(fairyCode, b) then
  begin
    Mouse.Click(b, EMouseButton.LEFT);
    Result := SleepUntil(Self.Code = fairyCode, 300, 5000);
  end;
end;


(*
## FairyRing.HandleInterface
```pascal
function TRSFairyRing.HandleInterface(code: String): Boolean;
```
Completely handles the fairy ring interface to set a code and teleport.
Will use both the log and the dials depending on the user biohash.

Example:
```pascal
WriteLn FairyRing.HandleInterface('cip');
```
*)
function TRSFairyRing.HandleInterface(fairyCode: String): Boolean;
begin
  if Biometrics.RandomBoolean(0.6) then  //use travel log or dial code...
  begin
    if not Self.ClickLogCode(fairyCode) then
      Exit;
  end
  else
  if not Self.Code[fairyCode] then
    Exit;

  Result := Self.ClickTeleport(); //TODO: Add some kind of teleport confirmation
end;


(*
## FairyRing.Teleport
```pascal
function TRSFairyRing.Teleport(fairyCode: String; cuboid: TCuboid): Boolean;
```
Teleports the user to the specified fairy ring code.
If the fairy ring interface is not open, the `RSObject` will be used to find the closest one and open it.
If the code is on the right click context menu, it will be used.
You can also optional pass in "Zanaris" or "BKS" to go to zanaris.

Example:
```pascal
WriteLn FairyRing.Teleport('cip');
```
*)
function TRSFairyRing.Teleport(fairyCode: String; cuboid: TCuboid): Boolean;
var
  contextMenuTeleport: Boolean;
begin
  if MSInterface.IsOpen() and not MSInterface.Close() then
    Exit;

  fairyCode := fairyCode.Replace(' ', '',).ToUpper();
  if fairyCode = 'ZANARIS' then
    fairyCode := 'BKS';

  if Self.IsOpen() then
    Exit(Self.HandleInterface(fairyCode));

  if fairyCode = 'BKS' then
    fairyCode := 'Zanaris';

  Mouse.Move(cuboid.ShapeFill().RandomMean());
  if not MainScreen.IsUpText('Fairy ring') then
    Exit;

  contextMenuTeleport := ChooseOption.Select(fairyCode, False, False);
  if not contextMenuTeleport then
    if not ChooseOption.Select('onfigure', False, True) then
      Exit;

  Minimap.WaitMoving();

  if contextMenuTeleport then
    Exit(True);

  if SleepUntil(Self.IsOpen(), RandomMode(100, 50, 1500), 3000) then
    Result := Self.HandleInterface(fairyCode);
end;


var
(*
## FairyRing variable
Global {ref}`TRSFairyRing` variable.
*)
  FairyRing: TRSFairyRing;
