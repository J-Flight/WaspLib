

{$DEFINE WL_XPBAR_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  ERSXPBarSize = enum(UNKNOWN, SMALL, MEDIUM, LARGE);


  ERSXPBarPosition = enum(UNKNOWN, LEFT, CENTER, RIGHT);


  TRSXPBar = record
    Size: ERSXPBarSize;
    Position: ERSXPBarPosition;

    Bounds: TBox;
    Font: TPixelFont;

    AvailableBounds: TBoxArray;

    Button: TCircle;

    SetupAttempts: Integer;

    Tracker: record
      Start: UInt64;
      Current: UInt64;
      Previous: UInt64;
    end;
  end;


procedure TRSXPBar.UpdateSize();
begin
  case Self.Size of
    ERSXPBarSize.UNKNOWN: Exit;
    ERSXPBarSize.SMALL:
    begin
      with Self.AvailableBounds[ERSXPBarPosition.LEFT-1] do X2 := X1 + 118;
      with Self.AvailableBounds[ERSXPBarPosition.RIGHT-1] do X1 := X2 - 118;
      with Self.AvailableBounds[ERSXPBarPosition.CENTER-1] do
      begin
        X1 += 10;
        X2 -= 11;
      end;
    end;

    ERSXPBarSize.MEDIUM:
    begin
      with Self.AvailableBounds[ERSXPBarPosition.LEFT-1] do X2 := X1 + 128;
      with Self.AvailableBounds[ERSXPBarPosition.RIGHT-1] do X1 := X2 - 128;
      with Self.AvailableBounds[ERSXPBarPosition.CENTER-1] do
      begin
        X1 += 5;
        X2 -= 6;
      end;
    end;
  end;

  if Self.Position <> ERSXPBarPosition.UNKNOWN then
    Self.Bounds := Self.AvailableBounds[Self.Position-1];

  with Self.Bounds do
    MainScreen.AddMask([X1, Y1, X2, Y2+1]);
end;


procedure TRSXPBar.SetupInterface();
begin
  case RSClient.Mode of
    ERSMode.RESIZABLE, ERSMode.MODERN_COMPACT, ERSMode.MODERN_WIDE:
      Self.Button := [Minimap.Bounds.X1 - 40, Minimap.Bounds.Y1 + 32,  11];

    ERSMode.FIXED:
      Self.Button := [Minimap.Bounds.X1 - 40, Minimap.Bounds.Y1 + 26,  11];
  end;

  MainScreen.AddMask(TPointArray.CreateFromCircle(Self.Button.Center, Self.Button.Radius + 2, True));

  SetLength(Self.AvailableBounds, 3);

  with Self.AvailableBounds[ERSXPBarPosition.LEFT-1] do
  begin
    X1 := MainScreen.Bounds.X1 + 2;
    X2 := X1 + 139;
    Y1 := MainScreen.Bounds.Y1 + 25;
    Y2 := Y1 + 27;
  end;

  with Self.AvailableBounds[ERSXPBarPosition.CENTER-1] do
  begin
    X1 := MSInterface.Bounds.X1 + (MSInterface.Width) div 2 - 69;
    Y1 := MainScreen.Bounds.Y1 + 25;
    X2 := X1 + 139;
    Y2 := Y1 + 27;
  end;

  with Self.AvailableBounds[ERSXPBarPosition.RIGHT-1] do
  begin
    X2 := MSInterface.Bounds.X2 - 2;
    X1 := X2 - 139;
    Y1 := MainScreen.Bounds.Y1 + 2;
    Y2 := Y1 + 27;
  end;

  Self.UpdateSize();
end;



function TRSXPBar.IsOpen(): Boolean;
begin
  Result := Target.HasColor($B0E4EF, 0, 50, Self.Button.Bounds);
end;


function TRSXPBar.WaitOpen(time: Integer = 600; interval: Integer = -1): Boolean;
begin
  if interval = -1 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(), interval, time);
end;


function TRSXPBar.Open(): Boolean;
begin
  if Self.IsOpen() then Exit(True);
  Mouse.Click(Self.Button, EMouseButton.LEFT);
  Result := Self.WaitOpen();
end;


function TRSXPBar.Close(): Boolean;
begin
  if not Self.IsOpen() then Exit(True);
  Mouse.Click(Self.Button, EMouseButton.LEFT);
  Result := SleepUntil(Self.IsOpen(), RandomMode(100, 50, 1500), 600);
end;



function TRSXPBar.Setup(): Boolean;
var
  position: ERSXPBarPosition;
  tpa: TPointArray;
begin
  if not Self.Open() then Exit;
  if (Self.Size <> ERSXPBarSize.UNKNOWN) and (Self.Position <> ERSXPBarPosition.UNKNOWN) then
    Exit(True);

  Self.SetupAttempts += 1;

  for position := ERSXPBarPosition.LEFT to ERSXPBarPosition.RIGHT do
  begin
    tpa := Target.FindColor($FFFFFF, 0, Self.AvailableBounds[position-1]);
    if tpa = [] then Continue;
    if not Target.HasColor($233038, 0, 30, Self.AvailableBounds[position-1]) then Continue;

    case tpa.Bounds().Height of
      8:
      begin
        Self.Size := ERSXPBarSize.SMALL;
        Self.Font := RSFonts.PLAIN_11;
      end;

      11:
      begin
        Self.Size := ERSXPBarSize.MEDIUM;
        Self.Font := RSFonts.PLAIN_12;
      end;

      10:
      begin
        Self.Size := ERSXPBarSize.LARGE;
        Self.Font := RSFonts.BOLD;
      end;

      else Continue;
    end;

    Self.Position := position;
    Self.UpdateSize();

    Exit(True);
  end;

  if Self.SetupAttempts < 3 then Exit;
  WriteLn GetDebugLn('XPBar', 'Something seems to be wrong with your XPBar.', ELogLevel.WARN);
  WriteLn GetDebugLn('XPBar', 'If you keep seeing this message fix your XPBar settings!', ELogLevel.WARN);
end;



function TRSXPBar.Read: UInt64;
var
  str: String;
  count: Integer;
begin
  if not Self.Setup then Exit;

  str := OCR.Recognize(Self.Bounds, Self.Font, [$FFFFFF], 0);

  Result := str.ExtractInteger(0);
  if Result = 0 then Exit;
  count := Target.CountColor($010000, 0, Self.Bounds);

  if ((count <> 45) and (not InRange(count, 141, 150))) then
  begin
    WriteLn GetDebugLn('XPBar', 'Your XPBar doesn''t seem to be set to count "Total Experience"', ELogLevel.WARN);
    WriteLn GetDebugLn('XPBar', 'XP Tracking won''t be used and this can cause issues.', ELogLevel.WARN);
  end;

  if Self.Tracker.Start = 0 then Self.Tracker.Start := Result;
  if Self.Tracker.Previous = 0 then Self.Tracker.Previous := Result;
  Self.Tracker.Current := Result;
end;


function TRSXPBar.EarnedXP(): Boolean;
begin
  Result := Self.Read() > Self.Tracker.Previous;

  if Result then
    Self.Tracker.Previous := Self.Tracker.Current;
end;


function TRSXPBar.WaitXP(time: Integer = 600; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.EarnedXP(), interval, time);
end;



function TRSXPBar.TotalEarnedXP(update: Boolean = True): UInt64;
begin
  if update then Self.Read();
  Result := Self.Tracker.Current - Self.Tracker.Start;
end;

var

  XPBar: TRSXPBar;
