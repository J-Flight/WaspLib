
{$DEFINE WL_CHAT_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  ERSChatColor = enum(
    BLACK, MAROON, BLUE, PURPLE, RED, LIGHT_RED, WHITE, LIGHT_PURPLE, NAVY, GREEN
  );

  ERSChatColorArray = array of ERSChatColor;


  ERSIronMan = enum(NONE, IRONMAN, HARDCORE, ULTIMATE, GROUP, HARCORE_GROUP, UNRANKED_GROUP);


  TRSChat = record
    Bounds: TBox;
    Scroll: TRSScrollBar;
    Tabs: TRSChatTabs;

    MessageLines: TBoxArray;
    InputLine: TBox;
    ReportButton: TRSButton;
    const Colors: array [ERSChatColor] of TColor = [$000000, $7F0000, $FF0000, $7F007F, $2010EF, $0000FF, $FFFFFF, $FF9090, $800000, $005F00];
  end;


procedure TRSChat.SetupInterface();
begin
  Self.Tabs.SetupInterface();
  Self.ReportButton.EnabledColors := [[1555,6], [5399922, 0], [795452, 0]];

  with Self.Tabs.Bounds do
  begin
    Self.ReportButton.Bounds := TBox.Create(X1 + 436, Y1,  X1 + 515, Y2 - 1);
    Self.Bounds.X1 := X1;
    Self.Bounds.X2 := X2;
    Self.Bounds.Y1 := Y1 - 142;
    Self.Bounds.Y2 := Y1 - 1;
  end;

  with Self.Bounds do
    Self.MessageLines := TBoxArray.Create(TopLeft + [10, 8], 1, 9, Width - 34, 13, [0, 1]);

  Self.InputLine := Self.MessageLines.Pop;
  Self.InputLine.X2 += 17;
  Self.InputLine.Y2 += 2;

  Self.Scroll.Area.X1 := Self.Bounds.X1 + 6;
  Self.Scroll.Area.Y1 := Self.Bounds.Y1 + 6;
  Self.Scroll.Area.X2 := Self.Bounds.X2 - 23;
  Self.Scroll.Area.Y2 := Self.InputLine.Y1 - 1;

  Self.Scroll.Setup();
end;




function TRSChat.GetColors(colors: ERSChatColorArray): TColorArray;
var
  c: ERSChatColor;
begin
  for c in colors do Result += Self.Colors[c];
end;



function TRSChat.GetDisplayNameBox(out color: Integer): TBox;
var
  b: TBox;
  tpa: TPointArray;
begin
  b.X1 := Self.InputLine.X1;
  b.Y1 := Self.InputLine.Y1;
  b.X2 := b.X1 + Self.InputLine.Width div 4;
  b.Y2 := Self.InputLine.Y2;

  for color in [$FFFFFF, $000000] do
  begin
    tpa := Target.FindColor(color, 0, b);
    if tpa <> [] then Exit(tpa.Bounds());
  end;
end;

function TRSChat.GetDisplayNameBox(): TBox; overload;
var
  color: Integer;
begin
  Result := Self.GetDisplayNameBox(color);
end;


function TRSChat.GetDisplayName(): String;
var
  b: TBox;
begin
  b.X1 := Self.InputLine.X1;
  b.Y1 := Self.InputLine.Y1;
  b.X2 := b.X1 + Self.InputLine.Width div 4;
  b.Y2 := Self.InputLine.Y2;

  Result := OCR.RecognizeStatic(b, RSFonts.PLAIN_12, [$FFFFFF, $000000], 0);

  if ':' in Result then
    Result := Result.Before(':');
end;



function TRSChat.GetIronManType(): ERSIronMan;
var
  b: TBox;
begin
  b.X1 := Self.InputLine.X1;
  b.Y1 := Self.InputLine.Y1;
  b.X2 := Self.InputLine.X1 + 10;
  b.Y2 := Self.InputLine.Y2;

  if Target.HasColor([$484949, 1.216, EColorSpace.HSL, [0.018, 2.599, 0.385]], 1, b) then
  begin
    if Target.HasColor([$7E3C1A, 0.761, EColorSpace.HSL, [1.396, 1.396, 0.210]], 1, b) then
      Exit(ERSIronMan.GROUP);
    if Target.HasColor([$1A1A83, 0.817, EColorSpace.HSL, [1.977, 0.683, 0.342]], 1, b) then
      Exit(ERSIronMan.HARCORE_GROUP);
    if Target.HasColor([$5D801A, 1.2, EColorSpace.HSL, [1.345, 1.345, 0.312]], 1, b) then
      Exit(ERSIronMan.UNRANKED_GROUP);

    Exit(ERSIronMan.IRONMAN);
  end;

  if Target.HasColor([$1B1B57, 0.787, EColorSpace.HSL, [2.371, 0.206, 0.425]], 1, b) then
    Exit(ERSIronMan.HARDCORE);

  if Target.HasColor([$BFC1C1, 2.268, EColorSpace.HSL, [0.034, 2.779, 0.189]], 1, b) then
    Exit(ERSIronMan.ULTIMATE);
end;



function TRSChat.IsTransparent(): Boolean;
var
  b: TBox;
begin
  b.X1 := Self.InputLine.X1;
  b.Y1 := Self.InputLine.Y1;
  b.X2 := b.X1 + Self.InputLine.Width div 4;
  b.Y2 := Self.InputLine.Y2;

  Result := Target.CountColor($FFFFFF, 0, b) > 0;
end;



function TRSChat.IsOpen(): Boolean;
begin
  if RSClient.Mode = ERSMode.FIXED then Exit(True);
  Result := Self.Tabs.GetActive() <> ERSChatTab.NONE;
end;


function TRSChat.Close(): Boolean;
begin
  if RSClient.Mode = ERSMode.FIXED then Exit(False);
  if Self.Tabs.GetActive() = ERSChatTab.NONE then Exit(True);

  Self.Tabs.Get(Self.Tabs.GetActive()).Button.Click();
  Result := Self.Tabs.GetActive() = ERSChatTab.NONE;
end;





function TRSChat.GetQuery(): String;
begin
  Result := OCR.Recognize(Self.Bounds, RSFonts.BOLD, [$0], 0);
end;


function TRSChat.GetQueryAnswer(): String;
begin
  Result := OCR.Recognize(Self.Bounds, RSFonts.BOLD, [$800000], 0);
end;


function TRSChat.FindQuery(query: String; caseSensitive: Boolean = False): Boolean;
begin
  Result := Self.GetQuery().Contains(query, caseSensitive);
end;


function TRSChat.WaitQuery(query: String; caseSensitive: Boolean = False; time: Integer = 600; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.FindQuery(query, caseSensitive), interval, time);
end;


function TRSChat.AnswerQuery(query, answer: String; waitTime: Integer = 600; interval: Integer = -1): Boolean;
begin
  Result := Self.WaitQuery(query, False, waitTime, interval);
  if not Result then Exit;

  if Self.GetQueryAnswer() <> Answer then
    while Self.GetQueryAnswer() <> '*' do
      Target.KeyPress(EKeyCode.BACK);

  Keyboard.Send(answer, EKeyCode.RETURN);
end;



function TRSChat.GetMessage(line: Integer): String;
const
  BG_COLOR: TColorTolerance = [$6793AA, 3.287, EColorSpace.HSL, [2.025, 0.581, 0.395]];
  STATIC_OFFSET: Integer = 2;
var
  b: TBox;
  img: TImage;
  tpa: TPointArray;
  colors: TColorArray;
begin
  with Self.MessageLines[line] do
    b := [X1, Y1-STATIC_OFFSET, X2, Y2];

  if colors = [] then colors := Self.Colors;

  if not Self.IsTransparent() then
  begin
    tpa := Target.FindColor(BG_COLOR, b).Invert();
    colors := Target.GetColors(tpa).Unique();
    Exit(OCR.Recognize(b, RSFonts.PLAIN_12, colors, 0));
  end;

  img := Target.GetImage(b);

  // First shadow from above line draws over our line.
  // Mark the shadow as a match since OCR requires 100% character match.
  tpa := img.FindColor($000000, 0, [0, STATIC_OFFSET, img.Width, STATIC_OFFSET]);
  img.DrawColor := $FFFFFF;
  img.DrawTPA(tpa);

  // Now find shadows, offset by -1,-1 to find colors of text
  tpa := img.FindColor(0, 0, [1, 1, img.Width, img.Height]);
  tpa := tpa.Offset([-1,-1]).ExcludePoints(tpa);
  img.ReplaceColorBinary(False, img.GetColors(tpa).Unique, 0);

  Result := OCR.Engine.Recognize(img, RSFonts.PLAIN_12, [0,0]);
end;


function TRSChat.FindMessageLine(msg: String; caseSensitive: Boolean = False): Integer;
var
  i: Integer;
begin
  for i := 0 to High(Self.MessageLines) do
    if Self.GetMessage(i).Contains(msg, caseSensitive) then
      Exit(i);
  Result := -1;
end;


function TRSChat.ContainsMessage(msg: String; caseSensitive: Boolean = False): Boolean;
begin
  Result := Self.FindMessageLine(msg, caseSensitive) > -1;
end;



function TRSChat.InputHasText(): Boolean;
begin
  Result := Target.HasColor(Self.Colors[ERSChatColor.BLUE], 0, 15, Self.InputLine);
end;


procedure TRSChat.Draw(img: TImage);
var
  tab: TRSChatTab;
begin
  if not Self.IsOpen() then Exit;

  img.DrawColor := $00FFFF;
  img.DrawBox(Self.Bounds);
  img.DrawColor := $FFFFFF;
  img.DrawBoxArray(Self.MessageLines, False);
  img.DrawColor := $00FF00;
  img.DrawBox(Self.InputLine);
  img.DrawColor := $FF0000;
  img.DrawBox(Self.InputLine);

  Self.Scroll.Draw(img);
  for tab in Self.Tabs.Tabs do
    tab.Button.Draw(img);
end;

procedure ShowOnTarget(chat: TRSChat); overload;
var
  img: TImage;
begin
  img := Target.GetImage();
  chat.Draw(img);
  img.Show();
end;

var

  Chat: TRSChat;
