

{$DEFINE WL_MAKE_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TRSMakeItem = record
    Item: String;
    Index, Quantity: Integer;
  end;


  TRSMake = record
    Items: array of TRSMakeItem;
    QuantityButtons: TBoxArray;
    SelectedQuantity: Integer;
    {%codetools on}
    _IsOpenHelper, _ItemsHelper: TBox;
    {%codetools on}
    const TEXT_COLOR: TColor = $203040;
  end;


procedure TRSMake.SetupInterface();
begin
  with Chat.Bounds do
  begin
    Self._IsOpenHelper.X1 := X1 + 10;
    Self._IsOpenHelper.Y1 := Y1 + 12;
    Self._IsOpenHelper.X2 := X2 - 10;
    Self._IsOpenHelper.Y2 := Y1 + 34;

    Self.QuantityButtons := TBoxArray.Create([X2-228, Y1+15], 6, 1, 29, 29, [6,0]).Reversed();
    Self.QuantityButtons[0].X2 += 5;

    Self._ItemsHelper.X1 := X1 + 8;
    Self._ItemsHelper.Y1 := Y1 + 51;
    Self._ItemsHelper.X2 := X2 - 8;
    Self._ItemsHelper.Y2 := Y2 - 19;
  end;
end;


function TRSMake.IsOpen(): Boolean;
begin
  Result := Target.HasColor(Self.TEXT_COLOR, 0, 500, Self._IsOpenHelper);
end;


function TRSMake.WaitOpen(time: Integer = 600; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(), interval, time);
end;



function TRSMake.GetItemBoxes(): TBoxArray;
var
  tpa: TPointArray;
  b: TBox;
begin
  tpa := Target.FindColor($080707, 5, Self._ItemsHelper);
  for tpa in tpa.Cluster(1.5) do
  begin
    b := tpa.Bounds();
    if InRange(b.Height, 60, 85) and InRange(b.Width, 20, 120) then
      Result += b;
  end;
end;



function TRSMake.HasHint(): Boolean;
begin
  Result := Target.HasColor($A0FFFF, 0, 1, Chat.Bounds);
end;


function TRSMake.WaitHint(time: Integer = 600; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.HasHint(), interval, time);
end;


function TRSMake.GetHintBox(): TBox;
var
  tpa: TPointArray;
begin
  tpa := Target.FindColor($A0FFFF, 0, Chat.Bounds);
  if tpa <> [] then Result := tpa.Bounds();
end;


function TRSMake.ReadHint(): String;
begin
  Result := OCR.Recognize(Self.GetHintBox(), RSFonts.PLAIN_12, [$0], 0);
end;


function TRSMake.CloseHint(): Boolean;
var
  tpa: TPointArray;
  b: TBox;
begin
  tpa := TPointArray.CreateFromBox(Chat.Bounds, True);
  for b in Self.GetItemBoxes() do
    tpa := tpa.ExcludeBox(b.Expand(1));

  tpa := tpa.SortFrom(Mouse.Position);
  Mouse.Move(tpa[RandomLeft(0, High(tpa))]);
  Result := SleepUntil(not Self.HasHint(), RandomMode(100, 50, 1500), 600);
end;




function TRSMake.IndexOfQuantity(amount: Integer): Integer;
var
  hintPt: TPoint;
  i: Integer;
  quantity: ERSItemQuantity;
begin
  if amount <= 0 then Exit(0);

  if Self.HasHint() then
  begin
    hintPt := Self.GetHintBox().TopRight;
    if (hintPt.Y <= Self.QuantityButtons[5].Y2) and (hintPt.X >= Self.QuantityButtons[5].X1) then

    if not Self.CloseHint() then
      raise GetDebugLn('Make', 'Failed to close the tooltip which is covering the quanitty buttons');
  end;

  quantity := ERSItemQuantity.Integer2Quantity(amount);

  if quantity = ERSItemQuantity.CUSTOM then
  begin
    if amount = OCR.RecognizeNumber(Self.QuantityButtons[2], RSFonts.PLAIN_11, [Self.TEXT_COLOR, RSColors.TEXT_WHITE], 0) then
      Exit(2);
    Exit(1);
  end;

  for i := 1 to High(Self.QuantityButtons) do
    if amount = OCR.RecognizeNumber(Self.QuantityButtons[i], RSFonts.PLAIN_11, [Self.TEXT_COLOR, RSColors.TEXT_WHITE], 0) then
      Exit(i);
  Result := -1;
end;


function TRSMake.IsQuantitySelected(idx: Integer): Boolean;
begin
  Result := Target.HasColor(RSColors.TEXT_WHITE, 0, 1, Self.QuantityButtons[idx]);
end;



function TRSMake.SetQuantity(amount: Integer): Boolean;
var
  idx: Integer;
  done: Boolean;
begin
  idx := Self.IndexOfQuantity(amount);
  if idx < 0 then
    raise GetDebugLn('Make', 'Quantity button for "' + ToStr(amount) + '" is not available.');

  if Self.IsQuantitySelected(idx) then Exit(True);

  Mouse.Click(Self.QuantityButtons[idx], EMouseButton.LEFT);
  Result := SleepUntil(
              (done := Self.IsQuantitySelected(idx)) or
              Chat.FindQuery('Enter amount', True), RandomMode(100, 50, 1500), 600
            );
  if done then Exit;

  Result := Chat.AnswerQuery('Enter amount', ToStr(amount), 600);
end;



function TRSMake._SelectHelper(index: Integer; boxes: TBoxArray; keyboardProbability: Single): Boolean;
begin
  if High(boxes) < index then Exit;

  if keyboardProbability = -1 then
    keyboardProbability := Biometrics.RandomDouble(0.5);

  if not RandomBoolean(keyboardProbability) then
  begin
    Mouse.Click(boxes[index], EMouseButton.LEFT);
    Exit(SleepUntil(not Self.IsOpen(), RandomMode(100, 50, 1500), 2000));
  end;

  boxes[index].Y1 := boxes[index].Y2 + 1;
  boxes[index].Y2 += 15;

  if OCR.Locate(boxes[index], 'Space', [Self.TEXT_COLOR], 0, RSFonts.PLAIN_11) < 0.95 then
    Keyboard.KeyPress(EKeyCode.SPACE)
  else
    Keyboard.KeyPress(EKeyCode(Ord(EKeyCode.NUM_1) + index));

  Result := SleepUntil(not Self.IsOpen(), RandomMode(100, 50, 1500), 2000);
end;


function TRSMake.Select(index, quantity: Integer; keyboardProbability: Single = -1): Boolean;
var
  boxes: TBoxArray;
begin
  if not Self.IsOpen() then Exit;
  if not Self.SetQuantity(quantity) then Exit;
  boxes := Self.GetItemBoxes();
  if index <= High(boxes) then
    Result := Self._SelectHelper(index, boxes, keyboardProbability);
end;

function TRSMake.Select(item: String; quantity: Integer; keyboardProbability: Single = -1): Boolean; overload;
var
  boxes: TBoxArray;
  i: Integer;
begin
  if not Self.IsOpen() then Exit;
  boxes := Self.GetItemBoxes();

  for i := 0 to High(Self.Items) do
  begin
    if Self.Items[i].Item <> item then Continue;

    if Self.Items[i].Quantity <> quantity then
    begin
      if not Self.SetQuantity(quantity) then Exit;
      Self.Items[i].Quantity := quantity;
    end;

    Exit(Self._SelectHelper(Self.Items[i].Index, boxes, keyboardProbability));
  end;

  if not Self.SetQuantity(quantity) then Exit;

  for i := 0 to High(boxes) do
  begin
    Mouse.Move(boxes[i]);
    if not Self.WaitHint(4000) then Continue;

    if SameText(Self.ReadHint(), item) then
    begin
      Self.Items += [item, i, quantity];
      Exit(Self._SelectHelper(i, boxes, keyboardProbability));
    end;
  end;
end;


procedure TRSMake.Draw(img: TImage);
begin
  if not Self.IsOpen() then Exit;

  img.DrawColor := $00FFFF;
  img.DrawBox(Chat.Bounds);
  img.DrawColor := $FFFFFF;
  img.DrawBoxArray(Self.QuantityButtons, False);
  img.DrawColor := $00FF00;
  img.DrawBoxArray(Self.GetItemBoxes(), False);
  img.DrawColor := $FF0000;
  img.DrawBox(Self.GetHintBox());
end;

procedure ShowOnTarget(make: TRSMake); overload;
var
  img: TImage;
begin
  img := Target.GetImage();
  make.Draw(img);
  img.Show();
end;

var

  Make: TRSMake;
