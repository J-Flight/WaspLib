
{$DEFINE WL_CHAT_OPTIONS_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TRSChatOption = record
    Text: String;
    Bounds: TBox;
    Key: EKeyCode;
  end;
  TRSChatOptionArray = array of TRSChatOption;


function TRSChat.GetOptions(colors: TIntegerArray = []): TRSChatOptionArray;
var
  pt: TPoint;
  i: Integer;
begin
  if colors = [] then
    colors := Self.GetColors([ERSChatColor.BLACK, ERSChatColor.WHITE]);

  OCR.RecognizeLines(Self.Bounds, RSFonts.QUILL_8, colors, 0);
  if OCR.Engine.Matches = [] then Exit;

  SetLength(Result, Length(OCR.Engine.Matches));

  pt := Self.Bounds.TopLeft;

  for i := 0 to High(OCR.Engine.Matches) do
  begin
    Result[i].Bounds := OCR.Engine.Matches[i].Bounds.Offset(pt);
    Result[i].Text := OCR.Engine.Matches[i].Text;
    Result[i].Key := EKeyCode(Ord(EKeyCode.NUM_1) + i);
  end;

  if ('Click here to continue' in Result[High(Result)].Text) then
    Result[High(Result)].Key := EKeyCode.SPACE;
end;


function TRSChat.GetOptionsString(): String;
var
  option: TRSChatOption;
begin
  for option in Self.GetOptions() do
  begin
    if Result <> '' then Result += LINE_SEP;
    Result += option.Text;
  end;
end;


function TRSChat.FindOption(chatOption: String; caseSensitive: Boolean = True; colors: TIntegerArray = []): TRSChatOption;
var
  option: TRSChatOption;
begin
  if colors = [] then
    colors := Self.GetColors([ERSChatColor.BLACK, ERSChatColor.WHITE, ERSChatColor.BLUE]);
  for option in Self.GetOptions(colors) do
    if option.Text.Contains(chatOption, caseSensitive) then
      Exit(option);
end;


function TRSChat.HasOption(chatOption: String; caseSensitive: Boolean = True; colors: TIntegerArray = []): Boolean;
begin
  if colors = [] then
    colors := Self.GetColors([ERSChatColor.BLACK, ERSChatColor.WHITE, ERSChatColor.BLUE]);
  Result := Self.FindOption(chatOption, caseSensitive, colors) <> [];
end;


function TRSChat.WaitOption(chatOption: String; caseSensitive: Boolean = True; colors: TIntegerArray = []; time: Integer = 600; interval: Integer = -1): Boolean;
begin
  if colors = [] then
    colors := Self.GetColors([ERSChatColor.BLACK, ERSChatColor.WHITE, ERSChatColor.BLUE]);
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.HasOption(chatOption, caseSensitive, colors), time, interval);
end;



function TRSChat.Select(chatOption: String; caseSensitive: Boolean = True; keyboardProbability: Single = -1; colors: TIntegerArray = []): Boolean;
var
  option: TRSChatOption;
begin
  if colors = [] then
    colors := Self.GetColors([ERSChatColor.BLACK, ERSChatColor.WHITE]);
  option := Self.FindOption(chatOption, caseSensitive, colors);
  if option = [] then Exit;

  if keyboardProbability < 0 then
    keyboardProbability := Biometrics.RandomDouble(0.5);

  if RandomBoolean(keyboardProbability) then
    Keyboard.KeyPress(option.Key)
  else
    Mouse.Click(option.Bounds, EMouseButton.LEFT);

  Result := True;
end;


function TRSChat.HasContinue(): Boolean;
var
  colors: TIntegerArray;
begin
  colors := Self.GetColors([ERSChatColor.BLUE, ERSChatColor.WHITE]);
  Result := Self.HasOption('Click here to continue', True, colors) or
            Self.HasOption('Please wait', True, colors);
end;


function TRSChat.Continue(keyboardProbability: Single = -1): Boolean;
var
  colors: TIntegerArray;
begin
  if keyboardProbability < 0 then
    keyboardProbability := Biometrics.RandomDouble(0.5);
  colors := Self.GetColors([ERSChatColor.BLUE, ERSChatColor.WHITE]);
  if not Self.Select('Click here to continue', True, keyboardProbability, colors) then
    Exit;

  Result := Self.WaitOption('Please wait', True, colors, 3000) and
            SleepUntil(not Self.HasOption('Please wait', True, colors), RandomMode(100, 50, 1500), 3000);
end;


function TRSChat.ContinueUntilOption(option: String; timeout: Integer = 10000): Boolean;
begin
  timeout += Time();
  while (Time() < timeout) do
  begin
    if Self.HasOption(option) then Break;
    Self.Continue();
    Sleep(0, 2500, ERandomDir.LEFT);
  end;

  Result := Self.Select(option);
end;



function TRSChat.GetTitle(): String;
var
  options: TRSChatOptionArray;
begin
  options := Self.GetOptions([$000080]);
  if Length(options) > 0 then
    Result := options[0].Text;
end;


function TRSChat.IsTitle(text: String; similarity: Single = 0.8): Boolean;
begin
  Result := Self.GetTitle().Similarity(text) >= similarity;
end;


function TRSChat.WaitTitle(text: String; time: Integer = 600; similarity: Single = 0.8; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsTitle(text, similarity), time, interval);
end;



function TRSChat.LeveledUp(): Boolean;
begin
  Result := False;
end;



function TRSChat.HandleLevelUp(keyboardProbability: Single = -1): Boolean;
var
  timeout: UInt64;
begin
  timeout := Time() + 8000;
  repeat
    Self.Continue(keyboardProbability);
    Sleep(60, 3000, ERandomDir.LEFT);
    Result := Chat.GetDisplayName() <> '';
  until Result or (Time() > timeout);
end;
