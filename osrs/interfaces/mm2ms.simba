(*
# MM2MS
The core for our minimap to mainscreen projection.
Supports rotation, and zoom, and resizable client.

MM2MS extends the Minimap interface as well as the mainscreen interface with
functionality to convert coordinates to & from the minimap to the mainscreen.

Original work done by slacky
*)

{$DEFINE SRLT_MM2MS_INCLUDED}
{$IFNDEF SRLT_OSRS}
  {$I SRLT/osrs.simba}
{$ENDIF}

type
  TMM2MS = record
    ZoomRectangles: array [0..100] of TQuad;
    PlayerBoxes: array [0..100] of TBox;
    Projector: TMM2MSProjector;
  end;

function TMM2MS.Run(arr: Vector3Array; roll: Single): TPointArray;
var
  i: Integer;
begin
  Self.Projector.UpdateZoom(Options.GetZoomLevel(True));

  with Minimap.RSInterface.Center do
    for i := 0 to High(arr) do
      arr[i] := [arr[i].X - X, Y - arr[i].Y, arr[i].Z];

  Result := Self.Projector.Run(arr, Vec3(0, 0, PI*2 - roll));
end;

var
  MM2MS: TMM2MS;

function TRSMinimap.Vectors2MS(vectors: Vector3Array; angle: Single): TPointArray;
var
  i: Integer;
begin
  for i := 0 to High(vectors) do
    vectors[i] := vectors[i].RotateXY(PI*2 - angle, Self.RSInterface.Center);
  Result := MM2MS.Run(vectors, angle);
end;

function TRSMinimap.Vector2MS(vector: Vector3; angle: Single): TPoint;
begin
  with vector.RotateXY(PI*2-angle, Self.RSInterface.Center) do
    Result := MM2MS.Run([vector], angle)[0];
end;


function TRSMinimap.Points2MS(points: TPointArray; angle: Single = $FFFF): TPointArray;
var
  vectors: Vector3Array;
  i: Integer;
  rotation: Single;
begin
  if (angle = $FFFF) then
    angle := Self.GetCompassAngle(False);

  SetLength(vectors, Length(points));

  rotation := PI*2 - angle;
  for i := 0 to High(points) do
  begin
    vectors[i].X := points[i].X;
    vectors[i].Y := points[i].Y;
    vectors[i] := vectors[i].RotateXY(rotation, Self.RSInterface.Center);
  end;

  Result := MM2MS.Run(vectors, angle);
end;

function TRSMinimap.Point2MS(pt: TPoint; angle: Single = $FFFF): TPoint;
begin
  if (angle = $FFFF) then angle := Self.GetCompassAngle(False);
  with pt.Rotate(PI*2-angle, Self.RSInterface.Center) do
    Result := MM2MS.Run([Vec3(X, Y, 0)], angle)[0];
end;

function TRSMinimap.ATPA2MS(atpa: T2DPointArray; angle: Single = $FFFF): T2DPointArray; overload;
var
  tpa: TPointArray;
begin
  if angle = $FFFF then
    angle := Self.GetCompassAngle(False);
  for tpa in atpa do
    Result += Self.Points2MS(tpa, angle);
end;


function TRSMinimap.Vector2MSQuad(vector: Vector3; angle: Single; size: Vector2 = [1,1]; offset: Vector3 = [0,0,0]): TQuad;
var
  arr: TPointArray;
  v1, v2: Vector2;
begin
  size.X := 2 * size.X;
  size.Y := 2 * size.Y;

  vector.X += offset.X;
  vector.Y += offset.Y;
  vector.Z += offset.Z;

  vector := vector.RotateXY(PI*2- angle, Self.RSInterface.Center);

  v1 := [vector.X-size.X, vector.Y-size.Y];
  v2 := [vector.X+size.X, vector.Y+size.Y];

  arr := MM2MS.Run([Vec3(v1.X, v1.Y, vector.Z),
                    Vec3(v2.X, v1.Y, vector.Z),
                    Vec3(v2.X, v2.Y, vector.Z),
                    Vec3(v1.X, v2.Y, vector.Z)], angle);

  Result := [arr[0], arr[1], arr[2], arr[3]];
end;

function TRSMinimap.Point2MSQuad(pt: TPoint; size: Vector2 = [1,1]; angle: Single = $FFFF): TQuad;
begin
  if angle = $FFFF then angle := Self.GetCompassAngle(False);
  Result := Self.Vector2MSQuad(Vec3(pt.X, pt.Y, 0), angle, size);
end;


procedure TRSMinimap.DebugTiles(drawDots: Boolean);
var
  img: TImage;
  x, y: Integer;
  tile: Vector3;
  dot: TPoint;
  angle: Single;
begin
  angle := Self.GetCompassAngle(False);

  img := TImage.CreateFromTarget();
  img.DrawColor := $00FF00;

  for x := Self.RSInterface.Center.X - 25 * 4 to Self.RSInterface.Center.X + 25 * 4 with 4 do
    for y := Self.RSInterface.Center.Y - 25 * 4 to Self.RSInterface.Center.Y + 25 * 4 with 4 do
    begin
      tile := Vec3(x, y).RotateXY(angle, Self.RSInterface.Center);
      img.DrawQuad(Self.Vector2MSQuad(tile, angle, [1,1]));
    end;

  if drawDots then
  begin
    img.DrawColor := $00FFFF;
    for dot in Self.GetDots(ERSMinimapDot.NPC) do
      img.DrawQuad(Self.Vector2MSQuad(Vec3(dot.X, dot.Y, 0), angle, [1,1]));

    img.DrawColor := $0000FF;
    for dot in Self.GetDots(ERSMinimapDot.ITEM) do
      img.DrawQuad(Self.Vector2MSQuad(Vec3(dot.X, dot.Y, 0), angle, [1,1]));

    img.DrawColor := $FFFFFF;
    for dot in Self.GetDots(ERSMinimapDot.PLAYER) do
      img.DrawQuad(Self.Vector2MSQuad(Vec3(dot.X, dot.Y, 0), angle, [1,1]));
  end;

  img.Show();
  img.Free();
end;

procedure TRSMinimap.DebugDots();
var
  img: TImage;
  x, y: Integer;
  tile: Vector3;
  dot: TPoint;
  angle: Single;
begin
  angle := Self.GetCompassAngle(False);

  img := TImage.CreateFromTarget();

  img.DrawColor := $00FFFF;
  for dot in Self.GetDots(ERSMinimapDot.NPC) do
    img.DrawQuad(Self.Vector2MSQuad(Vec3(dot.X, dot.Y, 0), angle, [1,1]));

  img.DrawColor := $0000FF;
  for dot in Self.GetDots(ERSMinimapDot.ITEM) do
    img.DrawQuad(Self.Vector2MSQuad(Vec3(dot.X, dot.Y, 0), angle, [1,1]));

  img.DrawColor := $FFFFFF;
  for dot in Self.GetDots(ERSMinimapDot.PLAYER) do
    img.DrawQuad(Self.Vector2MSQuad(Vec3(dot.X, dot.Y, 0), angle, [1,1]));

  img.Show();
  img.Free();
end;

