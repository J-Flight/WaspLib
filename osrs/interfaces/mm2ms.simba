(*
# MM2MS
The core for our minimap to mainscreen projection.
Supports rotation, and zoom, and resizable client.

MM2MS extends the Minimap interface as well as the mainscreen interface with
functionality to convert coordinates to & from the minimap to the mainscreen.

Original work done by slacky
*)

{$DEFINE SRLT_MM2MS_INCLUDED}
{$IFNDEF SRLT_OSRS}
  {$I SRLT/osrs.simba}
{$ENDIF}

type
  TMM2MS = record
    ZoomQuads: array [0..100] of TQuad;
    PlayerBoxes: array [0..100] of TBox;
    Projector: TMM2MSProjector;
  end;

function TMM2MS.Run(arr: Vector3Array; roll: Single): TPointArray;
var
  i: Integer;
begin
  Self.Projector.UpdateZoom(Options.GetZoomLevel(True));

  with Minimap.RSInterface.Center do
    for i := 0 to High(arr) do
      arr[i] := [arr[i].X - X, Y - arr[i].Y, arr[i].Z];

  Result := Self.Projector.Run(arr, Vec3(0, 0, PI*2 - roll));
end;

var
  MM2MS: TMM2MS;

function TRSMinimap.Vectors2MS(vectors: Vector3Array; angle: Single): TPointArray;
var
  i: Integer;
begin
  for i := 0 to High(vectors) do
    with Self.NormalizeEx([vectors[i].X, vectors[i].Y], angle) do
    begin
      vectors[i].X := X;
      vectors[i].Y := Y;
    end;

  Result := MM2MS.Run(vectors, angle);
end;

function TRSMinimap.Vector2MS(vector: Vector3; angle: Single): TPoint;
begin
  with Self.NormalizeEx([vector.X, vector.Y], angle) do
    Result := MM2MS.Run([[X, Y, vector.Z]], angle)[0];
end;


function TRSMinimap.Points2MS(points: TPointArray; angle: Single = $FFFF): TPointArray;
var
  vectors: Vector3Array;
  i: Integer;
  rotation: Single;
begin
  if (angle = $FFFF) then
    angle := Self.GetCompassAngle(False);

  SetLength(vectors, Length(points));

  for i := 0 to High(points) do
    with Self.Normalize(points[i], angle) do
    begin
      vectors[i].X := X;
      vectors[i].Y := Y;
    end;

  Result := MM2MS.Run(vectors, angle);
end;

function TRSMinimap.Point2MS(pt: TPoint; angle: Single = $FFFF): TPoint;
begin
  if (angle = $FFFF) then angle := Self.GetCompassAngle(False);
  with Self.Normalize(pt, angle) do
    Result := MM2MS.Run([Vec3(X, Y, 0)], angle)[0];
end;

function TRSMinimap.ATPA2MS(atpa: T2DPointArray; angle: Single = $FFFF): T2DPointArray; overload;
var
  tpa: TPointArray;
begin
  if angle = $FFFF then
    angle := Self.GetCompassAngle(False);
  for tpa in atpa do
    Result += Self.Points2MS(tpa, angle);
end;


function TRSMinimap.Vector2MSQuad(vector: Vector3; angle: Single; size: Vector2 = [1,1]; offset: Vector3 = [0,0,0]): TQuad;
var
  v1, v2: Vector2;
  arr: TPointArray;
begin
  size.X := 2 * size.X;
  size.Y := 2 * size.Y;

  vector.X += offset.X;
  vector.Y += offset.Y;
  vector.Z += offset.Z;

  with Self.NormalizeEx([vector.X, vector.Y], angle) do
  begin
    vector.X := X;
    vector.Y := Y;
  end;

  v1 := [vector.X-size.X, vector.Y-size.Y];
  v2 := [vector.X+size.X, vector.Y+size.Y];

  arr := MM2MS.Run([Vec3(v1.X, v1.Y, vector.Z),
                    Vec3(v2.X, v1.Y, vector.Z),
                    Vec3(v2.X, v2.Y, vector.Z),
                    Vec3(v1.X, v2.Y, vector.Z)], angle);

  Result := [arr[0], arr[1], arr[2], arr[3]];
end;

function TRSMinimap.Point2MSQuad(pt: TPoint; size: Vector2 = [1,1]; angle: Single = $FFFF): TQuad;
begin
  if angle = $FFFF then angle := Self.GetCompassAngle(False);
  Result := Self.Vector2MSQuad(Vec3(pt.X, pt.Y), angle, size);
end;


function TRSMinimap.Vector2MSCuboid(vector, size: Vector3; angle: Single; offset: Vector3 = [0,0,0]): TCuboid;
var
  v1, v2: Vector2;
  arr: TPointArray;
begin
  size.X := 2 * size.X;
  size.Y := 2 * size.Y;

  vector.X += offset.X;
  vector.Y += offset.Y;
  vector.Z += offset.Z;

  with Self.NormalizeEx([vector.X, vector.Y], angle) do
  begin
    vector.X := X;
    vector.Y := Y;
  end;

  v1 := [vector.X-size.X, vector.Y-size.Y];
  v2 := [vector.X+size.X, vector.Y+size.Y];

  arr := MM2MS.Run([
                Vec3(v1.X, v1.Y, vector.Z+size.Z), Vec3(v2.X, v1.Y, vector.Z+size.Z),
                Vec3(v2.X, v2.Y, vector.Z+size.Z), Vec3(v1.X, v2.Y, vector.Z+size.Z),

                Vec3(v1.X, v1.Y, vector.Z), Vec3(v2.X, v1.Y, vector.Z),
                Vec3(v2.X, v2.Y, vector.Z), Vec3(v1.X, v2.Y, vector.Z)
         ], angle);

  Result.Top := [arr[0], arr[1], arr[2], arr[3]];
  Result.Bottom := [arr[4], arr[5], arr[6], arr[7]];
end;

function TRSMinimap.Point2MSCuboid(pt: TPoint; size: Vector3; angle: Single = $FFFF): TCuboid;
begin
  if angle = $FFFF then angle := Self.GetCompassAngle(False);
  Result := Self.Vector2MSCuboid(Vec3(pt.X, pt.Y), size, angle);
end;



function TRSMainScreen.Point2MM(pt: TPoint; height: Integer; angle: Single; accuracy: Single = 0.2): Vector3;
  function FindNearest(Area, Step: Single; FromMM: Vector3; IsFinal: Boolean): Vector3;
  var
    i: Int32;
    tpa: TPointArray;
    arr, raw: Vector3Array;
    best: TPoint;
    x,y: single;
  begin
    best := Point(-9999, -9999);
    x := FromMM.X-Area;
    while x <= FromMM.X+Area do
    begin
      y := FromMM.Y-Area;
      while y <= FromMM.Y+Area do
      begin
        raw += Vector3([x,y,height]);
        arr += raw[High(raw)].RotateXY(-angle, Minimap.RSInterface.Center);
        y += Step;
      end;
      x += Step;
    end;

    TPA := Minimap.Vectors2MS(Copy(arr), angle);
    if not IsFinal then Swap(arr, raw);
    for i:=0 to High(TPA) do
      if Distance(TPA[i], pt) < Distance(best, pt) then
      begin
        best := TPA[i];
        Result := arr[i];
      end;
    Result.z := Height;
  end;

var
  area: Single;
begin
  area := 48;
  Result := FindNearest(area, area, Vec3(Minimap.RSInterface.Center.X, Minimap.RSInterface.Center.Y), False);
  while area > accuracy do
  begin
    Result := FindNearest(area, area, Result, False);
    area /= 2;
  end;
  Result := FindNearest(area, accuracy, Result, True);
end;


function TRSMinimap.GetZoomQuad(): TQuad;
var
  angle: Single;
begin
  if MM2MS.ZoomQuads[Options.GetZoomLevel(True)] <> [] then
    Exit(MM2MS.ZoomQuads[Options.ZoomLevel]);

  angle := Self.GetCompassAngle(False);

  Result := [
    MainScreen.Point2MM(MainScreen.RSInterface.TopLeft, 0, angle).ToPoint(),
    MainScreen.Point2MM(MainScreen.RSInterface.TopRight, 0, angle).ToPoint(),
    MainScreen.Point2MM(MainScreen.RSInterface.BottomRight, 0, angle).ToPoint(),
    MainScreen.Point2MM(MainScreen.RSInterface.BottomLeft, 0, angle).ToPoint()
  ];
  MM2MS.ZoomQuads[Options.ZoomLevel] := Result;
end;

function TRSMinimap.PointOnZoomQuad(pt: TPoint): Boolean;
begin
  Result := Self.GetZoomQuad().Contains(pt);
end;


procedure TRSMinimap.DebugTiles(dots: ERSMinimapDots = [ERSMinimapDot.PLAYER, ERSMinimapDot.NPC, ERSMinimapDot.ITEM]);
const DOT_COLORS: TColorArray = [$FFFFFF, $00FFFF, $0000FF];
var
  img: TImage;
  p: TPoint;
  vector: Vector3;
  quad: TQuad;
  dot: ERSMinimapDot;
  angle: Single;
  tpa: TPointArray;
begin
  angle := Self.GetCompassAngle(False);

  img := TImage.CreateFromTarget();
  img.DrawColor := $00FF00;

  for p.X := Self.RSInterface.Center.X - 25 * 4 to Self.RSInterface.Center.X + 25 * 4 with 4 do
    for p.Y := Self.RSInterface.Center.Y - 25 * 4 to Self.RSInterface.Center.Y + 25 * 4 with 4 do
    begin
      vector := Vec3(p.X, p.Y).RotateXY(angle, Self.RSInterface.Center);
      if not Self.PointOnZoomQuad(vector.ToPoint()) then Continue;
      quad := Self.Vector2MSQuad(vector, angle, [1,1]);
      tpa := quad.Corners.Connect();
      img.DrawTPA(tpa.ExtractBox(MainScreen.RSInterface.Bounds));
    end;

  for dot in dots do
  begin
    img.DrawColor := DOT_COLORS[dot];
    for p in Self.GetDots(dot) do
    begin
      vector := Vec3(p.X, p.Y, 0);
      if not Self.PointOnZoomQuad(vector.ToPoint()) then Continue;
      quad := Self.Vector2MSQuad(vector, angle, [1,1]);
      tpa := quad.Corners.Connect().Grow(1);
      img.DrawTPA(tpa.ExtractBox(MainScreen.RSInterface.Bounds));
    end;
  end;

  img.DrawColor := $FF0000;
  vector := Vec3(Self.RSInterface.Center.X, Self.RSInterface.Center.Y);
  quad := Self.Vector2MSQuad(vector, angle, [1,1]);
  tpa := quad.Corners.Connect().Grow(1);
  img.DrawTPA(tpa);

  img.Show();
  img.Free();
end;
