

{$DEFINE WL_MM2MS_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TRSMM2MS = record
    {%codetools off}
    ZoomQuads: array [0..100] of TQuad;
    PlayerBoxes: array [0..100] of TBox;
    {%codetools on}
    Projector: TMM2MSProjector;
    Normalizer: TMM2MSProjector;
    const MAX_RENDER_DISTANCE: Integer = 80; //roughly 20 tiles
  end;

procedure TRSMM2MS.Setup();
begin
  Self.Projector.SetupProjection(RSClient.Mode);
  Self.Normalizer.SetupProjection(ERSMode.FIXED);
  Self.Normalizer.UpdateZoom(50);
end;


function TRSMM2MS.Run(arr: TVector3Array; roll: Single): TPointArray;
var
  i: Integer;
begin
  Self.Projector.UpdateZoom(Options.GetZoomLevel(True));
  with Minimap.Center do
    for i := 0 to High(arr) do
      arr[i] := [arr[i].X - X, Y - arr[i].Y, arr[i].Z];

  Result := Self.Projector.Run(arr, [0, 0, TAU - roll]);
end;

var

  MM2MS: TRSMM2MS;


function TRSMinimap.Vectors2MS(vectors: TVector3Array; angle: Single): TPointArray;
var
  i: Integer;
begin
  for i := 0 to High(vectors) do
    with Self.NormalizeEx([vectors[i].X, vectors[i].Y], angle) do
    begin
      vectors[i].X := X;
      vectors[i].Y := Y;
    end;

  Result := MM2MS.Run(vectors, angle);
end;

function TRSMinimap.Vector2MS(vector: TVector3; angle: Single): TPoint;
begin
  with Self.NormalizeEx([vector.X, vector.Y], angle) do
    Result := MM2MS.Run([[X, Y, vector.Z]], angle)[0];
end;



function TRSMinimap.Points2MS(points: TPointArray; angle: Single = $FFFF): TPointArray;
var
  vectors: TVector3Array;
  i: Integer;
begin
  if (angle = $FFFF) then
    angle := Self.GetCompassAngle(False);

  SetLength(vectors, Length(points));

  for i := 0 to High(points) do
    with Self.Normalize(points[i], angle) do
    begin
      vectors[i].X := X;
      vectors[i].Y := Y;
    end;

  Result := MM2MS.Run(vectors, angle);
end;

function TRSMinimap.Point2MS(pt: TPoint; angle: Single = $FFFF): TPoint;
begin
  if (angle = $FFFF) then angle := Self.GetCompassAngle(False);
  with Self.Normalize(pt, angle) do
    Result := MM2MS.Run([[X, Y, 0]], angle)[0];
end;

function TRSMinimap.ATPA2MS(atpa: T2DPointArray; angle: Single = $FFFF): T2DPointArray; overload;
var
  tpa: TPointArray;
begin
  if angle = $FFFF then
    angle := Self.GetCompassAngle(False);
  for tpa in atpa do
    Result += Self.Points2MS(tpa, angle);
end;



function TRSMinimap.Vector2MSQuad(vector: TVector3; angle: Single; size: TVector2 = [1,1]; offset: TVector3 = [0,0,0]): TQuad;
var
  v1, v2: TVector2;
  arr: TPointArray;
begin
  size.X := 2 * size.X;
  size.Y := 2 * size.Y;

  vector.X += offset.X;
  vector.Y += offset.Y;
  vector.Z += offset.Z;

  with Self.NormalizeEx([vector.X, vector.Y], angle) do
  begin
    vector.X := X;
    vector.Y := Y;
  end;

  v1 := [vector.X-size.X, vector.Y-size.Y];
  v2 := [vector.X+size.X, vector.Y+size.Y];

  arr := MM2MS.Run([[v1.X, v1.Y, vector.Z],
                    [v2.X, v1.Y, vector.Z],
                    [v2.X, v2.Y, vector.Z],
                    [v1.X, v2.Y, vector.Z]], angle);

  Result := [arr[0], arr[1], arr[2], arr[3]];
end;

function TRSMinimap.Point2MSQuad(pt: TPoint; size: TVector2 = [1,1]; angle: Single = $FFFF): TQuad;
begin
  if angle = $FFFF then angle := Self.GetCompassAngle(False);
  Result := Self.Vector2MSQuad(pt.ToVec3(), angle, size);
end;



function TRSMinimap.Vector2MSCuboid(vector, size: TVector3; angle: Single; offset: TVector3 = [0,0,0]): TCuboid;
var
  v1, v2: TVector2;
  arr: TPointArray;
begin
  size.X := 2 * size.X;
  size.Y := 2 * size.Y;

  vector.X += offset.X;
  vector.Y += offset.Y;
  vector.Z += offset.Z;

  with Self.NormalizeEx([vector.X, vector.Y], angle) do
  begin
    vector.X := X;
    vector.Y := Y;
  end;

  v1 := [vector.X-size.X, vector.Y-size.Y];
  v2 := [vector.X+size.X, vector.Y+size.Y];

  arr := MM2MS.Run([
                [v1.X, v1.Y, vector.Z+size.Z], [v2.X, v1.Y, vector.Z+size.Z],
                [v2.X, v2.Y, vector.Z+size.Z], [v1.X, v2.Y, vector.Z+size.Z],

                [v1.X, v1.Y, vector.Z], [v2.X, v1.Y, vector.Z],
                [v2.X, v2.Y, vector.Z], [v1.X, v2.Y, vector.Z]
         ], angle);

  Result.Top := [arr[0], arr[1], arr[2], arr[3]];
  Result.Bottom := [arr[4], arr[5], arr[6], arr[7]];
end;

function TRSMinimap.Point2MSCuboid(pt: TPoint; size: TVector3; angle: Single = $FFFF): TCuboid;
begin
  if angle = $FFFF then angle := Self.GetCompassAngle(False);
  Result := Self.Vector2MSCuboid(pt.ToVec3(), size, angle);
end;



function TRSMainScreen.Point2MM(pt: TPoint; height: Integer; angle: Single; accuracy: Single = 0.2): TVector3;
  function FindNearest(Area, Step: Single; FromMM: TVector3; IsFinal: Boolean): TVector3;
  var
    i: Integer;
    tpa: TPointArray;
    arr, raw: TVector3Array;
    best: TPoint;
    x,y: single;
  begin
    best := Point(-9999, -9999);
    x := FromMM.X-Area;
    while x <= FromMM.X+Area do
    begin
      y := FromMM.Y-Area;
      while y <= FromMM.Y+Area do
      begin
        raw += [[x,y,height]];
        arr += raw[High(raw)].Rotate(-angle, Minimap.Center);
        y += Step;
      end;
      x += Step;
    end;

    TPA := Minimap.Vectors2MS(Copy(arr), angle);
    if not IsFinal then Swap(arr, raw);
    for i:=0 to High(TPA) do
      if Distance(TPA[i], pt) < Distance(best, pt) then
      begin
        best := TPA[i];
        Result := arr[i];
      end;
    Result.z := Height;
  end;

var
  area: Single;
begin
  area := 48;
  Result := FindNearest(area, area, Minimap.Center.ToVec3(), False);
  while area > accuracy do
  begin
    Result := FindNearest(area, area, Result, False);
    area /= 2;
  end;
  Result := FindNearest(area, accuracy, Result, True);
end;




property TRSMinimap.ZoomQuad: TQuad;
var
  angle: Single;
begin
  if MM2MS.ZoomQuads[Options.GetZoomLevel(True)] <> [] then
    Exit(MM2MS.ZoomQuads[Options.ZoomLevel]);

  angle := Self.GetCompassAngle(False);

  Result := [
    MainScreen.Point2MM(MainScreen.TopLeft, 0, angle).ToPoint(),
    MainScreen.Point2MM(MainScreen.TopRight, 0, angle).ToPoint(),
    MainScreen.Point2MM(MainScreen.BottomRight, 0, angle).ToPoint(),
    MainScreen.Point2MM(MainScreen.BottomLeft, 0, angle).ToPoint()
  ];
  MM2MS.ZoomQuads[Options.ZoomLevel] := Result;
end;


function TRSMinimap.PointOnZoomQuad(pt: TPoint): Boolean;
begin
  Result := Self.ZoomQuad.Contains(pt);
end;


function TRSMinimap.RandomPointOnZoomQuad(pt: TPoint; randomness: Integer): TPoint;
var
  quad: TQuad;
  img: TImage;
begin
  quad := Self.ZoomQuad;
  if not quad.Contains(pt) then
  begin
    img := Target.GetImage();
    img.DrawColor := $FFFFFF;
    img.DrawQuad(quad);
    img.DrawColor := $0000FF;
    img.DrawCross(pt, 4);
    img.Show();
    raise GetDebugLn('MM2MS', ToStr(pt) + ' is not a valid point to generate a random point on the zoom quad: ' + ToStr(quad) + '.');
  end;

  repeat
    Result := pt.Random(-randomness, randomness);
  until quad.Contains(Result);
end;



function TRSMinimap.FacePoint(pt: TPoint; randomness: Integer = 0): Boolean;
var
  quad: TQuad;
  tpa: TPointArray;
  distance: Double;
  i: Integer;
begin
  if not Self.Contains(pt) then Exit;

  quad := Self.ZoomQuad;
  if quad.Contains(pt) then Exit(True);

  tpa := quad.Corners.SortFrom(pt);
  distance := Self.Center.DistanceTo(pt);

  for i := 0 to High(tpa) do
  begin
    Result := distance <= Self.Center.DistanceTo(tpa[i]);
    if Result then
      Break;
  end;

  if not Result then Exit;

  Self.SetCompassAngle(
    Self.Center.AngleBetween(tpa[i]) - Self.Center.AngleBetween(pt) + randomness
  );
end;


function TRSMainScreen.FacePoint(pt: TPoint; randomness: Integer = 0): Boolean;
begin
  Result := Minimap.FacePoint(Self.Point2MM(pt, 0, Minimap.GetCompassAngle(False)).ToPoint(), randomness);
end;


function TRSMainScreen.NormalizeDistance(dist: Integer; accuracy: Single = 1.05): Integer;
var
  Base: TPoint;

  function _SearchUp(value: Single; target: Single; inc: Single): Single;
  var
    pt: TPoint;
  begin
    while True do
    begin
      pt := MM2MS.Normalizer.Run([value, 0, 0], [0, 0, 0]);
      if BASE.DistanceTo(pt) > target then
        Exit(value);

      value *= inc;
    end;
  end;

  function _SearchDown(value: Single; target: Single; dec: Single): Single;
  var
    pt: TPoint;
  begin
    while True do
    begin
      pt := MM2MS.Normalizer.Run([value, 0, 0], [0, 0, 0]);
      if BASE.DistanceTo(pt) < target then
        Exit(value);

      value /= dec;
    end;
  end;

var
  lo, hi, mean: Single;
  arr: TPointArray;
begin
  if dist = 0 then Exit;

  Base := MM2MS.Normalizer.Run([0, 0, 0], [0, 0, 0]);
  hi := _SearchUp(0.1, dist, 1.50);
  lo := _SearchDown(hi, dist, 1.50);

  hi := _SearchUp(lo, dist, accuracy);
  lo := _SearchDown(hi, dist, accuracy);
  mean := lo + ((hi - lo) / 2);

  with Minimap.Center do
    arr := MM2MS.Run([[X,Y], [X+mean,Y]], 0);

  Result := Round(arr[0].DistanceTo(arr[1]));

  if Result < 1 then Result := 1;
end;



function TRSMinimap.InZoomRangeEx(pt: TPoint; out corner: TPoint): Boolean;
var
  quad: TPointArray;
begin
  if not Self.Contains(pt) then Exit;

  quad := Self.ZoomQuad.Corners.SortFrom(Self.Center);
  corner := quad[High(quad)];

  Result := Self.Center.DistanceTo(pt) <= Self.Center.DistanceTo(corner);
end;

function TRSMinimap.InZoomRange(pt: TPoint): Boolean;
var
  corner: TPoint;
begin
  Result := Self.InZoomRangeEx(pt, corner);
end;

function TRSMinimap.AnyInZoomRange(tpa: TPointArray): Boolean; overload;
var
  quad: TPointArray;
  pt, corner: TPoint;
  dist: Double;
begin
  quad := Self.ZoomQuad.Corners.SortFrom(Self.Center);
  corner := quad[High(quad)];
  dist := Self.Center.DistanceTo(corner);

  for pt in tpa do
    if Self.Center.DistanceTo(pt) <= dist then
      Exit(True);
end;



function TRSMinimap.GetZoomToPoint(p: TPoint; randomness: Integer = 0): Integer;
var
  distance: Double;
begin
  distance := p.DistanceTo(Self.Center);

  Result := Round((73 - distance) / 0.8);
  Result := Result + randomness;
end;


function TRSMinimap.SetZoom2Point(pt: TPoint; randomness: Integer = 0): Boolean;
var
  level: Integer;
begin
  if Self.InZoomRange(pt) then Exit(True);

  level := Self.GetZoomToPoint(pt, randomness);

  if InRange(level, 0, 100) then
    Result := Options.SetZoomLevel(level);
end;



function TRSMinimap.MakePointVisible(pt: TPoint): Boolean;
begin
  Result := Self.SetZoom2Point(pt, Random(-5, 5)) and Self.FacePoint(pt, Random(-3, 3));
end;



procedure TRSMinimap.DebugTiles(dots: ERSMinimapDots = [ERSMinimapDot.PLAYER, ERSMinimapDot.NPC, ERSMinimapDot.ITEM]);
const DOT_COLORS: TColorArray = [$FFFFFF, $00FFFF, $0000FF];
var
  img: TImage;
  p: TPoint;
  vector: TVector3;
  quad: TQuad;
  dot: ERSMinimapDot;
  angle: Single;
  tpa: TPointArray;
begin
  angle := Self.GetCompassAngle(False);

  img := Target.GetImage();
  img.DrawColor := $00FF00;

  for p.X := Self.Center.X - 100 to Self.Center.X + 100 with 4 do
    for p.Y := Self.Center.Y - 100 to Self.Center.Y + 100 with 4 do
    begin
      vector := p.ToVec3().Rotate(angle, Self.Center);
      if not Self.PointOnZoomQuad(vector.ToPoint()) then Continue;
      quad := Self.Vector2MSQuad(vector, angle, [1,1]);
      tpa := quad.Corners.Connect().ExtractBox(MainScreen.Bounds);
      img.DrawTPA(tpa);
    end;

  for dot in dots do
  begin
    img.DrawColor := DOT_COLORS[dot];
    for p in Self.GetDots(dot) do
    begin
      vector := p.ToVec3();
      if not Self.PointOnZoomQuad(vector.ToPoint()) then Continue;
      quad := Self.Vector2MSQuad(vector, angle, [1,1]);
      tpa := quad.Corners.Connect().ExtractBox(MainScreen.Bounds);
      img.DrawTPA(tpa);
    end;
  end;

  img.DrawColor := $FF0000;
  vector := Self.Center.ToVec3();
  quad := Self.Vector2MSQuad(vector, angle, [1,1]);
  tpa := quad.Corners.Connect().Grow(1);
  img.DrawTPA(tpa);

  img.Show();
end;


property TRSMainScreen.PlayerBox: TBox;
var
  compassAngle: Double;
  vectors: TVector3Array;
begin
  if MM2MS.PlayerBoxes[Options.GetZoomLevel()] <> [] then
    Exit(MM2MS.PlayerBoxes[Options.GetZoomLevel()]);

  compassAngle := Minimap.GetCompassAngle(False);

  vectors := [
    Minimap.Center.Offset(-2,0).ToVec3(9).Rotate(-compassAngle, Minimap.Center),
    Minimap.Center.Offset(2,0).ToVec3(-3).Rotate(-compassAngle, Minimap.Center)
  ];

  Result := MM2MS.Run(vectors, compassAngle).Bounds;
  MM2MS.PlayerBoxes[Options.GetZoomLevel()] := Result;
end;
