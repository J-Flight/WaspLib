(*
# Consumables
Manages consumable items like food and potions.

It handles loading, inventory scanning, and consumption logic with cooldowns and effects.
*)
{$DEFINE WL_CONSUMABLES_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

(*
(ERSConsumable)=
## Enum ERSConsumable
```pascal
ERSConsumable = (BOOST, ENERGY, POISON, ANTIFIRE);
```
Defines the categories of consumables available.
*)
type
  ERSConsumable = (ENERGY, POISON, ANTIFIRE);

(*
(TRSConsumableItem)=
## type TRSConsumableItem
Represents a single consumable item with its properties.
*)
  TRSConsumableItem = record
    Item: TRSItem;
    Points, Order, Cooldown, Duration: Integer;
    Skills: array of ERSSkill;
    Other: array of ERSConsumable;
  end;

  TRSConsumableItemArray = array of TRSConsumableItem;

function TRSConsumableItemArray.Create(json: TJSONObject): TRSConsumableItemArray; static;
var
  idx, i: Integer;
  items: TRSItemArray;
  item: TRSConsumableItem;
begin
  items := TRSItem(json.Item['name'].AsString).Spread();

  for idx := 0 to High(items) do
  begin
    item.Item := items[idx];
    item.Order := json.Item['order'].AsInt;
    item.Cooldown := json.Item['cooldown'].AsInt;
    item.Duration := json.Item['duration'].AsInt;
    item.Points := json.Item['base'].AsInt;

    for i := 0 to json.Item['skills'].Count-1 do
      item.Skills += ERSSkill(json.Item['skills'].Item[i].AsInt);
    for i := 0 to json.Item['other'].Count-1 do
      item.Other += ERSConsumable(json.Item['other'].Item[i].AsInt);

    Result += item;
  end;
end;

function TRSConsumableItemArray.Intersection(other: TRSItemArray): TRSConsumableItemArray;
var
  i, j: Integer;
begin
  for i := 0 to High(other) do
    for j := 0 to High(Self) do
      if Self[i].Item.Before('(') = other[i] then
        Result += Self[i];
end;

function TRSConsumableItemArray.SortByPoints(lowToHigh: Boolean = False): TRSConsumableItemArray;
var
  i: Integer;
  weights: TIntegerArray;
begin
  SetLength(weights, Length(Self));
  for i := 0 to High(Self) do
    weights[i] := Self[i].Points;
  Result := Self.Sorted(weights, lowToHigh);
end;


type
(*
(TRSBoostItem)=
## type TRSBoostItem
Represents a single boost item with its properties.
*)
  TRSBoostItem = record
    Item: TRSItem;
    Skill: ERSSkill;
    Skills: array of ERSSkill;
    Other: array of ERSConsumable;
    _Points, Order, Cooldown, Duration, Base: Integer;
    Multiplier: Single;
  end;

(*
## TRSBoostItem.Points
```pascal
property TRSBoostItem.Points: Integer;
property TRSBoostItem.Points(value: Integer);
```
Getter and setter `Points` property.

Only set a new value if you want to permanently override it.
*)
property TRSBoostItem.Points: Integer;
begin
  if Self._Points > 0 then
    Exit(Self._Points);

  if Self.Item = 'anglerfish' then
  begin
    Self._Points := Floor(Stats.GetLevel(ERSSkill.HITPOINTS)/10) +
                    2*Floor(Stats.GetLevel(ERSSkill.HITPOINTS)/25) +
                    5*Floor(Stats.GetLevel(ERSSkill.HITPOINTS)/93) + 2;
    Exit(Self._Points);
  end;

  Self._Points := Self.Base + Floor(Stats.GetLevel(Self.Skill) * Self.Multiplier);

  Result := Self._Points * StrToInt(Self.Item.Between('(', ')'), 1);
end;

property TRSBoostItem.Points(value: Integer);
begin
  Self._Points := value;
end;

type
  TRSBoostItemArray = array of TRSBoostItem;

function TRSBoostItemArray.Create(json: TJSONObject; skill: ERSSkill): TRSBoostItemArray; static;
var
  idx, i: Integer;
  items: TRSItemArray;
  item: TRSBoostItem;
begin
  items := TRSItem(json.Item['name'].AsString).Spread();

  for idx := 0 to High(items) do
  begin
    item.Item := items[idx];
    item.Order := json.Item['order'].AsInt;
    item.Cooldown := json.Item['cooldown'].AsInt;
    item.Duration := json.Item['duration'].AsInt;
    item.Base := json.Item['base'].AsInt;
    item.Multiplier := json.Item['multiplier'].AsFloat;
    item.Skill := skill;

    for i := 0 to json.Item['skills'].Count-1 do
      item.Skills += ERSSkill(json.Item['skills'].Item[i].AsInt);
    for i := 0 to json.Item['other'].Count-1 do
      item.Other += ERSConsumable(json.Item['other'].Item[i].AsInt);

    Result += item;
  end;
end;

function TRSBoostItemArray.Intersection(other: TRSItemArray): TRSBoostItemArray;
var
  i, j: Integer;
begin
  for i := 0 to High(other) do
    for j := 0 to High(Self) do
      if Self[i].Item.Before('(') = other[i] then
        Result += Self[i];
end;

function TRSBoostItemArray.SortByPoints(lowToHigh: Boolean = False): TRSBoostItemArray;
var
  i: Integer;
  weights: TIntegerArray;
begin
  SetLength(weights, Length(Self));
  for i := 0 to High(Self) do
    weights[i] := Self[i].Points;
  Result := Self.Sorted(weights, lowToHigh);
end;


type
(*
(TRSConsumables)=
## type TRSConsumables
Manages all aspects of item consumption.
*)
  TRSConsumables = record
    Boosts: array [ERSSkill] of record
      Names: TStringArray;
      Items, Active: TRSBoostItemArray;
      MinInvPoints: Integer;
      Timers: array of TCountDown;
      IsSetup: Boolean;
    end;

    Consumables: array [ERSConsumable] of record
      Names: TStringArray;
      Items, Active: TRSConsumableItemArray;
      MinInvPoints: Integer;
      Timers: array of TCountDown;
      IsSetup: Boolean;
    end;

    Cooldowns: array [0..2] of TCountDown;

    Version, CacheDir: String;
  end;


procedure TRSConsumables.Init();
var
  path, tmp: String;
begin
  Self.Version := WLAssets.JSON.Item['jsons/consumables.zip'].AsString;
  Self.CacheDir := WLEnv.CacheDir + 'consumables' + PATH_SEP;

  //Delete old cache files if they exist
  for path in DirList(Self.CacheDir) do
  begin
    tmp := Copy(path, Length(path) - Length(Self.Version) + 1, Length(path));
    if tmp = Self.Version then Continue;
    DirDelete(path, False);
  end;

  Self.CacheDir += Self.Version + PATH_SEP;

  if not DirCreate(Self.CacheDir) then
    raise GetDebugLn('Consumables', 'Failed to create cache directory: ' + Self.CacheDir);

  Self.Cooldowns[0].Start(3*TICK);
  Self.Cooldowns[1].Start(3*TICK);
  Self.Cooldowns[2].Start(3*TICK);
end;

(*
## Consumables.Setup
```pascal
procedure TRSConsumables.Setup(consumable: ERSConsumable);
procedure TRSConsumables.Setup(skill: ERSSkill); overload;
```
Sets up the specified type of consumable.
To setup a `ERSConsumable.BOOST` you should use a `ERSSkill` value instead with
the `ERSSkill` you want to boost.

For example, to setup food, prayer potions and antifires you would do the
following:
```pascal
Consumables.Setup(ERSSkill.HITPOINTS);
Consumables.Setup(ERSSkill.PRAYER);
Consumables.Setup(ERSConsumable.ANTIFIRE);
```
*)
procedure TRSConsumables.Setup(consumable: ERSConsumable);
var
  filename: String;
  json: TJSONParser;
  i: Integer;
begin
  if Self.Consumables[consumable].IsSetup then
    Exit;

  filename := ToStr(consumable) + '.json';
  if not FileExists(Self.CacheDir + filename) then
    if not ZipExtract(WLEnv.AssetsDir + 'jsons' + PATH_SEP + 'consumables.zip', Self.CacheDir, [filename]) then
      raise GetDebugLn('Consumables', 'File does not exist: ' + filename);

  json := new TJSONParser();
  json.Load(filename);

  if json.Typ <> EJSONType.ARR then
    raise GetDebugLn('Consumables', 'Unexpected JSON format in: ' + filename);

  for i := 0 to json.Count-1 do
  begin
    Self.Consumables[consumable].Names += json.Item[i].Item['name'].AsString;
    Self.Consumables[consumable].Items += TRSConsumableItemArray.Create(json.Item[i]);
  end;

  Self.Consumables[consumable].IsSetup := True;
end;

procedure TRSConsumables.Setup(skill: ERSSkill); overload;
var
  filename: String;
  json: TJSONParser;
  i: Integer;
begin
  if Self.Boosts[skill].IsSetup then
    Exit;

  filename := ToStr(skill) + '.json';
  if not FileExists(Self.CacheDir + filename) then
    if not ZipExtract(WLEnv.AssetsDir + 'jsons' + PATH_SEP + 'consumables.zip', Self.CacheDir, [filename]) then
      raise GetDebugLn('Consumables', 'File does not exist: ' + filename);

  json := new TJSONParser();
  json.Load(filename);

  if json.Typ <> EJSONType.ARR then
    raise GetDebugLn('Consumables', 'Unexpected JSON format in: ' + filename);

  for i := 0 to json.Count-1 do
  begin
    Self.Boosts[skill].Names += json.Item[i].Item['name'].AsString;
    Self.Boosts[skill].Items += TRSBoostItemArray.Create(json.Item[i], skill);
  end;

  Self.Boosts[skill].IsSetup := True;
end;


(*
## TRSConsumables.Find
```pascal
function TRSConsumables.Find(consumable: ERSConsumable): TRSConsumableItemArray;
function TRSConsumables.Find(boost: ERSSkill): TRSBoostItemArray; overload;
```
Scans inventory for all consumables of a specific category.
*)
function TRSConsumables.Find(consumable: ERSConsumable): TRSConsumableItemArray;
var
  items: TRSItemArray;
  i: Integer;
begin
  if not Inventory.Open() then
    Exit;

  Self.Setup(consumable);

  items := Inventory.Items.DiscoverAll();

  for i := 0 to High(items) do
    if items[i].EndsWith(')') then
      items[i] := items[i].Before('(');

  Result := Self.Consumables[consumable].Items.Intersection(items);
end;

function TRSConsumables.Find(boost: ERSSkill): TRSBoostItemArray; overload;
var
  items: TRSItemArray;
  i: Integer;
begin
  if not Inventory.Open() then
    Exit;

  Self.Setup(boost);

  items := Inventory.Items.DiscoverAll();

  for i := 0 to High(items) do
    if items[i].EndsWith(')') then
      items[i] := items[i].Before('(');

  Result := Self.Boosts[boost].Items.Intersection(items);
end;


(*
## TRSConsumables.HasEnoughPoints
```pascal
function TRSConsumables.HasEnoughPoints(consumable: ERSConsumable): Boolean;
function TRSConsumables.HasEnoughPoints(skill: ERSSkill): Boolean; overload;
```
Checks if total points of a consumable type meet the `MinInvPoints` threshold.
*)
function TRSConsumables.HasEnoughPoints(consumable: ERSConsumable): Boolean;
var
  consumables: TRSConsumableItemArray;
  c: TRSConsumableItem;
  total: Integer;
begin
  if Self.Consumables[consumable].MinInvPoints <= 0 then
    Exit(True);

  consumables := Self.Find(consumable);
  for c in consumables do
    total += c.Points * Inventory.Items.Count(c.Item);

  Result := total >= Self.Consumables[consumable].MinInvPoints;
end;

function TRSConsumables.HasEnoughPoints(skill: ERSSkill): Boolean; overload;
var
  boosts: TRSBoostItemArray;
  b: TRSBoostItem;
  total: Integer;
begin
  if Self.Consumables[skill].MinInvPoints <= 0 then
    Exit(True);

  boosts := Self.Find(skill);
  for b in boosts do
    total += b.Points * Inventory.Items.Count(b.Item);

  Result := total >= Self.Consumables[skill].MinInvPoints;
end;


(*
## TRSConsumables.CanConsume
```pascal
function TRSConsumables.CanConsume(consumable: ERSConsumable): Boolean;
function TRSConsumables.CanConsume(boost: ERSSkill): Boolean; overload;
```
Checks if a consumable can be used, considering active effects.
*)
function TRSConsumables.CanConsume(consumable: ERSConsumable): Boolean;
var
  i: Integer;
begin
  for i := High(Self.Consumables[consumable].Active) downto 0 do
  begin
    if Self.Consumables[consumable].Timers[i].IsFinished then
    begin
      Delete(Self.Consumables[consumable].Active, i, 1);
      Delete(Self.Consumables[consumable].Timers, i, 1);
      Continue;
    end;
  end;

  Result := Self.Consumables[consumable].Active = [];
end;

function TRSConsumables.CanConsume(boost: ERSSkill): Boolean; overload;
var
  i: Integer;
begin
  for i := High(Self.Boosts[boost].Active) downto 0 do
  begin
    if Self.Boosts[boost].Timers[i].IsFinished then
    begin
      Delete(Self.Boosts[boost].Active, i, 1);
      Delete(Self.Boosts[boost].Timers, i, 1);
      Continue;
    end;
  end;

  Result := Self.Boosts[boost].Active = [];
end;


(*
## TRSConsumables.Consume
```pascal
function TRSConsumables.Consume(consumable: ERSConsumable): Boolean;
function TRSConsumables.Consume(skill: ERSSkill): Boolean; overload;
```
Consumes the best item of a specified category from inventory.
*)
function TRSConsumables.Consume(consumable: ERSConsumable): Boolean;
var
  consumables: TRSConsumableItemArray;
  i, j, slot: Integer;
begin
  for i := 0 to 2 do
    if Self.Cooldowns[i].IsFinished then
    begin
      if consumables = [] then
        consumables := Self.Find(consumable).SortByPoints(False);

      for j := 0 to High(consumables) do
      begin
        if consumables[j].Order <> i then Continue;

        if Inventory.Items.Find(consumables[j].Item, slot) then
          raise GetDebugLn('Consumables', 'Something went wrong, can''t find consumable that was found previously.');

        Inventory.Slots.Hover(slot);

        if not MainScreen.IsUpText(['Eat', 'Drink']) then
          if not ChooseOption.Hover(['Eat', 'Drink']) then Continue;
        Mouse.Click(EMouseButton.LEFT);
        Self.Cooldowns[i].Restart();
        Exit(True);
      end;
    end;
end;

function TRSConsumables.Consume(boost: ERSSkill): Boolean; overload;
var
  consumables: TRSBoostItemArray;
  i, j, slot: Integer;
begin
  for i := 0 to 2 do
    if Self.Cooldowns[i].IsFinished then
    begin
      if consumables = [] then
        consumables := Self.Find(boost).SortByPoints(False);

      for j := 0 to High(consumables) do
      begin
        if consumables[j].Order <> i then Continue;

        if Inventory.Items.Find(consumables[j].Item, slot) then
          raise GetDebugLn('Consumables', 'Something went wrong, can''t find consumable that was found previously.');

        Inventory.Slots.Hover(slot);

        if not MainScreen.IsUpText(['Eat', 'Drink']) then
          if not ChooseOption.Hover(['Eat', 'Drink']) then Continue;
        Mouse.Click(EMouseButton.LEFT);
        Self.Cooldowns[i].Restart();
        Exit(True);
      end;
    end;
end;

var
  Consumables: TRSConsumables;
