

{$DEFINE WL_GEAR_LAYOUTS_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TRSGearItem = type TRSItem;


function TRSGearItem.Interact(option: String = ''; attempts: Int32 = 2): Boolean;
var
  slot, i: Int32;
  slotsAPtr, slotsBPtr: ^TRSSlotInterface;
  itemsAPtr, itemsBPtr: ^TRSItemInterface;
  tabA, tabB: ERSGameTab;
begin
  tabA := GameTabs.GetCurrent();

  case tabA of
    ERSGameTab.INVENTORY:
      begin
        itemsAPtr := @Inventory.Items;
        itemsBPtr := @Equipment.Items;
        slotsAPtr := @Inventory.Slots;
        slotsBPtr := @Equipment.Slots;
        tabB := ERSGameTab.EQUIPMENT;
      end;
    ERSGameTab.EQUIPMENT:
      begin
        itemsAPtr := @Equipment.Items;
        itemsBPtr := @Inventory.Items;
        slotsAPtr := @Equipment.Slots;
        slotsBPtr := @Inventory.Slots;
        tabB := ERSGameTab.INVENTORY;
      end;
    else
      begin
        if not Inventory.Open() then Exit;
        Exit(Self.Interact(option));
      end;
  end;

  for i := 0 to 1 do
  begin
    slot := itemsAPtr^.IndexOf([Self]);
    if slot > -1 then
      Exit(slotsAPtr^.Interact(slot, option));

    Swap(slotsAPtr, slotsBPtr);
    Swap(itemsAPtr, itemsBPtr);
    Swap(tabA, tabB);
    if not GameTabs.Open(tabA) then Exit;
  end;

  if attempts > 0 then
    Result := Self.Interact(option, Dec(attempts));
end;

type

  TRSGear = record
    Name: String;
    Items: array [ERSEquipment] of TRSItem;
  end;


function TRSGear.ToJSON(): TJSONItem;
var
  slot: ERSEquipment;
begin
  Result := new TJSONObject();

  for slot := Low(ERSEquipment) to High(ERSEquipment) do
    Result.AddString(ToStr(slot).After('ERSEquipment.').ToLower(), Self.Items[slot]);
end;

type

  TRSGearLayout = record
    Gear: TRSGear;
    Equipped: array [ERSEquipment] of TRSItem;
  end;


function TRSGearLayout.Equip(): Boolean;
var
  slot: ERSEquipment;
  i: Integer;
  slots: TIntegerArray;
  items: TRSItemArray;
  nothing: array of ERSEquipment;
  slotMap: array [0..27] of ERSEquipment;
begin
  if Self.Equipped.Equals(Self.Gear.Items) then Exit(True);
  if not Inventory.Open() then Exit;

  for slot := Low(ERSEquipment) to High(ERSEquipment) do
  begin
    if Self.Equipped[slot] = Self.Gear.Items[slot] then
      Continue;
    if not Inventory.Items.Find(Self.Gear.Items[slot], i) then
      Exit;

    slots += i;
    case Self.Gear.Items[slot] of
      'Nothing': nothing += slot;
      'Anything': ;
      else
      begin
        items += Self.Gear.Items[slot];
        slotMap[i] := slot;
      end;
    end;
  end;

  slots := Inventory.RandomPattern().Intersection(slots);

  for i in slots do
  begin
    Inventory.Slots.Click(i, EMouseButton.LEFT);
    Self.Equipped[slotMap[i]] := Self.Gear.Items[slotMap[i]];
  end;

  Result := SleepUntil(not Inventory.Items.ContainsAny(items), 300, 2000);

  if not Equipment.Open() then Exit;

  for slot in nothing do
    if Equipment.Slots.IsUsed(Ord(slot)) then
      Equipment.Slots.Click(Ord(slot), EMouseButton.LEFT);
end;


function TRSGearLayout.Withdraw(): Boolean;
var
  slot: ERSEquipment;
begin
  if Self.Equipped.Equals(Self.Gear.Items) then Exit(True);
  if not Bank.IsOpen() then Exit;

  for slot := Low(ERSEquipment) to High(ERSEquipment) do
  begin
    if Self.Equipped[slot] = Self.Gear.Items[slot] then
      Continue;
    if Inventory.Items.Contains(Self.Gear.Items[slot]) then
      Continue;

    if not Bank.Withdraw(Self.Gear.Items[slot], False, True) then
      Exit;
  end;

  Result := True;
end;
