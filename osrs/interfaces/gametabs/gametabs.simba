(*
# GameTabs
Methods to interact with the gametab buttons.

By default it will attempt to use "F-Keys" to open gametabs.
You can turn this off by setting `TRSGameTabs.KeybindsEnabled` to `False`.

The way keybindings work in SRLT is that it will try a random "F-Key" everytime
you want to open a gametab. Because it uses a random "F-Key", it will probably
not open the gametab you want but whatever opens, gets cached and mapped to the
random "F-Key" used.

Next time you want to open a gametab that has already been mapped, it will use
the correct "F-Key".
*)
{$DEFINE SRLT_GAMETABS_INCLUDED}
{$INCLUDE_ONCE SRLT/osrs.simba}

{.$DEFINE SRLT_KEYBINDS_DEBUG}

type
(*
(ERSGameTab)=
## type ERSGameTab
```pascal
ERSGameTab = enum(NONE, COMBAT, STATS, ACHIEVEMENTS, INVENTORY, EQUIPMENT, PRAYER, MAGIC, CLAN, FRIENDS, ACCOUNT, LOGOUT, OPTIONS, EMOTES, MUSIC);
```
*)
  ERSGameTab = enum(
    COMBAT, STATS, ACHIEVEMENTS, INVENTORY, EQUIPMENT, PRAYER, MAGIC,
    CLAN, FRIENDS, ACCOUNT, LOGOUT, OPTIONS, EMOTES, MUSIC, NONE
  );

(*
(TRSGameTabs)=
## type TRSGameTabs
Main record responsible for handling the gametabs.
*)
  TRSGameTabs = record
    Bounds: TBox;
    Tabs: TBoxArray;
    Keybinds: array [ERSGameTab] of EKeyCode;
    KeybindsEnabled: Boolean;
    AvailableKeys: EKeycodeArray;
    const ActiveColor: TColorTolerance = [$14194A, 1.235, EColorSpace.HSL, [1.631, 1.084, 0.286]];
  end;

(*
## GameTabs.SetupInterface
```pascal
procedure TRSGameTabs.SetupInterface();
```
Internal method responsible for setting up coordinates for the {ref}`TRSGameTabs`.

This is automatically called for you on the {ref}`GameTabs variable`.
*)
procedure TRSGameTabs.SetupInterface();
var
  b: TBox;
  tab: ERSGameTab;
begin
  Self.Bounds.Y2 := Target.Bounds.Y2;

  case RSClient.Mode of
    ERSMode.FIXED:
    begin
      Self.Bounds.X1 := Target.Bounds.X2 - 242;
      Self.Bounds.X2 := Target.Bounds.X2 - 2;
      Self.Bounds.Y1 := Target.Bounds.Y2 - 334;
    end;

    ERSMode.RESIZABLE_CLASSIC:
    begin
      Self.Bounds.X1 := Target.Bounds.X2 - 240;
      Self.Bounds.X2 := Target.Bounds.X2;
      Self.Bounds.Y1 := Target.Bounds.Y2 - 334;
    end;

    ERSMode.RESIZABLE_MODERN:
    begin
      Self.Bounds.X2 := Target.Bounds.X2;

      //Needed because depending on the client width the tabs stack into row(s)
      if Target.Width >= 948 then
      begin
        Self.Bounds.X1 := Target.Bounds.X2 - 428;
        Self.Bounds.Y1 := Target.Bounds.Y2 - 35;
      end
      else
      begin
        Self.Bounds.X1 := Target.Bounds.X2 - 230;
        Self.Bounds.Y1 := Target.Bounds.Y2 - 71;
      end;
    end;
  end;

  case RSClient.Mode of
    ERSMode.FIXED, ERSMode.RESIZABLE_CLASSIC:
      Self.Tabs := TBoxArray.Create(Self.Bounds.TopLeft.Offset(6,1), 7, 2, 30, 33, [3, 265]);

    ERSMode.RESIZABLE_MODERN:
      begin
        // One row
        if Target.Width >= 948 then
        begin
          Self.Tabs := TBoxArray.Create(Self.Bounds.BottomLeft.Offset(0,-35), 14, 1, 30, 33, [3, 0]);
          for tab := ERSGameTab.MUSIC downto ERSGameTab.FRIENDS do
            Self.Tabs[tab] := Self.Tabs[tab-1];
        end
        else // Two rows
          Self.Tabs := TBoxArray.Create(Self.Bounds.BottomLeft.Offset(0,-70), 7, 2, 30, 33, [3, 3]);

        // Logout button is moved to top right corner
        Self.Tabs[7] := Self.Tabs[10];
        Self.Tabs[10].X1 := Target.Bounds.X2 - 19;
        Self.Tabs[10].Y1 := Target.Bounds.Y1 + 9;
        Self.Tabs[10].X2 := Target.Bounds.X2 - 10;
        Self.Tabs[10].Y2 := Target.Bounds.Y1 + 18;
      end;
  end;
end;

(*
## GameTabs.GetCurrent
```pascal
function TRSGameTabs.GetCurrent(): ERSGametab;
```
Get the currently active ERSGameTab.

Example:
```pascal
WriteLn GameTabs.GetCurrent();
```
*)
function TRSGameTabs.GetCurrent(): ERSGametab;
var
  tab: ERSGameTab;
begin
  if (RSClient.Mode = ERSMode.RESIZABLE_MODERN) and (Target.CountColor(8639715, 0, Self.Tabs[ERSGameTab.LOGOUT-1]) > 0) then
    Exit(ERSGameTab.LOGOUT);

  for tab := ERSGameTab.COMBAT to ERSGameTab.MUSIC do
    if (Target.CountColor(Self.ActiveColor, Self.Tabs[tab]) > 50) then
      Exit(tab);
  Result := ERSGameTab.NONE;
end;


(*
## GameTabs.IsOpen
```pascal
function TRSGameTabs.IsOpen(tab: ERSGameTab): Boolean;
```
Returns true/false if the specified `tab` is currently open.

Example:
```pascal
WriteLn GameTabs.IsOpen(ERSGameTab.INVENTORY);
```
*)
function TRSGameTabs.IsOpen(tab: ERSGameTab): Boolean;
begin
  Result := Self.GetCurrent() = tab;
end;

(*
## GameTabs.WaitOpen
```pascal
function TRSGameTabs.WaitOpen(tab: ERSGameTab; time: Integer = 600; interval: Integer = -1): Boolean;
```
Returns true/false if the specified `tab` opens within the specified `time`.

Example:
```pascal
Mouse.Click(GameTabs.Get(ERSGameTab.INVENTORY), EMouseButton.LEFT);
WriteLn GameTabs.WaitOpen(ERSGameTab.INVENTORY);
```
*)
function TRSGameTabs.WaitOpen(tab: ERSGameTab; time: Integer = 600; interval: Integer = -1): Boolean;
begin
  if interval < 0 then interval := RandomMode(100, 50, 1500);
  Result := SleepUntil(Self.IsOpen(tab), interval, time);
end;


(*
## GameTabs.FKeyOpen
```pascal
function TRSGameTabs.FKeyOpen(tab: ERSGameTab): Boolean;
```
Attempts to open the specified `tab` gametab with an FKey.
This works by randomly using FKeys that haven't been tried yet and slowly
caching which gametabs they open. At first most times this is used it won't
open the `tab` specified, but as more EKeyCode/ERSGameTab pairs get mapped
this starts getting them right.

Example:
```pascal
WriteLn GameTabs.FKeyOpen(ERSGameTab.INVENTORY);
```
*)
function TRSGameTabs.FKeyOpen(tab: ERSGameTab): Boolean;
var
  current, new: ERSGameTab;
  i: Integer;
  switched: Boolean;
begin
  {$IFDEF SRLT_KEYBINDS_DEBUG}
  for current := ERSGameTab.COMBAT to ERSGameTab.MUSIC do
    WriteLn GetDebugLn('GameTabs', 'Keybinds -> ' + ToStr(current) + ' -> ' ToStr(Self.Keybinds[current]));
  {$ENDIF}

  if Self.Keybinds[tab] <> EKeyCode.UNKNOWN then
  begin
    Keyboard.PressKey(Self.Keybinds[tab]);
    Exit(Self.WaitOpen(tab, 2000));
  end;

  if Self.AvailableKeys = [] then Exit; //all keys are already setup and there's no match
  i := Random(0, High(Self.AvailableKeys));

  current := Self.GetCurrent();
  Keyboard.PressKey(Self.AvailableKeys[i]);

  switched := SleepUntil(current <> (new := Self.GetCurrent()), RandomMode(100, 50, 1500), 600);

  if switched then //if tab switched we are sure of this key-gametab pair
  begin
   Self.Keybinds[new] := Self.AvailableKeys[i];
   Delete(Self.AvailableKeys, i, 1);
  end
  else if Self.Keybinds[new] <> EKeyCode.UNKNOWN then
    Delete(Self.AvailableKeys, i, 1); //This key has no pair

  Result := new = Tab;
end;


(*
## GameTabs.Open
```pascal
function TRSGameTabs.Open(tab: ERSGameTab; fkeyProbability: Single = -1): Boolean;
```
Attempts to open the specified `tab` gametab.
If `TRSGameTabs.KeybindsEnabled` is true, we might attempt to open the tab
with {ref}`TRSGameTabs.FKeyOpen`, subject to `fkeyProbability`.

Example:
```pascal
WriteLn GameTabs.Open(ERSGameTab.INVENTORY);
```
*)
function TRSGameTabs.Open(tab: ERSGameTab; fkeyProbability: Single = -1): Boolean;
begin
  if Self.IsOpen(tab) then
    Exit(True);

  if Self.KeybindsEnabled then
  begin
    if fkeyProbability = -1 then fkeyProbability := Biometrics.RandomDouble(0.8);

    if RandomBoolean(fkeyProbability) and Self.FKeyOpen(tab) then
      Exit(True);
  end;

  for 1 to 3 do
  begin
    Mouse.Click(Self.Tabs[tab], EMouseButton.LEFT);
    if Self.WaitOpen(tab, 2000) then Exit(True);
  end;
end;


procedure TRSGameTabs.Draw(img: TImage);
begin
  img.DrawBox(Self.Bounds);
  img.DrawBoxArray(Self.Tabs, False);
end;

var
(*
(GameTabs variable)=
## var GameTabs
Global {ref}`TRSGameTabs` variable.
*)
  GameTabs: TRSGameTabs;

begin
  GameTabs.KeybindsEnabled := True;
  GameTabs.AvailableKeys := [
    EKeyCode.ESCAPE, EKeyCode.F1, EKeyCode.F2, EKeyCode.F3, EKeyCode.F4,
    EKeyCode.F5, EKeyCode.F6, EKeyCode.F7, EKeyCode.F8, EKeyCode.F9,
    EKeyCode.F10, EKeyCode.F11, EKeyCode.F12
  ];
end;
