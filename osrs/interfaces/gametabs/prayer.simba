

{$DEFINE WL_PRAYER_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TRSPrayerSet = set of ERSPrayer;


  TRSPrayer = record
    Slots: TBoxArray;
  end;




procedure TRSPrayer.SetupGameTab();
begin
  Self.Slots := TBoxArray.Create(GameTab.Bounds.TopLeft.Offset(1,10), 5, 6, 33, 33, [4, 4]);
end;


function TRSPrayer.IsOpen(): Boolean;
begin
  Result := GameTabs.IsOpen(ERSGameTab.PRAYER);
end;


function TRSPrayer.Open(): boolean;
begin
  Result := GameTabs.Open(ERSGameTab.PRAYER);
end;


function TRSPrayer.GetInfoBox(): TBox;
const
  INFO_BOX_COLOR: TColor = $A0FFFF;
var
  tpa: TPointArray;
begin
  if not Self.IsOpen() then Exit;

  tpa := Target.FindColor(INFO_BOX_COLOR, 0, GameTab.Bounds);
  if tpa.Length > 1000 then
    Result := tpa.Bounds();
end;


function TRSPrayer.InfoIsOpen(): Boolean;
begin
  Result := Self.GetInfoBox <> [];
end;


function TRSPrayer.CloseInfo(): Boolean;
var
  destination: TPoint;
  timeout: UInt64;
begin
  if not Self.InfoIsOpen then
    Exit(True);

  destination := GameTab.Bounds.Expand(10).NearestEdge(Target.MouseXY);
  Async.MouseMove(destination);

  timeout := Time() + 3000;

  while Self.InfoIsOpen() or (Time() > timeout) do
    Sleep(20, 100, ERandomDir.LEFT);

  Async.MouseStop();

  Result := not Self.InfoIsOpen();
end;


function TRSPrayer.Find(prayer: ERSPrayer; out bounds: TBox; attempts: Integer = 2): Boolean;
var
  match: TImageMatch;
begin
  if not Self.IsOpen() then Exit;

  Result := PrayerFinder.Find([prayer], Self.Slots, match);

  if Result then
  begin
    bounds := match.Box.Expand(-1);
    Exit;
  end;

  if attempts = 0 then Exit;

  if Self.InfoIsOpen() then
    Result := Self.CloseInfo and Self.Find(prayer, bounds, attempts-1);
end;


function TRSPrayer.Hover(prayer: ERSPrayer; checkUpText: Boolean = False): Boolean;
var
  b: TBox;
begin
  if not (Self.IsOpen() and Self.Find(prayer, b)) then
    Exit;

  Mouse.Move(b);
  Result := True;

  if checkUpText then
    Result := MainScreen.UpText.After('ctivate').Trim()
      = ToStr(prayer).ToLower().Replace('_', ' ').CapitalizeWords();
end;


function TRSPrayer.Click(prayer: ERSPrayer; button: EMouseButton = EMouseButton.LEFT; checkUpText: Boolean = False): Boolean;
begin
  Result := Self.Hover(prayer, checkUpText);
  if Result then
    Target.MouseClick(button);
end;


function TRSPrayer.CanActivate(prayer: ERSPrayer): Boolean;
var
  b: TBox;
begin
  Result := Self.Find(prayer, b);
end;


function TRSPrayer.IsActive(prayers: TRSPrayerSet): Boolean;
const
  ACTIVE_COLOR: TColorTolerance = [$6CAAC2, 0.777, EColorSpace.HSL, [1.967, 0.232, 0.803]];
var
  prayer: ERSPrayer;
  b: TBox;
begin
  for prayer in prayers do
    if not (Self.Find(prayer, b) and Target.HasColor(ACTIVE_COLOR, 10, b)) then
      Exit;

  Result := True;
end;


function TRSPrayer.GetActivePrayers(): TRSPrayerSet;
var
  prayer: ERSPrayer;
begin
  for prayer := Low(ERSPrayer) to High(ERSPrayer) do
    if Self.IsActive([prayer]) then
      Result += prayer;
end;


function TRSPrayer.Activate(prayers: TRSPrayerSet): Boolean;
var
  prayer: ERSPrayer;
  activatedPrayers: TRSPrayerSet;
begin
  Result := True;
  if not Self.IsOpen then
    Exit(False);

  for prayer in prayers do
  begin
    if Self.IsActive([prayer]) then
      Continue;

    if Self.CanActivate(prayer) and Self.Click(prayer) then
      activatedPrayers += prayer
    else
      Result := False;
  end;

  Result := Result and SleepUntil(Self.IsActive(activatedPrayers), 100, 2000);
end;


function TRSPrayer.Deactivate(prayers: TRSPrayerSet): Boolean;
var
  prayer: ERSPrayer;
  emptyPrayerSet: TRSPrayerSet;
begin
  Result := True;
  if not Self.IsOpen() then
    Exit;

  for prayer in prayers do
  begin
    if not Self.IsActive([prayer]) then
      Continue;
    Result := Result and Self.Click(prayer);
  end;

  Result := Result and SleepUntil(((Self.GetActivePrayers() * prayers) = emptyPrayerSet), 100, 2000);
end;

var

  Prayer: TRSPrayer;
