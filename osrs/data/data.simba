

{$DEFINE WL_DATA_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type

  TItemData = record
    DefinitionsJSON, PricesJSON: TJSONParser;
    Filename: String;
    Timeout: UInt64;
    Disabled: Boolean;
    const CacheDir: String = WLEnv.CacheDir + 'data' + PATH_SEP;
    const PRICES_URL: String = 'https://prices.runescape.wiki/api/v1/osrs/latest';
  end;


  EItemDataKey = enum(
    ID,
    NAME,
    RESIZE_X,
    RESIZE_Y,
    RESIZE_Z,
    XAN_2D,
    YAN_2D,
    ZAN_2D,
    COST,
    TRADEABLE,
    STACKABLE,
    INVENTORY_MODEL,
    WEAR_POS_1,
    WEAR_POS_2,
    WEAR_POS_3,
    MEMBERS,
    COLOR_FIND,
    COLOR_REPLACE,
    ZOOM_2D,
    X_OFFSET_2D,
    Y_OFFSET_2D,
    AMBIENT,
    CONTRAST,
    OPTIONS,
    INTERFACE_OPTIONS,
    MALE_MODEL_0,
    MALE_MODEL_1,
    MALE_MODEL_2,
    MALE_OFFSET,
    MALE_HEAD_MODEL,
    MALE_HEAD_MODEL_2,
    FEMALE_MODEL_0,
    FEMALE_MODEL_1,
    FEMALE_MODEL_2,
    FEMALE_OFFSET,
    FEMALE_HEAD_MODEL,
    FEMALE_HEAD_MODEL_2,
    CATEGORY,
    NOTED_ID,
    NOTED_TEMPLATE,
    TEAM,
    WEIGHT,
    SHIFT_CLICK_DROP_INDEX,
    BOUGHT_ID,
    BOUGHT_TEMPLATE_ID,
    PLACEHOLDER_ID,
    PLACEHOLDER_TEMPLATE_ID,
    PARAMS
  );

procedure TItemData.UpdateFile();
var
  t: UInt64;
  files: TStringArray;
  i: Integer;
begin
  files := DirList(Self.CacheDir + 'prices' + PATH_SEP).Sorted();
  for i := 0 to High(files)-1 do FileDelete(files[i]);

  if files <> [] then
  begin
    Self.Filename := files.Last;
    Self.Timeout := StrToInt64(PathExtractNameWithoutExt(Self.Filename), Self.Timeout);
  end;

  t := Time();

  if Self.Timeout < t then
  begin
    if Self.Filename <> '' then
    begin
      WriteLn GetDebugLn('ItemData', 'Data cached is old and will be updated.');
      FileDelete(Self.Filename);
    end;

    Self.Timeout := t + ONE_HOUR;
    Self.Filename := Self.CacheDir  + 'prices' + PATH_SEP + ToStr(Self.Timeout) + '.json';
    HTTPClient.GetFile(Self.PRICES_URL, Self.Filename);
  end;
end;

procedure TItemData.Reload();
var
  current: String;
begin
  if Self.Disabled then Exit;

  current := Self.Filename;
  Self.UpdateFile();
  if current = Self.Filename then Exit;

  Self.PricesJSON := new TJSONParser();

  try
    Self.PricesJSON.Load(Self.Filename);
  except
    FileDelete(Self.Filename);
    Self.Disabled := True;
  end;
end;

procedure TItemData.Setup();
begin
  if not DirCreate(Self.CacheDir + 'prices' + PATH_SEP) then
    raise GetDebugLn('ItemData', 'Failed to create cache directory: ' + Self.CacheDir + 'prices' + PATH_SEP);
  if not DirCreate(Self.CacheDir + 'items' + PATH_SEP) then
    raise GetDebugLn('ItemData', 'Failed to create cache directory: ' + Self.CacheDir + 'items' + PATH_SEP);

  Self.DefinitionsJSON := new TJSONParser();
end;



function TItemData.GetDefinition(itemID: String): TJSONItem;
var
  path, filename: String;
begin
  if Self.DefinitionsJSON.GetObject(itemID, Result) then Exit;

  path := Self.CacheDir  + 'items' + PATH_SEP;
  filename := path + itemID + '.json';
  if not FileExists(filename) then
    if not ZipExtractEntry(WLAssets.ItemDefinitions.Path, itemID +'.json', path) then
      raise  GetDebugLn('ItemData', 'Couldn''t find ' + itemID + '.json');

  Result := new TJSONParser();

  TJSONParser(Result).Load(filename);
  Self.DefinitionsJSON.Add(itemID, Result);
end;


function TItemData.GetTradeableID(item: TRSItem): String;
var
  ids: TStringArray;
  id: String;
  json: TJSONItem;
begin
  if item.IsNumeric then ids := [item]
  else ids := ItemFinder.Database.GetAll(item.ToLower(), 'item', 'id');

  for id in ids do
  begin
    json := Self.GetDefinition(id);
    if json.Item[Ord(EItemDataKey.TRADEABLE)].AsBool then
      Exit(id);
  end;
end;



function TItemData.GetPrice(item: TRSItem): Integer;
var
  id: String;
  json: TJSONItem;
  lo, hi: Integer;
begin
  id := Self.GetTradeableID(item);
  if id = '' then Exit;

  case item of
    '995', '996', '997', '998', '999',
    '1000', '1001', '1002', '1003', '1004': Exit(1);
  end;

  Self.Reload();
  if Self.Disabled then Exit;
  if not Self.PricesJSON.Item[0].GetObject(id, json) then Exit;

  hi := json.Item[0].AsInt; //"high" key
  lo := json.Item[2].AsInt; //"lo" key

  if lo = hi then Exit(lo);
  if lo = 0 then Exit(hi);
  if hi = 0 then Exit(lo);

  Result := (hi + lo) div 2;
end;



function TItemData.GetLowAlch(item: TRSItem): Integer;
var
  ids: TStringArray;
  id: String;
  json: TJSONItem;
  value: Integer;
begin
  if item.IsNumeric then ids := [item]
  else ids := ItemFinder.Database.GetAll(item.ToLower(), 'item', 'id');

  for id in ids do
  begin
    json := Self.GetDefinition(id);
    value := json.Item[Ord(EItemDataKey.COST)].AsInt; //8 is "cost" key
    if value > 0 then
      Exit(Round(value * 0.4));
  end;
end;


function TItemData.GetHighAlch(item: TRSItem): Integer;
var
  ids: TStringArray;
  id: String;
  json: TJSONItem;
  value: Integer;
begin
  if item.IsNumeric then ids := [item]
  else ids := ItemFinder.Database.GetAll(item.ToLower(), 'item', 'id');

  for id in ids do
  begin
    json := Self.GetDefinition(id);
    value := json.Item[Ord(EItemDataKey.COST)].AsInt; //8 is "cost" key
    if value > 0 then
      Exit(Round(value * 0.6));
  end;
end;

function TItemData.IsStackable(item: TRSItem): Boolean;
var
  ids: TStringArray;
  id: String;
  json: TJSONItem;
  stackable: Boolean;
begin
  if item.IsNumeric then ids := [item]
  else ids := ItemFinder.Database.GetAll(item.ToLower(), 'item', 'id');
  for id in ids do
  begin
    json := Self.GetDefinition(id);
    stackable := json.Item[Ord(EItemDataKey.STACKABLE)].AsBool;
    if stackable then
      Exit(stackable);
  end;
end;

var

  ItemData: TItemData;

type

  TGearData = record
    Data: TJSONItem;
  end;


procedure TGearData.Setup();
begin
  if Self.Data <> nil then Exit;
  Self.Data := new TJSONParser();
  TJSONParser(Self.Data).Load(WLAssets.Gear.Path);
end;


function TGearData.GetArray(index: Integer): TJSONItem;
begin
  Self.Setup();
  Result := Self.Data.Item[index];
end;

function TGearData.GetArray(key: String): TJSONItem; overload;
begin
  Self.Setup();
  if key = 'secondary_ammo' then key := 'ammo';
  Result := Self.Data.Item[key];
end;


function TGearData.GetItems(key: Integer): TRSItemArray;
var
  i: Int32;
begin
  Self.Setup();
  for i := 0 to Self.Data.Item[key].Count-1 do
    Result += Self.Data.Item[key].Item[i].AsString;
end;

function TGearData.GetItems(key: String): TRSItemArray; overload;
var
  i: Int32;
begin
  Self.Setup();
  if key = 'secondary_ammo' then key := 'ammo';
  for i := 0 to Self.Data.Item[key].Count-1 do
    Result += Self.Data.Item[key].Item[i].AsString;
end;

var

  GearData: TGearData;
