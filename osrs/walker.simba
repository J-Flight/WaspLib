(*
# Walker
This file is responsible for our walking system.
It is heavily inspired in the original TRSWalker by [slacky](https://slacky.one/) and it's future
iterations made by Olly.
*)

{$DEFINE WL_WALKER_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
(*
## type PRSWalker
TRSWalker pointer.
*)
  PRSWalker = ^TRSWalker;

(*
## type TRSWalkerEvent
Callback object method to use while walking. This can be used to perform custom tasks while walking.

Example:
```pascal
procedure TRSWalker.WalkerTasks(walker: PRSWalker; position, destination: TPoint);
begin
  Antiban.RandomTab();
end;

begin
  //this assumes walker is already setup.
  walker.OnWaitMoving := @walker.WalkerTasks;
end;
```
*)
  TRSWalkerEvent            = procedure(walker: PRSWalker; position, destination: TPoint) of object;
  TRSWalkerPositionFunction = function (): TPoint of object;
  TRSWalkerHeightFunction   = function (pt: TPoint = [0,0]; global: Boolean = True): Single of object;
  TRWalkerGetLocalFunction  = function (pt: TPoint; offset: TPoint = [0,0]): TPoint of object;

(*
## TRSWalker
TRSWalker is the record responsible for walking.
To work you need to set it up with something that gives it a position function
as by itself it doesn't really do anything.

Once you have a function that gives you an accurate position, you can pass it to
into a `TRSWalker` variable or into the {ref}`Walker` one, either directly or
via the {ref}`Walker.Setup` method.
*)
  TRSWalker = record
    Name: String;

    Position: TRSWalkerPositionFunction;
    Height:   TRSWalkerHeightFunction;
    GetLocal: TRWalkerGetLocalFunction;

    MinEnergy, ClickRandomness, MouseAheadTimer: Integer;

    ScreenWalk, AdaptiveWalk, FancyMouse, Walking, RedClicked: Boolean;

    AdaptiveToggleDistances, AdaptiveDistance: TPoint;


    WalkUpText, TargetUpText, ActionUpText: TStringArray;

    WebGraph: ^TWebGraph;
    MapImage: TImage;

    OnWalkEvent, OnWaitMovingEvent: TRSWalkerEvent;

    //Don't touch:
    _PathIndex: Integer;
    _Path: TPointArray;
  end;

(*
## TRSWalker.Setup
```pascal
procedure TRSWalker.Setup(
  position: function (): TPoint of object;
  height: function (p: TPoint = [-1,-1]): Single of object;
  getLocal: function (tpa: TPointArray; offset: TPoint = [0,0]): TPointArray of object;
  graph: ^TWebGraph;
  mapImage: TImage
);
```
Setup method for TRSWalker.

Only `position` is a hard requirement of this method,
all others can be `nil` if you don't need them.

`graph` is only required if you plan on doing webwaking and should point to your webgraph.
`getLocal` and `mapImage` are just for webgraph debugging if webwalking crashes.

`height` is only required if you want to pass in tile heights information to TRSWalker.

Example:
```pascal
Walker.Setup(@MyCustomPositionSystem, nil, nil, nil, nil);
```
*)

{%codetools off}
{$H-}
function TRSWalker.DummyHeight(pt: TPoint = [0,0]; global: Boolean = True): Single; begin Result := pt.X; end;
function TRSWalker.DummyGetLocal(pt: TPoint; offset: TPoint = [0,0]): TPoint; begin Result := pt+offset; end;
{$H+}
{%codetools on}

(*
## Walker.Setup
```pascal
procedure TRSWalker.Setup(position: TRSWalkerPositionFunction; height: TRSWalkerHeightFunction; getLocal: TRWalkerGetLocalFunction; graph: ^TWebGraph; mapImage: TImage);
```
Method responsible for setting up the {ref}`TRSWalker` variable.
All parameters of this function can be `nil` except for `position`.
Without a `position` callback you cannot use `TRSWalker`.

The following example is purely an example, you never have to do this since
`Map.Setup` already does this for you anyway.

Example:
```pascal
Map.Setup(ERSChunk.CATACOMBS_OF_KOUREND);
Walker.Setup(@Map.Position, @Map.Height, @Map.Loader.GetLocal, @Map.Loader.Graph, @Map.Loader.Map);
```
*)
procedure TRSWalker.Setup(position: TRSWalkerPositionFunction; height: TRSWalkerHeightFunction; getLocal: TRWalkerGetLocalFunction; graph: ^TWebGraph; mapImage: TImage);
begin
  Self.Position := @position;

  if @height <> nil then
    Self.Height := @height else Self.Height := @Self.DummyHeight;
  if @getLocal <> nil then
    Self.GetLocal := @getLocal else Self.GetLocal := @Self.DummyGetLocal;
  if Self.AdaptiveDistance = Default(TPoint) then
    Self.AdaptiveDistance := [25,110];

  Self.WalkUpText := ['Walk here', 'alk her'];
  Self.AdaptiveWalk := True;
  Self.WebGraph := graph;
  Self.MapImage := mapImage;
end;


(*
## Walker Conversions
```pascal
function TRSWalker.Point2MM(playerPoint, pt: TPoint; radians: Double): TPoint;
function TRSWalker.Point2MMVec(playerPoint, pt: TPoint; radians: Double): Vector2;
function TRSWalker.Points2MM(playerPoint: TPoint; tpa: TPointArray; radians: Double): TPointArray;
function TRSWalker.GetLocalEx(tpa: TPointArray; offset: TPoint = [0,0]): TPointArray;
function TRSWalker.GetQuadMS(playerPoint, mapPoint: TPoint; height: Double = 0; offset: Vector3 = [0,0,0]; radians: Single = $FFFF): TQuad;
function TRSWalker.MM2Map(playerPoint, minimapPoint: TPoint; radians: Single = $FFFF): TPoint;
```
Used to convert coordinates from `TRSWalker` to the minimap or the mainscreen.

Example:
```pascal
//assuming walker is already setup...
me := Walker.Position();
ShowOnTarget(Walker.GetQuadMS(me, me + [4,0])); //should show you the tile to your right.
```
*)
function TRSWalker.Point2MM(playerPoint, pt: TPoint; radians: Double): TPoint;
begin
  Result := pt - playerPoint + Minimap.Center;
  Result := Result.Rotate(radians, Minimap.Center);
end;

function TRSWalker.Point2MMVec(playerPoint, pt: TPoint; radians: Double): TVector2;
begin
  with pt - playerPoint + Minimap.Center do
    Result := ToVec2().Rotate(radians, Minimap.Center);
end;

function TRSWalker.Points2MM(playerPoint: TPoint; tpa: TPointArray; radians: Double): TPointArray;
var
  pt: TPoint;
begin
  for pt in tpa do
    Result += Self.Point2MM(playerPoint, pt, radians);
end;

function TRSWalker.FilterToMM(playerPoint: TPoint; dotFilter: TRSDotFilter; radians: Single): TRSDotFilter;
var pt: TPoint;
begin
  if dotFilter.Circle <> [] then
    with Self.Point2MM(playerPoint, dotFilter.Circle.Center, radians) do
      Result.Circle := [X, Y, dotFilter.Circle.Radius];

  for pt in Self.Points2MM(playerPoint, dotFilter.Poly, radians) do
    Result.Poly += pt;
  Result.Inside  := dotFilter.Inside;
  Result.Timeout := dotFilter.Timeout;
  Result.Timer   := dotFilter.Timer;
end;

function TRSWalker.FiltersToMM(playerPoint: TPoint; dotFilters: TRSDotFilterArray; radians: Single): TRSDotFilterArray;
var
  i: Int32;
begin

  for i := High(dotFilters) downto 0 do
  begin
    if dotFilters[i].IsExpired() then
    begin
      Delete(dotFilters, i, 1);
      Continue;
    end;

    Result += Self.FilterToMM(playerPoint, dotFilters[i], radians);
  end;
end;

function TRSWalker.GetLocalEx(tpa: TPointArray; offset: TPoint = [0,0]): TPointArray;
var
  pt: TPoint;
begin
  for pt in tpa do
    Result += Self.GetLocal(pt, offset);
end;

function TRSWalker.GetQuadMS(playerPoint, mapPoint: TPoint; radians: Single = $FFFF): TQuad;
var
  vector: TVector2;
  corners: TVector3Array;
  h: Single;
  pt, currLoc: TPoint;
  arr: TPointArray;
begin
  if not playerPoint.InRange(mapPoint, MM2MS.MAX_RENDER_DISTANCE) then Exit;
  if radians = $FFFF then radians := Minimap.GetCompassAngle(False);
  vector := Self.Point2MMVec(playerPoint, mapPoint, radians);
  pt := vector.ToPoint();

  vector := Minimap.NormalizeEx(vector, radians);
  playerPoint := Self.GetLocal(playerPoint);

  h := Self.Height(playerPoint - [1,3], False) + Self.Height(playerPoint + [3,-3], False) +
       Self.Height(playerPoint + [3,1], False) + Self.Height(playerPoint - [1,1], False);
  h := h/4;

  currLoc := playerPoint + vector.ToPoint() - Minimap.Center;

  corners := [
    [vector.X-2, vector.Y-2, Self.Height(currLoc - [1,3],  False) - h],
    [vector.X+2, vector.Y-2, Self.Height(currLoc + [3,-3], False) - h],
    [vector.X+2, vector.Y+2, Self.Height(currLoc + [3,1],  False) - h],
    [vector.X-2, vector.Y+2, Self.Height(currLoc - [1,1],  False) - h]
  ];

  arr := MM2MS.Run(corners, radians);
  Result := [arr[0], arr[1], arr[2], arr[3]];
end;

function TRSWalker.MM2Map(playerPoint, minimapPoint: TPoint; radians: Single = $FFFF): TPoint;
begin
  Result := playerPoint + minimapPoint - Minimap.Center;
  if (radians = $FFFF) then
    radians := Minimap.GetCompassAngle(False);
  Result := Result.Rotate(-radians, playerPoint);
end;


(*
## TRSWalker.InRange
```pascal
function TRSWalker.InRangeEx(me, coordinate: TPoint; distance: Integer = 4): Boolean;
function TRSWalker.InRange(coordinate: TPoint; distance: Integer = 4): Boolean;
```
Returns True/False if we are within `distance` of a certain `coordinate`.
`distance` is measured in pixels and in a radial way.
*)
function TRSWalker.InRangeEx(me, coordinate: TPoint; distance: Integer = 4): Boolean;
begin
  Result := me.DistanceTo(coordinate) <= distance;
end;

function TRSWalker.InRange(coordinate: TPoint; distance: Integer = 4): Boolean;
begin
  Result := Self.InRangeEx(Self.Position(), coordinate, distance);
end;


(*
## Walker.CheckRunEnergy
```pascal
procedure TRSWalker.CheckRunEnergy();
```
Internal method used to check and enable the player run.
You will probably never need to call this directly.

The values used are hardcoded and if you don't like them,
it's recommended you override the method.
The following example shows how one could override the function to enable
run at 50% energy everytime, keep in mind though,
you shouldn't do this, you should add randomness to it!

Example:
```pascal
procedure TRSWalker.CheckRunEnergy(); override;
begin
  if Minimap.RunEnabled() then Exit;
  if Minimap.GetLevel(ERSMinimapOrb.ENERGY) < Self.MinEnergy then Exit;

  Self.MinEnergy := 50;
  Minimap.Toggle(ERSMinimapOrb.ENERGY);
end;
```
*)
procedure TRSWalker.CheckRunEnergy();
begin
  if Minimap.RunEnabled() then Exit;
  if Minimap.GetLevel(ERSMinimapOrb.ENERGY) < Self.MinEnergy then Exit;

  Self.MinEnergy := RandomMode(40, 10, 100);
  Minimap.Toggle(ERSMinimapOrb.ENERGY);
end;

(*
## Walker.AdaptiveWalkCheck
```pascal
procedure TRSWalker.AdaptiveWalkCheck(position: TPoint);
```
Internal method used to check if adaptive walk should toggle and toggle TRSWalker.ScreenWalk.
You will probably never need to call this directly.
*)
procedure TRSWalker.AdaptiveWalkCheck(position: TPoint);
var
  wasEnabled: Boolean;
begin
  wasEnabled := Self.ScreenWalk;
  Self.ScreenWalk := False;
  if ((position.DistanceTo(Self._Path[0]) < Self.AdaptiveToggleDistances.X) or
      (position.DistanceTo(Self._Path[High(Self._Path)]) < Self.AdaptiveToggleDistances.Y)) and
     (Random() > 0.05) then
    Self.ScreenWalk := True

  else if Random() < 0.02 then
    Self.ScreenWalk := True;

  if (not wasEnabled) and (Self.ScreenWalk) and (Self.FancyMouse) and (Random() < 0.75) and Minimap.Contains(Target.MouseXY) then
    Self.DoMouseAhead(position, True);
end;

(*
## Walker.DoMouseAhead
```pascal
procedure TRSWalker.DoMouseAhead(position: TPoint; forced: Boolean = False);
```
Internal method used to pre-hover the next walking step.
You will probably never need to call this directly.
*)
procedure TRSWalker.DoMouseAhead(position: TPoint; forced: Boolean = False);
var
  flag: TPoint;
  dist: Integer;

  procedure MouseToNextPoint(myPos: TPoint);
  var
    mmPos, tmp: TPoint;
    idx: Integer;
    speed: Double;
    angle, h, diff: Single;
  begin
    angle := Minimap.GetCompassAngle(False);
    idx := Self._PathIndex;

    while (idx < High(Self._Path)) and Self.IsWalkable(Self._Path[idx+1], myPos, tmp, angle) do
      Inc(idx);

    if (idx = High(Self._Path)) and (Random(10) > 2) then Exit();

    mmPos := Self._Path[idx] - myPos + Minimap.Center;
    mmPos := mmPos.Rotate(angle, Minimap.Center);

    if Self.ScreenWalk then
    begin
      h := Self.Height(myPos);
      diff := Self.Height(Self.MM2Map(myPos, mmPos, angle));
      mmPos := Minimap.Vector2MSQuad(mmPos.ToVec3(h), angle, [1,1], [0,0,-diff]).Mean;
    end;

    speed := Target.Options.MouseSpeed;
    Target.Options.MouseSpeed := Random(6,10);
    if not Self.ScreenWalk then
      Mouse.Move(Box(mmPos, Random(5,16), Random(5,16)))
    else
      Mouse.Move(Box(mmPos, Random(15,36), Random(15,36)));
    Target.Options.MouseSpeed := speed;
  end;
begin
  if (not forced) then
    if (GetTimeRunning() < Self.MouseAheadTimer) or (not Minimap.FindFlag(Flag)) then
      Exit();

  dist := Trunc(flag.DistanceTo(Minimap.Center));
  if System.InRange(dist, Random(5,10), Random(60,70)) then
    MouseToNextPoint(position);

  Self.MouseAheadTimer := GetTimeRunning() + RandomMode(0,50,500);
  if Self.ScreenWalk then
    Self.MouseAheadTimer += RandomMode(0,50,500);
end;

(*
## Walker.WaitMoving
```pascal
procedure TRSWalker.WaitMoving(destination: TPoint; minDistance: Integer);
```
Internal method used to wait while we are moving using walker.
You will probably never need to call this directly.

This is where TRSWalker.OnWaitMoving are called.
*)
procedure TRSWalker.WaitMoving(destination: TPoint; minDistance: Integer);
var
  timeout, countdown: TCountDown;
  position: record Current, Previous: TPoint; end;
  awct: Int64;
begin
  timeout.Start(Round(GaussRand(20000, 25000)));
  countdown.Start(Round(GaussRand(500, 1500)));

  // initial timeout needs to be longer, as we might not have started walking yet.
  countdown.Extend(Round(GaussRand(2500, 3500)));

  position.Previous := Self.Position();
  position.Current := position.Previous;

  // Break from the loop if:
  // - Haven't moved in 500ms
  // - Been walking for over 20 seconds
  // - Within `minDistance` to the destination
  repeat
    Self.CheckRunEnergy();

    position.Previous := position.Current;
    position.Current := Self.Position();
    if position.Current <> position.Previous then
      countdown.Restart();

    //if Self._DoorHandler.Handling then
    //begin
    //  if Self.WebGraph^.WalkableClusters.InSameTPA(RSTranslator.NormalizeDoor(position.Current), RSTranslator.NormalizeDoor(Self._DoorHandler.Current.After)) then
    //  begin
    //    Self._PathIndex := Self._Path.IndexOf(Self._Path.NearestPoint(destination));
    //    Self._DoorHandler.Handling := False;
    //    Exit;
    //  end;
    //end;

    if @Self.OnWaitMovingEvent <> nil then
      Self.OnWaitMovingEvent(@Self, position.Current, destination);

    if (Self.AdaptiveWalk) and (Time() > awct) then
    begin
      Self.AdaptiveWalkCheck(Position.Current);
      awct := Time() + 1000;
    end;

    if Self.FancyMouse then Self.DoMouseAhead(position.Current);
    if not Self.Walking then Break;

    Sleep(50, 150);
  until timeout.IsFinished or countdown.IsFinished or position.Current.InRange(destination, minDistance);
end;

procedure TRSWalker.WaitMoving(time: Integer = 20000; doAntiban: Boolean = True); overload;
var
  timeout, countdown: TCountDown;
  moving: Boolean;
begin
  timeout.Start(time);
  countdown.Start(500);

  repeat
    if doAntiban then
      Antiban.WalkingTasks();

    moving := Minimap.IsPlayerMoving();

    if moving then
      countdown.Restart(0, 1000);

  until timeout.IsFinished or (not moving and countdown.IsFinished) or not Minimap.HasFlag();
end;

function TRSWalker.FindFlagMove(out flag: TPoint): Boolean;
var
  i: Integer;
  p, q, median: TPoint;
  history: TPointarray;
begin
  if not SleepUntil(Minimap.FindFlag(p), 10, 2000) then
    Exit(True);

  history += Self.MM2Map(Self.Position(), p);

  for i := 1 to 10 do
  begin
    if not Minimap.FindFlag(q) then
    begin
      flag := Self.Position();
      Exit(True);
    end;

    history += Self.MM2Map(Self.Position(), q);
    Sleep(50);
  end;

  median := history.Median();
  (*
  if p.DistanceTo(median) > RSTranslator.TileSize then
  begin
    flag := median + [0,8];
    Result := True;
  end;
  *)
end;


(*
## Walker.Click
```pascal
function TRSWalker.Click(minimapPoint: TPoint; Randomness: Integer): Boolean;
```
Internal method used by walker to handle clicking while walking.
You will probably never need to call this directly.

If you wish to modify certain walker behaviors, it can be a good approach to override this function.
*)
function TRSWalker.Click(playerPoint, walkerPoint, minimapPoint: TPoint; randomness: Integer): Boolean;
var
  pt: TPoint;
  upText: String;
  hoveringTarget: Boolean;
  quad: TQuad;
begin
  Self.RedClicked := False;
  if MainScreen.IsUpText('>') and not Self.ActionUpText.AnyContains('>') then
  begin
    ChooseOption.Select('Cancel');
    Exit;
  end;

  Result := True;
  Self.CheckRunEnergy();

  if Self.ScreenWalk then
  begin
    pt := walkerPoint.Random(-8, 8);
    if not playerPoint.InRange(pt, MM2MS.MAX_RENDER_DISTANCE) then Exit;

    quad := Self.GetQuadMS(playerPoint, pt);

    Mouse.Move(quad);
    upText := MainScreen.UpText;

    hoveringTarget := upText.ContainsAny(Self.TargetUpText);

    if hoveringTarget and (Self.ActionUpText <> []) then
    begin
      hoveringTarget := upText.ContainsAny(Self.ActionUpText);

      if not hoveringTarget then
      begin
        Self.RedClicked := ChooseOption.Select(Self.ActionUpText);
        if Self.RedClicked then
          Self.Walking := False;
        Exit(Self.RedClicked);
      end;
    end
    else if not upText.ContainsAny(Self.WalkUpText) then
    begin
      if not ChooseOption.Open() then Exit;
      if not ChooseOption.Find(Self.TargetUpText, True, False) then
        Exit(ChooseOption.Select(Self.WalkUpText));

      if Self.ActionUpText <> [] then
        Self.RedClicked := ChooseOption.Select(Self.ActionUpText)
      else
        Self.RedClicked := ChooseOption.Select(Self.TargetUpText);

      if Self.RedClicked then
        Self.Walking := False;
      Exit(Self.RedClicked);
    end;
  end
  else
    Mouse.Move(Minimap.RandomPoint(minimapPoint, randomness));

  if randomness = 0 then
    Mouse.Click(EMouseButton.LEFT)
  else
    Biometrics.Click(EMouseButton.LEFT);

  Self.RedClicked := Self.ScreenWalk and hoveringTarget and MainScreen.RedClicked();
  if Self.RedClicked then
    Self.Walking := False;
end;

(*
## Walker.IsWalkable
```pascal
function TRSWalker.IsWalkable(walkerPoint: TPoint; playerPoint: TPoint; out mmPoint: TPoint; angle: Double): Boolean;
```
Internal method used by walker to decide if the destination point is within 1 click reach.
You will probably never need to call this directly.
*)
function TRSWalker.IsWalkable(walkerPoint, playerPoint: TPoint; out mmPoint: TPoint; angle: Double): Boolean;
var
  corner: TPoint;
begin
  mmPoint := Self.Point2MM(playerPoint, walkerPoint, angle);
  if not Self.ScreenWalk then
    Exit(Minimap.Polygon.Expand(-1).Contains(mmPoint));

  for corner in Self.GetQuadMS(playerPoint, walkerPoint, angle).Expand(-8).Corners do
    if MainScreen.Bounds.Contains(corner) then
      Exit(True);
end;

(*
## Walker.WalkStepHelper()
```pascal
function TRSWalker.WalkStepHelper(playerPoint, walkerPoint: TPoint; out minimapPoint: TPoint): Boolean;
```
Internal method used by walker to help walking steps.
You will probably never need to call this directly.
*)
function TRSWalker.WalkStepHelper(playerPoint, walkerPoint: TPoint; out minimapPoint: TPoint): Boolean;
var
  t: UInt64;
begin
  t := Time();
  if @Self.OnWalkEvent <> nil then Self.OnWalkEvent(@Self, playerPoint, walkerPoint);
  if Time() - t > 100 then playerPoint := Self.Position(); //Check if event took too long and update position.

  if not Self.Walking then Exit;
  Result := Self.IsWalkable(walkerPoint, playerPoint, minimapPoint, Minimap.GetCompassAngle(False));
end;

(*
## Walker.WalkFinalStep
```pascal
function TRSWalker.WalkFinalStep(playerPoint, walkerPoint: TPoint; minDistance: Integer): Boolean;
```
Internal method used by walker when finishing walking a path.
You will probably never need to call this directly but it can be used to take a single step.
*)
function TRSWalker.WalkFinalStep(playerPoint, walkerPoint: TPoint; minDistance: Integer): Boolean;
var
  minimapPoint, flag: TPoint;
  wasHandlingDoor: Boolean;
begin
  if not Self.WalkStepHelper(playerPoint, walkerPoint, minimapPoint) then
    Exit(not Self.Walking);

  if (Minimap.Center.DistanceTo(minimapPoint) < 4) then
    Exit(True);

  Result := Self.Click(playerPoint, walkerPoint, minimapPoint, 0);
  if not Result then Exit;

  //if Self._DoorHandler.Handling then
  //begin
  //  wasHandlingDoor := True;
  //  if (walkerPoint.DistanceTo(Self._DoorHandler.Current.After) > 4) and (walkerPoint.DistanceTo(playerPoint) > 10) then
  //    if Self.FindFlagMove(flag) then
  //    begin
  //      flag := RSTranslator.NormalizeDoor(flag);
  //      flag := Self.WebGraph^.NearestWalkablePoint(flag);
  //      if not Self.WebGraph^.WalkableClusters.InSameTPA(flag, walkerpoint) then
  //      begin
  //        if Self.WebGraph^.WalkableClusters.InSameTPA(Self.Position(), RSTranslator.NormalizeDoor(Self._DoorHandler.Current.After)) then
  //          Exit;
  //
  //        if Minimap.IsPlayerMoving() then
  //          SleepUntil(not Minimap.IsPlayermoving(), 100, 2000);
  //        Self._DoorHandler.FlagMoved := True;
  //        Exit(False);
  //      end;
  //    end;
  //end;
  //
  //if Self._DoorHandler.SettingUp then
  //  if (playerpoint.DistanceTo(Self._DoorHandler.Current.Center) <= 99) and (playerpoint.DistanceTo(walkerPoint) > 20) then
  //  begin
  //    Minimap.SetCompassAngleEx(Self._DoorHandler.Current.GetVisibleAngle(Minimap.GetCompassAngle()), 15);
  //    Self._DoorHandler.SettingUp := False;
  //  end;
  //

  Self.WaitMoving(walkerPoint, minDistance);

  //if wasHandlingDoor then
  //  Exit(not Self._DoorHandler.Handling);
  //
  // Tolerance for final step
  Result := Self.Position().InRange(walkerPoint, Max(minDistance, 4));
end;

(*
## Walker.WalkStep
```pascal
function TRSWalker.WalkStep(playerPoint, walkerPoint: TPoint): Boolean;
```
Internal method used by walker while walking a path.
You will probably never need to call this directly.
*)
function TRSWalker.WalkStep(playerPoint, walkerPoint: TPoint): Boolean;
var
  minimapPoint, flag: TPoint;
  minDistance: Integer;
  wasHandlingDoor: Boolean;
begin
  if not Self.WalkStepHelper(playerPoint, walkerPoint, minimapPoint) then
    Exit(not Self.Walking);

  if Minimap.Center.InRange(minimapPoint, 4) then
    Exit(True);

  Result := Self.Click(playerPoint, walkerPoint, minimapPoint, Self.ClickRandomness);
  if Result then
  begin
    if (Random() < 0.15) then // 15% chance of randomness else mean
      minDistance := Random(Round(Minimap.Center.DistanceTo(minimapPoint)))
    else
      minDistance := RandomMean(0, Round(Minimap.Center.DistanceTo(minimapPoint)) + 10);

    //if Self._DoorHandler.Handling then
    //begin
    //  wasHandlingDoor := True;
    //  if (walkerPoint.DistanceTo(Self._DoorHandler.Current.After) > 4) and (walkerPoint.DistanceTo(playerpoint) > 10) then
    //    if Self.FindFlagMove(flag) then
    //    begin
    //      flag := Self.WebGraph^.WalkableSpace.NearestPoint(flag);
    //      if not Self.WebGraph^.WalkableClusters.InSameTPA(flag, walkerpoint) then
    //      begin
    //        if Self.WebGraph^.WalkableClusters.InSameTPA(Self.Position(), Self._DoorHandler.Current.After) then
    //          Exit;
    //
    //        if Minimap.IsPlayermoving() then
    //          SleepUntil(not Minimap.IsPlayermoving(), 100, 2000);
    //        Self._DoorHandler.FlagMoved := True;
    //        Exit(False);
    //      end;
    //    end;
    //end;
    //
    //if Self._DoorHandler.SettingUp then
    //  if (playerpoint.DistanceTo(Self._DoorHandler.Current.Center) <= 99) and (playerpoint.DistanceTo(walkerPoint) > 20) then
    //  begin
    //    Minimap.SetCompassAngleEx(Self._DoorHandler.Current.GetVisibleAngle(Minimap.GetCompassAngle()), 15);
    //    Self._DoorHandler.SettingUp := False;
    //  end;
    //
    //Self.WaitMoving(walkerPoint, minDistance);
    //
    //if wasHandlingDoor then
    //  Exit(not Self._DoorHandler.Handling);
  end;
end;


procedure TRSWalker.DrawPath(img: TImage; index: Integer; playerPoint: TPoint);
var
  i: Integer;
  path: TPointArray;
begin
  path := Self._Path.ExtractDist(playerPoint, 0, 90);
  path := Self.Points2MM(playerPoint, path, Minimap.GetCompassAngle(False));
  path := Minimap.Filter(path);

  for i := 0 to High(path) do
  begin
    img.DrawColor := $FFFFFF;
    if (i < High(path)) and img.InImage(path[i+1].X, path[i+1].Y) then
      img.DrawLine(path[i], path[i+1]);

    if index = i then
    begin
      img.DrawColor := $FF1010;
      img.DrawBox(TBox.Create(path[i], 2, 2));
    end
    else
    begin
      img.DrawColor := $10FF10;
      img.DrawBox(TBox.Create(path[i], 2, 2));
    end;
  end;
end;

procedure TRSWalker.DebugPath(index: Integer; playerPoint: TPoint);
var
  img: TImage;
begin
  img := Target.GetImage();
  Self.DrawPath(img, index, playerPoint);
  img.Show();
end;

function TRSWalker._BuildPath(tpa: TPointArray): TPointArray;
var
  i, j: Integer;
  line: TPointArray;
begin
  for i := 1 to High(tpa) do
  begin
    line := TPointArray.CreateFromLine(tpa[i-1], tpa[i]);

    j := 0;
    while j < High(line) do
    begin
      Result += line[j];

      if (Self.ScreenWalk or Self.AdaptiveWalk) and InRange(Options.GetZoomLevel(), 70, 100) then
        Inc(j, Random(1, 4))
      else
        Inc(j, Random(3, 12));
    end;
  end;

  Result += tpa[High(tpa)];
end;

function TRSWalker._AdvancePath(out index: Integer; playerPoint: TPoint; angle: Double): Boolean;
var
  tmp: TPoint;
  previous: Integer;
  nearest, furthest: Integer;
begin
  previous := index;

  nearest := Self._Path.IndexOf(Self._Path.NearestPoint(playerPoint));
  Self._Pathindex := nearest;

  while (nearest < High(Self._Path)) and (not Self.IsWalkable(Self._Path[nearest+1], playerPoint, tmp, angle)) do
    Inc(nearest);

  furthest := nearest;
  while (furthest < High(Self._Path)) and Self.IsWalkable(Self._Path[furthest+1], playerPoint, tmp, angle) do
    Inc(furthest);

  index := furthest;

  // do the result check before randomness to avoid false error
  Result := index > previous;

  // 0.2% chance of randomness else furthest
  if Biometrics.RandomBoolean(0.002) then
    index := Random(nearest, furthest);
end;

procedure TRSWalker._WalkPathSetup(path: TPointArray);
var
  me: TPoint;
begin
  Self.Walking := True;
  me := Self.Position();

  Self._Path := Self._BuildPath([me] + path);

  if Self.AdaptiveWalk then
  begin
    Self.AdaptiveToggleDistances.X := Self.AdaptiveDistance.X + Random(-6,6);
    Self.AdaptiveToggleDistances.Y := Self.AdaptiveDistance.Y + Random(-16,16);
    Self.AdaptiveWalkCheck(me);
  end;
end;

function TRSWalker._WalkPathHelper(out index: Integer; out angle: Double; playerPoint: TPoint; fails: Integer; debug: Boolean): Integer;
begin
  if debug then
    Self.DebugPath(index, playerPoint);

  Result := fails;

  if Self._AdvancePath(index, playerPoint, angle) then
    Exit(0);

  //Likely haven't moved far enough to advance to next point
  if Inc(Result) < 5 then
  begin
    Sleep(300);
    Exit;
  end;

  //Screen walking struggles, so disable it
  if Self.AdaptiveWalk and Self.ScreenWalk then
  begin
    Self.ScreenWalk := False;
    if Self._AdvancePath(index, playerPoint, angle) then
      Exit(0);
  end;

  if (Result = 5) then
  begin
    Minimap.SetCompassAngle(RadToDeg(angle) + RandomLeft(30, 360) * Random(-1,1));
    angle := Minimap.GetCompassAngle(False);
  end;

  if Result mod 2 = 0 then
    Minimap.WaitFlag();
end;


(*
## TRSWalker.WalkPath
```pascal
function TRSWalker.WalkPath(Path: TPointArray; minDistance: Integer = 0): Boolean;
```
Walks a path of points taken from the loaded map. We advice that minDistance is not 0.

Parameters:
- Path
	Array of points taken from the loaded map to walk. Must be ordered from start to finish.
- minDistance
	Determines when the method returns once the final point has been clicked. Default value: 0.
	| *minDistance=0* waits until the player has reached the final point.
	| *minDistance=20* waits until the player is within 20 pixels of the final point.

Example:
```pascal
Walker.WalkPath([[100,100],[120,120],[140,140],[160,160],[180,180]]);
```
*)
function TRSWalker.WalkPath(path: TPointArray; minDistance: Integer = 0; data: EGraphNodeArray = []; debug: Boolean = False): Boolean;
var
  playerPoint: TPoint;
  index, fails: Integer;
  angle: Double;
begin
  Self._WalkPathSetup(path);

  angle := Minimap.GetCompassAngle(False);
  while Self.Walking and (fails < 10) do
  begin
    playerPoint := Self.Position();

    //if Self._DoorHandler.FlagMoved then
    //begin
    //  Self._DoorHandler.FlagMoved := False;
    //  Exit(Self.WebGraph^.WalkableClusters.InSameTPA(playerPoint, RSTranslator.NormalizeDoor(Self._DoorHandler.Current.After)));
    //end;
    //
    fails := Self._WalkPathHelper(index, angle, playerPoint, fails, debug);

    if index = High(Self._Path) then
    begin
      if Self.WalkFinalStep(playerPoint, Self._Path[index], minDistance) then
        Exit(True);
      Continue;
    end;

    if fails > 0 then Continue;

    Self.WalkStep(playerPoint, Self._Path[index]);
  end;

  if fails = 10 then
    WriteLn GetDebugLn(Self.Name, 'Failed to advance path', ELogLevel.WARN);
end;

(*
## TRSWalker.WalkBlind
```pascal
function TRSWalker.WalkBlind(Destination: TPoint; minDistance: Integer = 0): Boolean;
```
"Blindly" walks to a point taken from the loaded map.
A straight line is generated between the player's position and destination which is then walked.

Parameters:
- Destination
  Destination point taken from the loaded map.
- minDistance
	Determines when the method returns once the final point has been clicked. Default value: 0.
	| *minDistance=0* waits until the player has reached the final point.
	| *minDistance=20* waits until the player is within 20 pixels of the final point.

Example:
```pascal
Walker.WalkBlind([300, 300]);
```
*)
function TRSWalker.WalkBlind(Destination: TPoint; minDistance: Integer = 0): Boolean;
begin
  Result := Self.WalkPath([Destination], minDistance);
end;


(*
## TRSWalker.GetClosestPoint
```pascal
function TRSWalker.GetClosestPointEx(me: TPoint; destinations: TPointArray): TPoint;
function TRSWalker.GetClosestPoint(destinations: TPointArray): TPoint;
```
Method used to get the closest Point to the Player out of a TPA.
*)
function TRSWalker.GetClosestPointEx(me: TPoint; destinations: TPointArray; out path: TPointArray; out data: EGraphNodeArray): TPoint; overload;
var
  shortPaths: T2DPointArray;
  shortest, dist: Integer;
  destination: TPoint;
begin
  me := Self.Position();
  shortest := $FFFFFF;

  for destination in destinations do
  begin
    try
      path := Self.WebGraph^.PathBetween(me, destination, 0, 4);
    except
      Continue;
    end;

    if path = [] then Continue;

    dist := Floor(path.PolylineLength());
    if dist < shortest then
    begin
      shortPaths := [path];
      shortest := dist;
    end
    else if dist = shortest then
      shortPaths += path;

    path := [];
  end;

  if shortPaths = [] then
    Exit(destinations.NearestPoint(me));

  path := shortPaths.Random();
  Result := path.Last;
end;

function TRSWalker.GetClosestPoint(me: TPoint; destinations: TPointArray; out path: TPointArray): TPoint; overload;
var
  data: EGraphNodeArray;
begin
  Result := Self.GetClosestPointEx(me, destinations, path, data);
end;



function TRSWalker._GetPath(me, destination: TPoint; out data: EGraphNodeArray; safe: Boolean; randomness: Double): TPointArray;
var
  img: TImage;
  tmp: TWebGraph;
  closestMe, closestDest: TIntegerArray;
  i: Integer;
begin
  try
    Result := Self.WebGraph^.PathBetweenEx(me, destination, data, randomness, 4, safe);
  except
    if Assigned(Self.MapImage) and (Length(Self.WebGraph^.Nodes) > 0) then
    begin
      img := Self.MapImage.Copy();
      tmp := Self.WebGraph^;

      closestMe   := Self.WebGraph^.NearNodesIndices(me, 4);
      closestDest := Self.WebGraph^.NearNodesIndices(destination, 4);

      tmp.Nodes := Self.GetLocalEx(tmp.Nodes);
      me := Self.GetLocal(me);
      destination := Self.GetLocal(destination);

      tmp.Draw(img);

      for i := 0 to 3 do
      begin
        if i < Length(closestMe) then
        begin
          img.DrawColor := $FF00FF;
          img.DrawCircle(tmp.Nodes[closestMe[i]], 4);
        end;

        if i < Length(closestDest) then
        begin
          img.DrawColor := $FF0000;
          img.DrawCircle(tmp.Nodes[closestDest[i]], 4);
        end;
      end;

      img.DrawColor := $00FF00;
      if img.InImage(me.X, me.Y) then
        img.DrawCross(me, 4);

      if img.InImage(destination.X, destination.Y) then
        img.DrawCross(destination, 4);

      img.Show();
    end;
    raise GetDebugLn(Self.Name, GetExceptionMessage());
  end;
end;

(*
## TRSWalker.WebWalk
```pascal
function TRSWalker.WebWalkEx(me, destination: TPoint; minDistance: Integer = 0; randomness: Double = 0): Boolean;
function TRSWalker.WebWalk(destination: TPoint; minDistance: Integer = 0; randomness: Double = 0): Boolean;
function TRSWalker.WebWalk(destinations: TPointArray; minDistance: Integer = 0; randomness: Double = 0): Boolean; overload;
```
Web walks to the destination point on the loaded map. Does **not** handle any obstacles.
*)
function TRSWalker.WebWalkEx(me, destination: TPoint; minDistance: Integer = 0; randomness: Double = 0; debug: Boolean = False): Boolean;
var
  path: TPointArray;
  data: EGraphNodeArray;
  tries, lastIdx: Integer;
begin
  if not System.InRange(randomness, 0, 1) then
    raise GetDebugLn('Walker' 'WebWalk `randomness` must be between 0.0 an 1.0');

  if me.InRange(destination, 3) then
    Exit(True);
  path := Self._GetPath(me, destination, data, True, randomness);
  Result := Self.WalkPath(path, minDistance, data, debug);
end;

function TRSWalker.WebWalk(destination: TPoint; minDistance: Integer = 0; randomness: Double = 0; debug: Boolean = False): Boolean;
begin
  Result := Self.WebWalkEx(Self.Position(), destination, minDistance, randomness, debug);
end;

function TRSWalker.WebWalk(destinations: TPointArray; minDistance: Integer = 0; randomness: Double = 0; debug: Boolean = False): Boolean; overload;
var
  me, destination: TPoint;
  path: TPointArray;
  data: EGraphNodeArray;
begin
  if not System.InRange(randomness, 0, 1) then
    raise GetDebugLn('Walker' 'WebWalk `randomness` must be between 0.0 an 1.0');

  me := Self.Position();
  destination := Self.GetClosestPointEx(me, destinations, path, data);

  if me.InRange(destination, 3) then
    Exit(True);

  Result := Self.WalkPath(path, minDistance, data, debug);
end;

(*
## TRSWalker.MakePointVisible
```pascal
function TRSWalker.MakePointVisible(p: TPoint): Boolean;
function TRSWalker.MakePointVisible(tpa: TPointArray): Boolean; overload;
```
Wrapper function used to attempt to make a Point visible on the MainScreen.
*)
function TRSWalker.MakePointVisible(me: TPoint; pt: TPoint): Boolean;
begin
  Result := Minimap.MakePointVisible(Self.Point2MM(me, pt, Minimap.GetCompassAngle(False)));
end;

function TRSWalker.MakePointVisible(pt: TPoint): Boolean; overload;
begin
  Result := Self.MakePointVisible(Self.Position(), pt);
end;
