(*
# Walker
This file is responsible for our walking system.
It is heavily inspired in the original TRSWalker by Slacky and it's future
iterations made by Olly.
*)

{$DEFINE SRLT_WALKER_INCLUDED}
{$INCLUDE_ONCE SRLT/osrs.simba}

type
(*
(PRSWalker)=
## type PRSWalker
TRSWalker pointer.
*)
  PRSWalker = ^TRSWalker;

(*
(TRSWalkerEvent)=
## type TRSWalkerEvent
Callback object method to use while walking. This can be used to perform custom tasks while walking.

Example:
```pascal
procedure TRSWalker.WalkerTasks(walker: PRSWalker; position, destination: TPoint);
begin
  Antiban.RandomTab();
end;

begin
  //this assumes walker is already setup.
  walker.OnWaitMoving := @walker.WalkerTasks;
end;
```
*)
  TRSWalkerEvent            = procedure(walker: PRSWalker; position, destination: TPoint) of object;
  TRSWalkerPositionFunction = function (): TPoint of object;
  TRSWalkerHeightFunction   = function (pt: TPoint = [0,0]): Single of object;
  TRWalkerGetLocalFunction  = function (pt: TPoint; offset: TPoint = [0,0]): TPoint of object;

(*
(TRSWalker)=
## type TRSWalker
TRSWalker is the record responsible for walking.
To work you need to set it up with something that gives it a position function
as by itself it doesn't really do anything.

Once you have a function that gives you an accurate position, you can pass it to
into a `TRSWalker` variable or into the {ref}`Walker` one, either directly or
via the {ref}`Walker.Setup()` method.
*)
  TRSWalker = record
    Name: String;

    Position: TRSWalkerPositionFunction;
    Height:   TRSWalkerHeightFunction;
    GetLocal: TRWalkerGetLocalFunction;

    MinEnergy, ClickRandomness, MouseAheadTimer: Integer;

    ScreenWalk, AdaptiveWalk, FancyMouse, Walking, RedClicked: Boolean;

    AdaptiveToggleDistances: TPoint;

    WalkUpText, TargetUpText, ActionUpText: TStringArray;

    WebGraph: ^TWebGraph;
    MapImage: TImage;

    OnWalkEvent, OnWaitMovingEvent: TRSWalkerEvent;


    //Don't touch:
    _PathIndex: Integer;
    _Path: TPointArray;

    _DoorHandler: record
      Door: TRSDoor;
      DoorsOnPath: TRSDoorArray;
      FlagMoved, Handling, SettingUp, Skipped, Enabled: Boolean;
    end;
  end;

var
  WALKER_ADAPTIVE_SCREEN_TOGGLE_DISTANCES: TPoint = [25,110];

(*
## TRSWalker.Setup
```pascal
procedure TRSWalker.Setup(
  position: function (): TPoint of object;
  height: function (p: TPoint = [-1,-1]): Single of object;
  getLocal: function (tpa: TPointArray; offset: TPoint = [0,0]): TPointArray of object;
  graph: ^TWebGraph;
  mapImage: TImage
);
```
Setup method for TRSWalker.

Only `position` is a hard requirement of this method,
all others can be `nil` if you don't need them.

`graph` is only required if you plan on doing webwaking and should point to your webgraph.
`getLocal` and `mapImage` are just for webgraph debugging if webwalking crashes.

`height` is only required if you want to pass in tile heights information to TRSWalker.

Example:
```pascal
Walker.Setup(@MyCustomPositionSystem, nil, nil, nil, nil);
```
*)

{%codetools off}
function TRSWalker.DummyHeight(pt: TPoint = [0,0]): Single; begin Result := pt.X; end;
function TRSWalker.DummyGetLocal(pt: TPoint; offset: TPoint = [0,0]): TPoint; begin Result := pt+offset; end;
{%codetools on}

(*
## Walker.Setup
```pascal
procedure TRSWalker.Setup(position: TRSWalkerPositionFunction; height: TRSWalkerHeightFunction; getLocal: TRWalkerGetLocalFunction; graph: ^TWebGraph; mapImage: TImage);
```
Method responsible for setting up the {ref}`TRSWalker` variable.
All parameters of this function can be `nil` except for `position`.
Without a `position` callback you cannot use `TRSWalker`.

The following example is purely an example, you never have to do this since
`Map.Setup` already does this for you anyway.

Example:
```pascal
Map.Setup(ERSChunk.CATACOMBS_OF_KOUREND);
Walker.Setup(@Map.Position, @Map.Height, @Map.Loader.GetLocal, @Map.Loader.Graph, @Map.Loader.Map);
```
*)
procedure TRSWalker.Setup(position: TRSWalkerPositionFunction; height: TRSWalkerHeightFunction; getLocal: TRWalkerGetLocalFunction; graph: ^TWebGraph; mapImage: TImage);
begin
  Self.Position := @position;
  if @height <> nil then Self.Height := @height else Self.Height := @Self.DummyHeight;
  if @getLocal <> nil then Self.GetLocal := @getLocal else Self.GetLocal := @Self.DummyGetLocal;

  Self.WalkUpText := ['Walk here', 'alk her'];
  Self.AdaptiveWalk := True;
  Self.WebGraph := graph;
  Self.MapImage := mapImage;
end;


(*
## Walker Conversions
```pascal
function TRSWalker.Point2MM(playerPoint, pt: TPoint; radians: Double): TPoint;
function TRSWalker.Point2MMVec(playerPoint, pt: TPoint; radians: Double): Vector2;
function TRSWalker.Points2MM(playerPoint: TPoint; tpa: TPointArray; radians: Double): TPointArray;
function TRSWalker.GetLocalEx(tpa: TPointArray; offset: TPoint = [0,0]): TPointArray;
function TRSWalker.GetQuadMS(playerPoint, mapPoint: TPoint; height: Double = 0; offset: Vector3 = [0,0,0]; radians: Single = $FFFF): TQuad;
function TRSWalker.MM2Map(playerPoint, minimapPoint: TPoint; radians: Single = $FFFF): TPoint;
```
Used to convert coordinates from `TRSWalker` to the minimap or the mainscreen.

Example:
```pascal
//assuming walker is already setup...
me := Walker.Position();
ShowOnClient(Walker.GetQuadMS(me, me + [4,0])); //should show you the tile to your right.
```
*)
function TRSWalker.Point2MM(playerPoint, pt: TPoint; radians: Double): TPoint;
begin
  Result := pt - playerPoint + Minimap.Center;
  Result := Result.Rotate(radians, Minimap.Center);
end;

function TRSWalker.Point2MMVec(playerPoint, pt: TPoint; radians: Double): Vector2;
begin
  with pt - playerPoint + Minimap.Center do
    Result := Vec2(X,Y).Rotate(radians, Minimap.Center);
end;

function TRSWalker.Points2MM(playerPoint: TPoint; tpa: TPointArray; radians: Double): TPointArray;
var
  pt: TPoint;
begin
  for pt in tpa do
    Result += Self.Point2MM(playerPoint, pt, radians);
end;

function TRSWalker.GetLocalEx(tpa: TPointArray; offset: TPoint = [0,0]): TPointArray;
var
  pt: TPoint;
begin
  for pt in tpa do
    Result += Self.GetLocal(pt, offset);
end;


function TRSWalker.GetQuadMS(playerPoint, mapPoint: TPoint; height: Double = 0; offset: Vector3 = [0,0,0]; radians: Single = $FFFF): TQuad;
var
  vector: Vector2;
begin
  if radians = $FFFF then
    radians := Minimap.GetCompassAngle(False);

  with Minimap.Center + (mapPoint - playerPoint) do
    vector := Vec2(X, Y).Rotate(radians, Minimap.Center);

  Result := Minimap.Vector2MSQuad(Vec3(vector.X, vector.Y, height), radians, [1,1], offset);
end;

function TRSWalker.MM2Map(playerPoint, minimapPoint: TPoint; radians: Single = $FFFF): TPoint;
begin
  Result := playerPoint + minimapPoint - Minimap.Center;
  if (radians = $FFFF) then
    radians := Minimap.GetCompassAngle(False);
  Result := Result.Rotate(-radians, playerPoint);
end;


(*
## TRSWalker.InRange
```pascal
function TRSWalker.InRangeEx(me, coordinate: TPoint; distance: Integer = 4): Boolean;
function TRSWalker.InRange(coordinate: TPoint; distance: Integer = 4): Boolean;
```
Returns True/False if we are within `distance` of a certain `coordinate`.
`distance` is measured in pixels and in a radial way.
*)
function TRSWalker.InRangeEx(me, coordinate: TPoint; distance: Integer = 4): Boolean;
begin
  Result := me.DistanceTo(coordinate) <= distance;
end;

function TRSWalker.InRange(coordinate: TPoint; distance: Integer = 4): Boolean;
begin
  Result := Self.InRangeEx(Self.Position(), coordinate, distance);
end;


(*
## Walker.CheckRunEnergy
```pascal
procedure TRSWalker.CheckRunEnergy();
```
Internal method used to check and enable the player run.
You will probably never need to call this directly.

The values used are hardcoded and if you don't like them,
it's recommended you override the method.
The following example shows how one could override the function to enable
run at 50% energy everytime, keep in mind though,
you shouldn't do this, you should add randomness to it!

Example:
```pascal
procedure TRSWalker.CheckRunEnergy(); override;
begin
  if Minimap.RunEnabled() then Exit;
  if Minimap.GetLevel(ERSMinimapOrb.ENERGY) < Self.MinEnergy then Exit;

  Self.MinEnergy := 50;
  Minimap.Toggle(ERSMinimapOrb.ENERGY);
end;
```
*)
procedure TRSWalker.CheckRunEnergy();
begin
  if Minimap.RunEnabled() then Exit;
  if Minimap.GetLevel(ERSMinimapOrb.ENERGY) < Self.MinEnergy then Exit;

  Self.MinEnergy := RandomMode(40, 10, 100);
  Minimap.Toggle(ERSMinimapOrb.ENERGY);
end;

(*
## Walker.AdaptiveWalkCheck
```pascal
procedure TRSWalker.AdaptiveWalkCheck(position: TPoint);
```
Internal method used to check if adaptive walk should toggle and toggle TRSWalker.ScreenWalk.
You will probably never need to call this directly.
*)
procedure TRSWalker.AdaptiveWalkCheck(position: TPoint);
var
  wasEnabled: Boolean;
begin
  wasEnabled := Self.ScreenWalk;
  Self.ScreenWalk := False;
  if ((position.DistanceTo(Self._Path[0]) < Self.AdaptiveToggleDistances.X) or
      (position.DistanceTo(Self._Path[High(Self._Path)]) < Self.AdaptiveToggleDistances.Y)) and
     (Random() > 0.05) then
    Self.ScreenWalk := True

  else if Random() < 0.02 then
    Self.ScreenWalk := True;

  if (not wasEnabled) and (Self.ScreenWalk) and (Self.FancyMouse) and (Random() < 0.75) and Minimap.Contains(Target.MouseXY) then
    Self.DoMouseAhead(position, True);
end;

(*
## Walker.DoMouseAhead
```pascal
procedure TRSWalker.DoMouseAhead(position: TPoint; forced: Boolean = False);
```
Internal method used to pre-hover the next walking step.
You will probably never need to call this directly.
*)
procedure TRSWalker.DoMouseAhead(position: TPoint; forced: Boolean = False);
var
  flag: TPoint;
  dist: Integer;

  procedure MouseToNextPoint(myPos: TPoint);
  var
    mmPos: TPoint;
    idx: Integer;
    speed: Double;
    angle, h, diff: Single;
  begin
    angle := Minimap.GetCompassAngle(False);
    idx := Self._PathIndex;

    while (idx < High(Self._Path)) and Self.IsWalkable(Self._Path[idx+1], myPos, angle) do
      Inc(idx);

    if (idx = High(Self._Path)) and (Random(10) > 2) then Exit();

    mmPos := Self._Path[idx] - myPos + Minimap.Center;
    mmPos := mmPos.Rotate(angle, Minimap.Center);

    if Self.ScreenWalk then
    begin
      h := Self.Height(myPos);
      diff := Self.Height(Self.MM2Map(myPos, mmPos, angle));
      mmPos := Minimap.Vector2MSQuad(Vec3(mmPos.X, mmPos.Y, h), angle, [1,1], Vec3(0,0,-diff)).Mean;
    end;

    speed := Target.MouseOptions.Speed;
    Target.MouseOptions.Speed := Random(6,10);
    if not Self.ScreenWalk then
      Mouse.Move(Box(mmPos, Random(5,16), Random(5,16)))
    else
      Mouse.Move(Box(mmPos, Random(15,36), Random(15,36)));
    Target.MouseOptions.Speed := speed;
  end;
begin
  if (not forced) then
    if (GetTimeRunning() < Self.MouseAheadTimer) or (not Minimap.FindFlag(Flag)) then
      Exit();

  dist := Trunc(flag.DistanceTo(Minimap.Center));
  if System.InRange(dist, Random(5,10), Random(60,70)) then
    MouseToNextPoint(position);

  Self.MouseAheadTimer := GetTimeRunning() + RandomMode(0,50,500);
  if Self.ScreenWalk then
    Self.MouseAheadTimer += RandomMode(0,50,500);
end;

(*
## Walker.WaitMoving
```pascal
procedure TRSWalker.WaitMoving(destination: TPoint; waitUntilDistance: Integer);
```
Internal method used to wait while we are moving using walker.
You will probably never need to call this directly.

This is where TRSWalker.OnWaitMoving are called.
*)
procedure TRSWalker.WaitMoving(destination: TPoint; waitUntilDistance: Integer);
var
  timeout, countdown: TCountDown;
  position: record Current, Previous: TPoint; end;
  awct: Int64;
begin
  timeout.Init(Round(GaussRand(20000, 25000)));
  countdown.Init(Round(GaussRand(500, 1500)));

  // initial timeout needs to be longer, as we might not have started walking yet.
  countdown.Timeout := GetTickCount() + Round(GaussRand(2500, 3500));

  position.Previous := Self.Position();
  position.Current := position.Previous;

  // Break from the loop if:
  // - Haven't moved in 500ms
  // - Been walking for over 20 seconds
  // - Within `waitUntilDistance` to the destination
  repeat
    Self.CheckRunEnergy();

    position.Previous := position.Current;
    position.Current := Self.Position();
    if position.Current <> position.Previous then
      countdown.Restart();


    if Self._DoorHandler.Handling then
    begin
      if Self.WebGraph^.WalkableClusters.InSameTPA(RSTranslator.NormalizeDoor(position.Current), RSTranslator.NormalizeDoor(Self._DoorHandler.Door.After)) then
      begin
        Self._PathIndex := Self._Path.IndexOf(Self._Path.NearestPoint(destination));
        Self._DoorHandler.Handling := False;
        Exit;
      end;
    end;


    if @Self.OnWaitMovingEvent <> nil then
      Self.OnWaitMovingEvent(@Self, position.Current, destination);

    if (Self.AdaptiveWalk) and (GetTickCount() > awct) then
    begin
      Self.AdaptiveWalkCheck(Position.Current);
      awct := GetTickCount() + 1000;
    end;

    if Self.FancyMouse then Self.DoMouseAhead(position.Current);
    if not Self.Walking then Break;

    Sleep(50, 150);
  until timeout.IsFinished() or countdown.IsFinished() or (position.Current.DistanceTo(destination) <= waitUntilDistance);
end;


function TRSWalker.FindFlagMove(out flag: TPoint): Boolean;
var
  i: Integer;
  p, q, median: TPoint;
  history: TPointarray;
begin
  if not SleepUntil(Minimap.FindFlag(p), 10, 2000) then
    Exit(True);

  history += Self.MM2Map(Self.Position(), p);

  for i := 1 to 10 do
  begin
    if not Minimap.FindFlag(q) then
    begin
      flag := Self.Position();
      Exit(True);
    end;

    history += Self.MM2Map(Self.Position(), q);
    Sleep(50);
  end;

  median := history.Median();
  (*
  if p.DistanceTo(median) > RSTranslator.TileSize then
  begin
    flag := median + [0,8];
    Result := True;
  end;
  *)
end;


(*
## Walker.Click
```pascal
function TRSWalker.Click(minimapPoint: TPoint; Randomness: Integer): Boolean;
```
Internal method used by walker to handle clicking while walking.
You will probably never need to call this directly.

If you wish to modify certain walker behaviors, it can be a good approach to override this function.
*)
function TRSWalker.Click(minimapPoint: TPoint; randomness: Integer; height: Single = 0): Boolean;
var
  p: TPoint;
  upText: String;
  hoveringTarget: Boolean;
begin
  Self.RedClicked := False;
  if MainScreen.IsUpText('>') and not Self.ActionUpText.AnyContains('>') then
  begin
    ChooseOption.Select('Cancel');
    Exit;
  end;

  Result := True;
  Self.CheckRunEnergy();

  if Self.ScreenWalk then
  begin
    p := Minimap.RandomPointOnZoomQuad(minimapPoint, randomness);
    Mouse.Move(Minimap.Vector2MSQuad(Vec3(p.X, p.Y, height), Minimap.GetCompassAngle(False)).Mean);
    upText := MainScreen.GetUpText();

    hoveringTarget := upText.ContainsAny(Self.TargetUpText);
    if hoveringTarget and (Self.ActionUpText <> []) then
    begin
      hoveringTarget := upText.ContainsAny(Self.ActionUpText);

      if not hoveringTarget then
      begin
        Self.RedClicked := ChooseOption.Select(Self.ActionUpText);
        if Self.RedClicked then Self.Walking := False;
        Exit(Self.RedClicked);
      end;
    end
    else if not upText.ContainsAny(Self.WalkUpText) then
    begin
      if not ChooseOption.Open() then Exit;
      if not ChooseOption.Find(Self.TargetUpText, True, False) then
        Exit(ChooseOption.Select(Self.WalkUpText));

      if Self.ActionUpText <> [] then
        Self.RedClicked := ChooseOption.Select(Self.ActionUpText)
      else
        Self.RedClicked := ChooseOption.Select(Self.TargetUpText);

      if Self.RedClicked then Self.Walking := False;
      Exit(Self.RedClicked);
    end;

  end
  else
    Mouse.Move(Minimap.RandomPoint(minimapPoint, randomness));

  if randomness = 0 then
    Mouse.Click(EMouseButton.LEFT)
  else
    Biometrics.Click(EMouseButton.LEFT);

  Self.RedClicked := Self.ScreenWalk and hoveringTarget and MainScreen.RedClicked();
  if Self.RedClicked then Self.Walking := False;
end;

(*
## Walker.WalkStepHelper()
```pascal
function TRSWalker.WalkStepHelper(playerPoint, walkerPoint: TPoint; out minimapPoint: TPoint): Boolean;
```
Internal method used by walker to help walking steps.
You will probably never need to call this directly.
*)
function TRSWalker.WalkStepHelper(playerPoint, walkerPoint: TPoint; out minimapPoint: TPoint): Boolean;
var
  event_time: UInt64;
begin
  event_time := GetTickCount();

  // run events
  if @Self.OnWalkEvent <> nil then
    Self.OnWalkEvent(@Self, playerPoint, walkerPoint);

  // in case the events used a bit of time, while our character was moving towards a point, we have to update the current position.
  if GetTickCount() - event_time > 100 then
    playerPoint := Self.Position();

  if not Self.Walking then
    Exit;

  minimapPoint := Self.Point2MM(playerPoint, walkerPoint, Minimap.GetCompassAngle(False));

  if Self.ScreenWalk then
    Exit(Minimap.PointOnZoomQuad(minimapPoint));

  Result := Minimap.Contains(minimapPoint);
end;

(*
## Walker.WalkFinalStep
```pascal
function TRSWalker.WalkFinalStep(playerPoint, walkerPoint: TPoint; waitUntilDistance: Integer): Boolean;
```
Internal method used by walker when finishing walking a path.
You will probably never need to call this directly but it can be used to take a single step.
*)
function TRSWalker.WalkFinalStep(playerPoint, walkerPoint: TPoint; waitUntilDistance: Integer): Boolean;
var
  minimapPoint, flag: TPoint;
  h, diff: Single;
  wasHandlingDoor: Boolean;
begin
  if not Self.WalkStepHelper(playerPoint, walkerPoint, minimapPoint) then
    Exit(not Self.Walking);

  if (Minimap.Center.DistanceTo(minimapPoint) < 4) then
    Exit(True);

  h := Self.Height(playerPoint);
  diff := -(h-Self.Height(walkerPoint));

  Result := Self.Click(minimapPoint, 0, diff);
  if not Result then Exit;


  if Self._DoorHandler.Handling then
  begin
    wasHandlingDoor := True;
    if (walkerPoint.DistanceTo(Self._DoorHandler.Door.After) > 4) and (walkerPoint.DistanceTo(playerPoint) > 10) then
      if Self.FindFlagMove(flag) then
      begin
        flag := RSTranslator.NormalizeDoor(flag);
        flag := Self.WebGraph^.NearestWalkablePoint(flag);
        if not Self.WebGraph^.WalkableClusters.InSameTPA(flag, walkerpoint) then
        begin
          if Self.WebGraph^.WalkableClusters.InSameTPA(Self.Position(), RSTranslator.NormalizeDoor(Self._DoorHandler.Door.After)) then
            Exit;

          if Minimap.IsPlayerMoving() then
            SleepUntil(not Minimap.IsPlayermoving(), 100, 2000);
          Self._DoorHandler.FlagMoved := True;
          Exit(False);
        end;
      end;
  end;


  if Self._DoorHandler.SettingUp then
    if (playerpoint.DistanceTo(Self._DoorHandler.Door.Center) <= 99) and (playerpoint.DistanceTo(walkerPoint) > 20) then
    begin
      Minimap.SetCompassAngleEx(Self._DoorHandler.Door.GetVisibleAngle(Minimap.GetCompassAngle()), 15);
      Self._DoorHandler.SettingUp := False;
    end;


  Self.WaitMoving(walkerPoint, waitUntilDistance);

  if wasHandlingDoor then
    Exit(not Self._DoorHandler.Handling);
end;

(*
## Walker.WalkStep
```pascal
function TRSWalker.WalkStep(playerPoint, walkerPoint: TPoint): Boolean;
```
Internal method used by walker while walking a path.
You will probably never need to call this directly.
*)
function TRSWalker.WalkStep(playerPoint, walkerPoint: TPoint): Boolean;
var
  minimapPoint, flag: TPoint;
  waitUntilDistance: Integer;
  wasHandlingDoor: Boolean;
begin
  if not Self.WalkStepHelper(playerPoint, walkerPoint, minimapPoint) then
    Exit(not Self.Walking);

  if (Minimap.Center.DistanceTo(minimapPoint) < 4) then
    Exit(True);

  Result := Self.Click(minimapPoint, Self.ClickRandomness);
  if Result then
  begin
    if (Random() < 0.15) then // 15% chance of randomness else mean
      waitUntilDistance := Random(Round(Minimap.Center.DistanceTo(minimapPoint)))
    else
      waitUntilDistance := RandomMean(0, Round(Minimap.Center.DistanceTo(minimapPoint)) + 10);

    if Self._DoorHandler.Handling then
    begin
      wasHandlingDoor := True;
      if (walkerPoint.DistanceTo(Self._DoorHandler.Door.After) > 4) and (walkerPoint.DistanceTo(playerpoint) > 10) then
        if Self.FindFlagMove(flag) then
        begin
          flag := Self.WebGraph^.WalkableSpace.NearestPoint(flag);
          if not Self.WebGraph^.WalkableClusters.InSameTPA(flag, walkerpoint) then
          begin
            if Self.WebGraph^.WalkableClusters.InSameTPA(Self.Position(), Self._DoorHandler.Door.After) then
              Exit;

            if Minimap.IsPlayermoving() then
              SleepUntil(not Minimap.IsPlayermoving(), 100, 2000);
            Self._DoorHandler.FlagMoved := True;
            Exit(False);
          end;
        end;
    end;

    if Self._DoorHandler.SettingUp then
      if (playerpoint.DistanceTo(Self._DoorHandler.Door.Center) <= 99) and (playerpoint.DistanceTo(walkerPoint) > 20) then
      begin
        Minimap.SetCompassAngleEx(Self._DoorHandler.Door.GetVisibleAngle(Minimap.GetCompassAngle()), 15);
        Self._DoorHandler.SettingUp := False;
      end;

    Self.WaitMoving(walkerPoint, waitUntilDistance);

    if wasHandlingDoor then
      Exit(not Self._DoorHandler.Handling);
  end;
end;

(*
## Walker.IsWalkable
```pascal
function TRSWalker.IsWalkable(walkerPoint: TPoint; playerPoint: TPoint; Angle: Double): Boolean;
```
Internal method used by walker to decide if the destination point is within 1 click reach.
You will probably never need to call this directly.
*)
function TRSWalker.IsWalkable(walkerPoint: TPoint; playerPoint: TPoint; angle: Double): Boolean;
var
  mmPoint: TPoint;
  h, diff: Single;
  b: TBox;
begin
  mmPoint := Self.Point2MM(playerPoint, walkerPoint, angle);
  if not Self.ScreenWalk then
    Exit(Minimap.Polygon.Expand(-1).Contains(mmPoint));

  h := Self.Height(playerPoint);
  diff := Self.Height(walkerPoint);
  b := Minimap.Vector2MSQuad(Vec3(mmPoint.X, mmPoint.Y, h), angle, [1,1], Vec3(0,0, -diff)).Bounds;

  if MainScreen.IsVisible(b.Center) then
    Result := not Target.HasColor($0, 0, 1, b.Expand(4, MainScreen.Bounds)); //Client doesn't always render everything when zoomed out
end;


procedure TRSWalker.DrawPath(img: TImage; index: Integer; playerPoint: TPoint);
var
  i: Integer;
  path: TPointArray;
begin
  path := Self._Path.ExtractDist(playerPoint, 0, 90);
  path := Self.Points2MM(playerPoint, path, Minimap.GetCompassAngle(False));
  path := Minimap.Filter(path);

  for i := 0 to High(path) do
  begin
    img.DrawColor := $FFFFFF;
    if (i < High(path)) and img.InImage(path[i+1].X, path[i+1].Y) then
      img.DrawLine(path[i], path[i+1]);

    if index = i then
    begin
      img.DrawColor := $FF1010;
      img.DrawBox(TBox.Create(path[i], 2, 2));
    end
    else
    begin
      img.DrawColor := $10FF10;
      img.DrawBox(TBox.Create(path[i], 2, 2));
    end;
  end;
end;

procedure TRSWalker.DebugPath(index: Integer; playerPoint: TPoint);
var
  img: TImage;
begin
  img := TImage.CreateFromTarget();
  Self.DrawPath(img, index, playerPoint);
  img.Show();
  img.Free();
end;

{%codetools on}
function TRSWalker._BuildPath(tpa: TPointArray): TPointArray;
var
  i, j: Integer;
  line: TPointArray;
begin
  for i := 1 to High(tpa) do
  begin
    line := TPointArray.CreateFromLine(tpa[i-1], tpa[i]);

    j := 0;
    while j < High(line) do
    begin
      Result += line[j];

      if (Self.ScreenWalk or Self.AdaptiveWalk) and InRange(Options.GetZoomLevel(), 70, 100) then
        Inc(j, Random(1, 4))
      else
        Inc(j, Random(3, 12));
    end;
  end;

  Result += tpa[High(tpa)];
end;

function TRSWalker._AdvancePath(out index: Integer; playerPoint: TPoint; angle: Double): Boolean;
var
  previous: Integer;
  nearest, furthest: Integer;
begin
  previous := index;

  //nearest := Self._Path.Find(Self._Path.Sorted(playerPoint)[0]);
  Self._Pathindex := nearest;

  while (nearest < High(Self._Path)) and (not Self.IsWalkable(Self._Path[nearest+1], playerPoint, angle)) do
    Inc(nearest);

  furthest := nearest;
  while (furthest < High(Self._Path)) and Self.IsWalkable(Self._Path[furthest+1], playerPoint, angle) do
    Inc(furthest);

  index := furthest;

  // do the result check before randomness to avoid false error
  Result := index > previous;

  // 15% chance of randomness else furthest
  if Random() < 0.15 then
    index := Random(nearest, furthest);
end;

procedure TRSWalker._WalkPathSetup(path: TPointArray);
var
  me: TPoint;
begin
  Self.Walking := True;
  me := Self.Position();

  Self._Path := Self._BuildPath([me] + path);

  if Self.AdaptiveWalk then
  begin
    Self.AdaptiveToggleDistances.X := WALKER_ADAPTIVE_SCREEN_TOGGLE_DISTANCES.X + Random(-6,6);
    Self.AdaptiveToggleDistances.Y := WALKER_ADAPTIVE_SCREEN_TOGGLE_DISTANCES.Y + Random(-16,16);
    Self.AdaptiveWalkCheck(me);
  end;
end;

function TRSWalker._WalkPathHelper(out index: Integer; out angle: Double; playerPoint: TPoint; fails: Integer; debug: Boolean): Integer;
begin
  if debug then
    Self.DebugPath(index, playerPoint);

  Result := fails;

  if Self._AdvancePath(index, playerPoint, angle) then Exit(0);

  //Likely haven't moved far enough to advance to next point
  if Inc(Result) < 5 then
  begin
    Sleep(300);
    Exit;
  end;

  //Screen walking struggles, so disable it
  if Self.AdaptiveWalk and Self.ScreenWalk then
  begin
    Self.ScreenWalk := False;
    Self._AdvancePath(index, playerPoint, angle);
  end
  else if (Result = 5) then
  begin
    Minimap.SetCompassAngle(RadToDeg(angle) + RandomLeft(30, 360) * Random(-1,1));
    angle := Minimap.GetCompassAngle(False);
  end;

  if Result mod 2 = 0 then Minimap.WaitFlag();
end;
{%codetools on}

(*
## TRSWalker.WalkPath
```pascal
function TRSWalker.WalkPath(Path: TPointArray; waitUntilDistance: Integer = 0): Boolean;
```
Walks a path of points taken from the loaded map. We advice that waitUntilDistance is not 0.

Parameters:
- Path
	Array of points taken from the loaded map to walk. Must be ordered from start to finish.
- waitUntilDistance
	Determines when the method returns once the final point has been clicked. Default value: 0.
	| *waitUntilDistance=0* waits until the player has reached the final point.
	| *waitUntilDistance=20* waits until the player is within 20 pixels of the final point.

Example:
```pascal
Walker.WalkPath([[100,100],[120,120],[140,140],[160,160],[180,180]]);
```
*)
function TRSWalker.WalkPath(path: TPointArray; waitUntilDistance: Integer = 0; debug: Boolean = False): Boolean;
var
  playerPoint: TPoint;
  index, fails: Integer;
  angle: Double;
begin
  Self._WalkPathSetup(path);

  angle := Minimap.GetCompassAngle(False);
  while Self.Walking and (fails < 10) do
  begin
    playerPoint := Self.Position();

    (*
    if Self._DoorHandler.FlagMoved then
    begin
      Self._DoorHandler.FlagMoved := False;
      //TODO
      //Exit(Self.WebGraph^.WalkableClusters.InSameTPA(playerPoint, RSTranslator.NormalizeDoor(Self._DoorHandler.Door.After)));
    end;
    *)

    fails := Self._WalkPathHelper(index, angle, playerPoint, fails, debug);
    if fails > 0 then Continue;

    if index = High(Self._Path) then
    begin
      if Self.WalkFinalStep(playerPoint, Self._Path[index], waitUntilDistance) then
        Exit(True);
      Continue;
    end;

    Self.WalkStep(playerPoint, Self._Path[index]);
  end;

  if fails = 10 then
    WriteLn GetDebugLn(Self.Name, 'Failed to advance path', EErrorLevel.WARN);
end;


procedure TRSWalker.SolveDoor(door: TRSDoor; compass: Single);
var
  quad: TQuad;
  middleOfDoorside, doorTile: TPoint;
  tpa: TPointArray;
begin
  WriteLn GetDebugLn('Walker', 'Solving door from far away');

  SleepUntil(not minimap.IsPlayerMoving(), 10, 7000);

  if Abs(DeltaAngle(door.GetDoorAngle,compass)) < 90 then
    doorTile := door.After
  else
    doorTile := door.Before;

  quad := Self.GetQuadMS(Self.Position(), doorTile);

  //move mouse to the average of the middle of the bottom edge and the center of the quad
  // recent addition, shift 3/5 of the way towards the bottom instead of in the middle
  // potential addition for more randomness: make tpa from line and grow by 1
  {$IFDEF DEBUG_WALKERV2}
  RSClient.Image.Clear(MainScreen.Bounds);
  RSClient.Image.DrawRect(quad, $FFFF00);
  {$ENDIF}

  tpa := TRSDoor.GetCorners(quad.Corners, door.GetDoorAngle(), compass);
  middleOfDoorside := [Round((tpa[0].X+tpa[1].X)/2), Round((tpa[0].Y+tpa[1].Y)/2)];

  Mouse.Move([Round((2*quad.Mean.X+3*middleOfDoorside.X)/5), Round((2*quad.Mean.Y+3*middleOfDoorside.Y)/5)]);

  Self._DoorHandler.Skipped := False; //I can't explain why but without this like, it always skips the door

  //Check Uptext and walk through
  if Mainscreen.AnyIsUpText(['Open', 'Squeeze']) then
  begin
    Target.MouseClick(EMouseButton.LEFT);
    Exit;
  end;

  if Mainscreen.IsUpText('Walk here') then
  begin
    Self._DoorHandler.Skipped := True;
    Target.MouseClick(EMouseButton.LEFT);
    Exit;
  end;

  if not ChooseOption.Select('Open', True, False) then
  begin
    ChooseOption.Select('Walk here');
    Self._DoorHandler.Skipped := True;
  end;
end;

function TRSWalker.WalkDoorway(path: TPointArray; waitUntilDistance: Integer = 0; debug: Boolean = False): Boolean;
var
  playerPoint: TPoint;
  pathToDoor: TPointArray;
  index, fails, doorIndex, postDoorIndex, i: Integer;
  quad: TQuad;
  compass, cAngle: Double;
begin
  doorIndex := -1;
  for i := 0 to High(path) do
    if RSTranslator.Normalize(path[i]) = Self._DoorHandler.Door.Before then
    begin
      doorIndex := i; //find the last time the door occurs in the path
      Break;
    end;

  if doorIndex = -1 then
    raise GetDebugLn('Walker', 'Couldn''t find a door on the path for TRSWalker.WalkDoorway() to handle!');

  pathToDoor := Copy(path, 0, doorIndex + 1); //you need this + 1 to get door.After node
  Self._WalkPathSetup(pathToDoor);

  while Self.Walking and (fails < 10) do
  begin
    {$IFDEF DEBUG_WALKERV2}
    Self.DebugLn('fails: ' + ToStr(fails));
    {$ENDIF}
    playerPoint := Self.Position();
    if Self.WebGraph^.WalkableClusters.InSameTPA(RSTranslator.NormalizeDoor(playerPoint), RSTranslator.NormalizeDoor(Self._DoorHandler.Door.After)) then
      Exit(True);

    if Self._DoorHandler.FlagMoved then
    begin
      Self._DoorHandler.FlagMoved := False;
      Exit(Self.WebGraph^.WalkableClusters.InSameTPA(RSTranslator.NormalizeDoor(playerPoint), RSTranslator.NormalizeDoor(Self._DoorHandler.Door.After)));
    end;

    compass := Minimap.GetCompassAngle(False);
    fails := Self._WalkPathHelper(index, compass, playerPoint, fails, debug);
    if fails > 0 then Continue;

    if not Self._DoorHandler.Handling then
    begin
      cAngle := RadToDeg(compass);
      quad := Self.GetQuadMS(playerPoint, Self._DoorHandler.Door.After, 0, [0,0], compass);

      if Mainscreen.IsVisible(quad.Mean) then
      begin
        if not Self._DoorHandler.SettingUp then
        begin
          compass := Self._DoorHandler.Door.GetVisibleAngle(Minimap.GetCompassAngle());
          Minimap.SetCompassAngleEx(compass, 15);

          Self._DoorHandler.SettingUp := True;

          compass := Minimap.GetCompassAngle(False);
          quad := Self.GetQuadMS(playerPoint, Self._DoorHandler.Door.After, 0, [0,0], compass);

          if not Mainscreen.IsVisible(quad.Mean) then
            Continue;
        end;

        SleepUntil(not Minimap.IsPlayerMoving(), 10, 5000);

        cAngle := Minimap.GetCompassAngle(True);
        quad := Self.GetQuadMS(playerPoint, Self._DoorHandler.Door.After);

        if Mainscreen.IsVisible(quad.Mean) then
        begin
          {$IFDEF DEBUG_WALKERV2}
          Self.DebugLn('Solving the door');
          {$ENDIF}

          Self.SolveDoor(Self._DoorHandler.Door, cAngle);
          playerPoint := Self.Position();

          //if you didnt skip the door you need to check if you are moving towards it
          //if you are not close to the door when you stop moving, it means the door was opened by someone else in the mean time
          //in this case you are not handling the door anymore so you Continue and it will try to handle again
          if not Self._DoorHandler.Skipped then
          begin
            Self._DoorHandler.Skipped := False;
            SleepUntil(Minimap.IsPlayerMoving(), 200, 1200);
            SleepUntil(not Minimap.IsPlayerMoving(), 50, 2000 + 600 * Round(playerPoint.DistanceTo(Self._DoorHandler.Door.Before) / 4)); //max duration it can take to get to a point with a 2 second buffer
            if Self.WebGraph^.WalkableClusters.InSameTPA(RSTranslator.NormalizeDoor(Self.Position), RSTranslator.NormalizeDoor(Self._DoorHandler.Door.After)) then Exit(True);
            if (Self._DoorHandler.Door.Before.DistanceTo(Self.Position()) > 3) then Continue;
          end;

          index := 0;

          if Length(Self._DoorHandler.DoorsOnPath) > 1 then
          begin
            postDoorIndex := -1;
            for i := 0 to High(path) do
              if RSTranslator.Normalize(path[i]) = Self._DoorHandler.DoorsOnPath[1].Before then
              begin
                postDoorIndex := i;
                Break;
              end;

            if postDoorIndex = -1 then
              raise GetDebugLn('Walker', 'Couldn''t find then next door on the path for TRSWalker.WalkDoorway to handle!');
          end
          else
            postDoorIndex := High(path);

          pathToDoor := Copy(path, doorIndex, postDoorIndex - doorIndex + 1);
          Self._WalkPathSetup(pathToDoor);
          Self._DoorHandler.Handling := True;
          Continue;
        end;
      end;
    end;

    if index = High(Self._Path) then
    begin
      if Self.WalkFinalStep(playerPoint, Self._Path[index], waitUntilDistance) then
        Exit(not Self._DoorHandler.Handling);
      Continue;
    end;

    Self.WalkStep(playerPoint, Self._Path[index]);
  end;

  if fails = 10 then
    WriteLn GetDebugLn('Walker', 'Failed to advance path', EErrorLevel.ERROR);
end;


(*
## TRSWalker.WalkBlind
```pascal
function TRSWalker.WalkBlind(Destination: TPoint; waitUntilDistance: Integer = 0): Boolean;
```
"Blindly" walks to a point taken from the loaded map.
A straight line is generated between the player's position and destination which is then walked.

Parameters:
- Destination
  Destination point taken from the loaded map.
- waitUntilDistance
	Determines when the method returns once the final point has been clicked. Default value: 0.
	| *waitUntilDistance=0* waits until the player has reached the final point.
	| *waitUntilDistance=20* waits until the player is within 20 pixels of the final point.

Example:
```pascal
Walker.WalkBlind([300, 300]);
```
*)
function TRSWalker.WalkBlind(Destination: TPoint; waitUntilDistance: Integer = 0): Boolean;
begin
  Result := Self.WalkPath([Destination], waitUntilDistance);
end;


(*
## TRSWalker.GetClosestPoint
```pascal
function TRSWalker.GetClosestPointEx(me: TPoint; destinations: TPointArray): TPoint;
function TRSWalker.GetClosestPoint(destinations: TPointArray): TPoint;
```
Method used to get the closest Point to the Player out of a TPA.
*)
function TRSWalker.GetClosestPointEx(me: TPoint; destinations: TPointArray; out path: TPointArray): TPoint; overload;
var
  shortPaths: T2DPointArray;
  shortest, dist: Integer;
  destination: TPoint;
begin
  me := Self.Position();
  shortest := $FFFFFF;

  for destination in destinations do
  begin
    try
      path := Self.WebGraph^.PathBetweenEx(me, destination, 0, 4);
    except
      Continue;
    end;

    if path = [] then Continue;

    dist := Floor(path.PolylineLength());
    if dist < shortest then
    begin
      shortPaths := [path];
      shortest := dist;
    end
    else if dist = shortest then
      shortPaths += path;

    path := [];
  end;

  if shortPaths = [] then
    Exit(destinations.NearestPoint(me));

  path := shortPaths.Random();
  Result := shortPaths.Random().Last;
end;

function TRSWalker.GetClosestPointEx(me: TPoint; destinations: TPointArray): TPoint; overload;
var
  tpa: TPointArray;
begin
  Result := Self.GetClosestPointEx(me, destinations, tpa);
end;

function TRSWalker.GetClosestPoint(destinations: TPointArray): TPoint;
begin
  Result := Self.GetClosestPointEx(Self.Position(), destinations);
end;


function TRSWalker._HardSolveDoor(door: TRSDoor): Boolean;
var
  middleBottom, me: TPoint;
  angle: Single;
  quad: TQuad;
  tpa: TPointArray;
begin
  angle := door.GetVisibleAngle(Minimap.GetCompassAngle() , 0 , False);
  Minimap.SetCompassAngleEx(angle, 15);
  SleepUntil(not minimap.IsPlayerMoving, 50,5000);

  me := Self.Position();
  quad := Self.GetQuadMS(me, door.After, 0, [0,0], Minimap.GetCompassAngle(False));
  if not Mainscreen.IsVisible(quad.Mean) then Exit(False);

  //move mouse slightly below the mean of the rectangle
  tpa := quad.Corners;
  tpa.SortByY(False);
  middleBottom := [(tpa[0].X + tpa[1].X) div 2, (tpa[0].Y + tpa[1].Y) div 2];

  with quad.Mean do
    Mouse.Move([(X + middleBottom.X) div 2, (Y + middleBottom.Y) div 2]);

  if Mainscreen.AnyIsUpText(['Open', 'Squeeze']) then
  begin
    Target.MouseClick(EMouseButton.LEFT);
    if not SleepUntil(not Mainscreen.AnyIsUpText(['Open', 'Close', 'Squeeze']), 100, 2000) then
      Exit;
  end;

  Self.WalkBlind(door.After, 0);
  Sleep(1000,2000, ERandomDir.LEFT);

  with Self.Position() do
    Result := door.After.DistanceTo([X, Y]) < me.DistanceTo([X, Y]);
end;


function TRSWalker.GetDoorsOnPath(path: TPointArray): TRSDoorArray;
var
  i: Integer;
  door: TRSDoor;
  n1, n2, tmp: TPoint;
begin
  for i := 0 to High(path) - 1 do
  begin
    n1 := RSTranslator.Normalize(path[i]);
    n2 := RSTranslator.Normalize(path[i+1]);

    for door in Self.WebGraph^.Doors do
    begin
      if (n1 = door.Before) and (n2 = door.After) then Result += door
      else if (n1 = door.After) and (n2 = door.Before) then
      begin
        tmp := door.Before;
        door.Before := door.After;
        door.After := tmp;
        Result += door;
      end;
    end;
  end;
end;


(*
## TRSWalker.WebWalk
```pascal
function TRSWalker.WebWalkEx(me: TPoint; destination: TPoint; waitUntilDistance: Integer = 0; pathRandomness: Double = 0): Boolean;
function TRSWalker.WebWalk(destination: TPoint; waitUntilDistance: Integer = 0; pathRandomness: Double = 0): Boolean;
function TRSWalker.WebWalk(destinations: TPointArray; waitUntilDistance: Integer = 0; pathRandomness: Double = 0): Boolean; overload;
```
Web walks to the destination point on the loaded map. Does **not** handle any obstacles.
*)
function TRSWalker.WebWalkEx(me: TPoint; destination: TPoint; waitUntilDistance: Integer = 0; pathRandomness: Double = 0; debug: Boolean = False): Boolean;
  function _GetPath(me: TPoint; safe: Boolean): TPointArray;
  var
    img: TImage;
    tmp: TWebGraph;
    closestMe, closestDest: TIntegerArray;
    i: Integer;
  begin
    try
      Result := Self.WebGraph^.PathBetweenEx(me, destination, pathRandomness, 4, safe);
    except
      if Assigned(Self.MapImage) and (Length(Self.WebGraph^.Nodes) > 0) then
      begin
        img := Self.MapImage.Copy();
        tmp := Self.WebGraph^;

        closestMe   := Self.WebGraph^.FindNearestNodes(me, 4);
        closestDest := Self.WebGraph^.FindNearestNodes(destination, 4);

        tmp.Nodes := Self.GetLocalEx(tmp.Nodes);
        me := Self.GetLocal(me);
        destination := Self.GetLocal(destination);

        tmp.Draw(img);

        for i := 0 to 3 do
        begin
          if i < Length(closestMe) then
          begin
            img.DrawColor := $FF00FF;
            img.DrawCircle(tmp.Nodes[closestMe[i]], 4);
          end;

          if i < Length(closestDest) then
          begin
            img.DrawColor := $FF0000;
            img.DrawCircle(tmp.Nodes[closestDest[i]], 4);
          end;
        end;

        img.DrawColor := $00FF00;
        if img.InImage(me.X, me.Y) then
          img.DrawCross(me, 4);

        if img.InImage(destination.X, destination.Y) then
          img.DrawCross(destination, 4);

        img.Show();
        img.Free();
      end;
      raise GetDebugLn(Self.Name, GetExceptionMessage());
    end;
  end;

var
  path: TPointArray;
  tries: Integer;
  doors: TRSDoorArray;
begin
  if not System.InRange(pathRandomness, 0, 1) then
    raise GetDebugLn('Walker' 'WebWalk `pathRandomness` must be between 0.0 an 1.0');

  if not Self._DoorHandler.Enabled then
  begin
    if me = destination then Exit(True);
    path := _GetPath(me, True);
    Exit(Self.WalkPath(path, waitUntilDistance, debug));
  end;

  for tries := 0 to 4 do
  begin
    path := _GetPath(Self.Position(), False);
    doors := Self.GetDoorsOnPath(path);

    Self._DoorHandler.SettingUp := False;
    Self._DoorHandler.Handling := False;

    if Length(doors) = 0 then Break;

    Self._DoorHandler.Door := doors[0];
    Self._DoorHandler.DoorsOnPath := doors;

    WriteLn GetDebugLn('Walker', 'Attempting to solve door, attempt ' + ToStr(tries + 1));

    if not Self.WalkDoorway(path, 0, debug) then
    begin
      Inc(tries);
    end
    else
    begin
      tries := 0;
      Continue;
    end;

    Self._DoorHandler.SettingUp := False;
    Self._DoorHandler.Handling := False;

    if tries <= 2 then Continue;
    WriteLn GetDebugLn('Walker', 'Hard solving door.', EErrorLevel.WARN);
    if Self.WalkStep(Self.Position(), Self._DoorHandler.Door.Before) then
      if Self._HardSolveDoor(Self._DoorHandler.Door) then tries := 0;
  end;

  if Self.Position() = destination then Exit(True);
  path := _GetPath(Self.Position(), True);
  Result := Self.WalkPath(path, waitUntilDistance, debug);
end;

function TRSWalker.WebWalk(destination: TPoint; waitUntilDistance: Integer = 0; pathRandomness: Double = 0; debug: Boolean = False): Boolean;
begin
  Result := Self.WebWalkEx(Self.Position(), destination, waitUntilDistance, pathRandomness, debug);
end;

function TRSWalker.WebWalk(destinations: TPointArray; waitUntilDistance: Integer = 0; pathRandomness: Double = 0; debug: Boolean = False): Boolean; overload;
var
  me, destination: TPoint;
begin
  me := Self.Position();
  destination := Self.GetClosestPointEx(me, destinations);
  Result := Self.WebWalkEx(me, destination, waitUntilDistance, pathRandomness, debug);
end;

(*
## TRSWalker.MakePointVisible
```pascal
function TRSWalker.MakePointVisible(p: TPoint): Boolean;
function TRSWalker.MakePointVisible(tpa: TPointArray): Boolean; overload;
```
Wrapper function used to attempt to make a Point visible on the MainScreen.
*)
function TRSWalker.MakePointVisible(pt: TPoint): Boolean;
begin
  Result := Minimap.MakePointVisible(Self.Point2MM(Self.Position(), pt, Minimap.GetCompassAngle(False)));
end;

var
(*
## Walker variable
Global {ref}`TRSWalker` variable.
*)
  Walker: TRSWalker;
