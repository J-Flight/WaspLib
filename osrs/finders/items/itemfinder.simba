(*
# ItemFinder
Methods to find and compare item images
*)

{$DEFINE WL_ITEMFINDER_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
  TRSItemFinder = record
    ItemImages: TStringMap<TImage>;
    Filters: array of record
      Name: String;
      Filter: TImageCompareFilter;
    end;
    Version: String;
    Similarity: Single;
    ImageCompare: TImageCompareUtils;
    Database: TDatabase;
    CacheDir: String;
    const ZIP: String = {$MACRO DIR} + 'images.zip';
  end;

function TRSItemFinder.Align(image, template: TImage): Boolean;
var
  borderA, borderB: TPointArray;
  bounds: TBox;
  align, p: TPoint;
begin
  borderA  := image.FindColor(RSColors.ITEM_BORDER, 0);
  borderB := template.FindColor(RSColors.ITEM_BORDER, 0) + template.FindColor(RSColors.ITEM_BORDER_WHITE, 0);

  align := borderA[High(borderA)] - borderB[High(borderB)];

  borderB := borderB.Offset(align);
  for p in borderB do
  begin
    if p.Y <= 8 then Continue;//stack number... Don't compare.

    //borders don't match.
    if not image.InImage(p.X, p.Y) then Exit;
    if image.Pixel[p.X, p.Y] <> RSColors.ITEM_BORDER then Exit;
  end;

  bounds := borderA.Bounds();
  image.Crop(bounds);
  template.Crop(bounds.Offset([-align.X, -align.Y]));
  Result := True;
end;

procedure TRSItemFinder.Clean(image, template: TImage);
var
  color: TColor;
  tpa: TPointArray;
begin
  image.DrawColor := $0;
  template.DrawColor := $0;

  template.DrawTPA(image.FindColor($0, 0));

  tpa := image.FindColor(RSColors.ITEM_SHADOW, 0);
  for color in RSColors.STACK_COLORS do
    tpa += template.FindColor(color, 0);

  tpa += template.FindColor(RSColors.ITEM_BORDER, 0);
  image.DrawTPA(tpa);
  template.DrawTPA(tpa);
end;

procedure TRSItemFinder.Setup();
var
  path, tmp: String;
begin
  Self.Version := HashFile(EHashAlgo.MD5, Self.ZIP);
  SetLength(Self.Version, 6);
  Self.Database.Setup('ItemFinder', ['id', 'item', 'hash'], {$MACRO DIR} + 'data' + PATH_SEP, Self.Version);

  Self.CacheDir := WLEnv.CacheDir + 'itemfinder' + PATH_SEP;

  //Delete old cache files if they exist
  for path in DirList(Self.CacheDir) do
  begin
    tmp := Copy(path, 1, Length(path)-Length(Self.Version));
    if tmp = Self.Version then Continue;
    DirDelete(path, False);
  end;

  Self.CacheDir += Self.Version + PATH_SEP;

  if not DirCreate(Self.CacheDir) then
    raise GetDebugLn('ItemFinder', 'Failed to create cache directory: ' + Self.CacheDir);

  //only set similarity if the user didn't set it already
  if Self.Similarity = 0 then
    Self.Similarity := 0.999;

  Self.ItemImages.CaseSens := False;

  Self.ImageCompare.Align := @Self.Align;
  Self.ImageCompare.Clean := @Self.Clean;
end;


function TRSItemFinder.GetIDs(item: String): TStringArray;
begin
  Result := Self.Database.GetAll(item, 'item', 'id');
end;

procedure TRSItemFinder.MapItem(item, id: String);
begin
  Self.Database.AddRow([id, item, '']);
end;



function TRSItemFinder.GetFilter(item: String): TImageCompareFilter;
var
  i: Integer;
begin
  for i := 0 to High(Self.Filters) do
    if Self.Filters[i].Name = item then
      Exit(@Self.Filters[i].Filter);
end;

function TRSItemFinder.GetImage(id: String): TImage;
var
  path: String;
begin
  if not Self.ItemImages.Exists(id) or
    (Self.ItemImages.Value[id] = nil) then
  begin
    path := Self.CacheDir + id + '.png';

    if not FileExists(path) then
      ZipExtractEntry(Self.ZIP, id + '.png', Self.CacheDir);

    Self.ItemImages.Value[id] := TImage.Create(path);
    Self.ItemImages.Value[id].FreeOnTerminate := True;
  end;

  Result := Self.ItemImages.Value[id];
end;

function TRSItemFinder.GetImages(item: String): TImageArray;
var
  ids: TStringArray;
  id: String;
begin
  if item.IsNumeric then ids := [item]
  else ids := Self.GetIDs(item);

  for id in ids do
    Result += Self.GetImage(id);
end;


function TRSItemFinder.FindAll(items: TRSItemArray; boxes: TBoxArray; maxToFind: Integer = 0): TImageMatchArray;
var
  item: TRSItem;
  img: TImage;
  i: Integer;
  skip: TBooleanArray;
  match: Single;
begin
  SetLength(skip, Length(boxes));

  for item in items do
  begin
    item := LowerCase(item);
    Self.ImageCompare.Filter := @Self.GetFilter(item);

    for img in Self.GetImages(item) do
      for i := 0 to High(boxes) do
      begin
        if skip[i] then Continue;
        if not RSColors.HasItem(boxes[i]) then
        begin
          skip[i] := True;
          Continue;
        end;

        match := Self.Similarity;
        if Self.ImageCompare.Compare(img, boxes[i], match) then
        begin
          Result += [i, boxes[i], match];
          if (maxToFind > 0) and (Length(Result) >= maxToFind) then Exit;
          skip[i] := True;
        end;
      end;
  end;
end;

function TRSItemFinder.FindAll(items: TRSItemArray; boxes: TBoxArray; out matches: TImageMatchArray): Boolean; overload;
var
  item: TRSItem;
  results: TImageMatchArray;
  i: Integer;
  img: TImage;
  match: Single;
  skip: TBooleanArray;
begin
  SetLength(skip, Length(boxes));

  for item in items do
  begin
    item := LowerCase(item);
    Self.ImageCompare.Filter := @Self.GetFilter(item);

    for img in Self.GetImages(item) do
      for i := 0 to High(boxes) do
      begin
        if skip[i] then Continue;
        if not RSColors.HasItem(boxes[i]) then
        begin
          skip[i] := True;
          Continue;
        end;

        match := Self.Similarity;
        if Self.ImageCompare.Compare(img, boxes[i], match) then
        begin
          results += [i, boxes[i], match];
          skip[i] := True;
        end;
      end;

    if results = [] then Exit;

    matches += results;
    results := [];
  end;

  Result := True;
end;

function TRSItemFinder.Find(items: TRSItemArray; boxes: TBoxArray; out match: TImageMatch): Boolean;
var
  item: TRSItem;
  img: TImage;
  i: Integer;
  similarity: Single;
  skip: TBooleanArray;
begin
  SetLength(skip, Length(boxes));

  for item in items do
  begin
    item := LowerCase(item);
    Self.ImageCompare.Filter := @Self.GetFilter(item);

    for img in Self.GetImages(item) do
    begin
      for i := 0 to High(boxes) do
      begin
        if skip[i] then Continue;
        if not RSColors.HasItem(boxes[i]) then
        begin
          skip[i] := True;
          Continue;
        end;

        similarity := Self.Similarity;
        if Self.ImageCompare.Compare(img, boxes[i], similarity) then
        begin
          match := [i, boxes[i], similarity];
          Exit(True);
        end;
      end;
    end;
  end;
end;


procedure TRSItemFinder.Show(item: TRSItem);
var
  display, img: TImage;
  i, h, w, x: Integer;
begin
  try
    display := TImage.Create();

    for img in Self.GetImages(item) do
    begin
      if img.Height > h then h:= img.Height;
      w := img.Width;
      x := display.Width;
      display.SetSize(x+w, h);
      display.DrawImage(img,[x,0]);
    end;

    display.Show();
  finally
    display.Free();
  end;
end;


var
  ItemFinder: TRSItemFinder;
