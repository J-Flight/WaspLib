(*
# ItemFinder
Methods to find and compare item images
*)

{$DEFINE SRLT_ITEMFINDER_INCLUDED}
{$IFNDEF SRLT_OSRS}
  {$I SRLT/osrs.simba}
{$ENDIF}

type
  TItemFinder = record
    ItemImages: TStringMap<TImage>;
    Filters: array of record
      Name: String;
      Filter: TImageCompareFilter;
    end;
    Version: String;
    Similarity: Single;
    ImageCompare: TImageCompareUtils;
    Database: TDatabase;
    CacheDir: String;
    const ZIP: String = {$MACRO DIR} + 'images.zip';
  end;


procedure TItemFinder.Align(image, template: TImage);
var
  borderA, borderB: TPointArray;
begin
  borderA  := image.FindColor(RSColors.ITEM_BORDER, 0);
  borderB := template.FindColor(RSColors.ITEM_BORDER, 0) + template.FindColor(RSColors.ITEM_BORDER_WHITE, 0);

  image.Crop(borderA.Bounds());
  template.Crop(borderB.Bounds());
end;

procedure TItemFinder.Clean(image, template: TImage);
var
  color: TColor;
  tpa: TPointArray;
begin
  image.DrawColor := $0;
  template.DrawColor := $0;

  template.DrawTPA(image.FindColor($0, 0));

  for color in RSColors.STACK_COLORS do
  begin
    tpa := template.FindColor(color, 0);
    if tpa = [] then Continue;
    image.DrawTPA(tpa);
    template.DrawTPA(tpa);
  end;
end;

procedure TItemFinder.Setup();
var
  dir, tmp: String;
begin
  Self.Version := HashFile(EHashAlgo.MD5, Self.ZIP);
  SetLength(Self.Version, 6);
  Self.Database.Setup('ItemFinder', ['id', 'item', 'hash'], {$MACRO DIR} + 'data' + PATH_SEP, Self.Version);

  Self.CacheDir := SRLTEnv.CacheDir + 'ItemFinder' + PATH_SEP;

  //Delete old cache files if they exist
  for dir in DirList(Self.CacheDir) do
  begin
    tmp := Copy(dir, 1, Length(dir)-Length(Self.Version));
    if tmp = Self.Version then Continue;
    DirDelete(dir, False);
  end;

  Self.CacheDir += Self.Version + PATH_SEP;

  if not DirCreate(Self.CacheDir) then
    raise GetDebugLn('ItemFinder', 'Failed to create cache directory: ' + Self.CacheDir);

  //only set similarity if the user didn't set it already
  if Self.Similarity = 0 then
    Self.Similarity := 0.999;

  Self.ItemImages.CaseSens := False;

  Self.ImageCompare.Align := @Self.Align;
  Self.ImageCompare.Clean := @Self.Clean;
end;


function TItemFinder.GetFilter(item: String): TImageCompareFilter;
var
  i: Integer;
begin
  for i := 0 to High(Self.Filters) do
    if Self.Filters[i].Name = item then
      Exit(@Self.Filters[i].Filter);
end;

function TItemFinder.GetImage(id: String): TImage;
var
  path: String;
begin
  if not Self.ItemImages.Exists(id) then
    Self.ItemImages.Value[id] := nil;

  if Self.ItemImages.Value[id] = nil then
  begin
    path := Self.CacheDir + id + '.png';
    if FileExists(path) then
      Self.ItemImages.Value[id].Load(path)
    else
    begin
      Self.ItemImages.Value[id].CreateFromZip(Self.ZIP, id + '.png');
      Self.ItemImages.Value[id].Save(path);
    end;
    Self.ItemImages.Value[id].FreeOnTerminate := True;
  end;

  Result := Self.ItemImages.Value[id];
end;

function TItemFinder.GetImages(item: String): TImageArray;
var
  ids: TStringArray;
  id: String;
begin
  if item.IsNumeric then ids := [item]
  else ids := Self.Database.GetAll(item, 'item', 'id');

  for id in ids do
    Result += Self.GetImage(id);
end;


function TItemFinder.FindAll(items: TRSItemArray; boxes: TBoxArray; maxToFind: Integer = 0): TImageMatchArray;
var
  item: TRSItem;
  slots: TBoxArray;
  results: TImageMatchArray;
  i: Integer;
begin
  slots := Copy(boxes);
  for item in items do
  begin
     item := LowerCase(item);
     Self.ImageCompare.Filter := @Self.GetFilter(item);
     results := Self.ImageCompare.MatchAll(Self.GetImages(item), slots, Self.Similarity);
     Result += results;
     if Length(Result) >= maxToFind then Exit;

     for i := 0 to High(results) do
       slots.Remove(results[i].Box);
  end;
end;

function TItemFinder.FindAll(items: TRSItemArray; boxes: TBoxArray; out matches: TImageMatchArray): Boolean; overload;
var
  item: TRSItem;
  slots: TBoxArray;
  results: TImageMatchArray;
  i: Integer;
begin
  slots := Copy(boxes);
  for item in items do
  begin
    if slots = [] then Exit;
    item := LowerCase(item);
    Self.ImageCompare.Filter := @Self.GetFilter(item);
    results := Self.ImageCompare.MatchAll(Self.GetImages(item), slots, Self.Similarity);
    if results = [] then Exit;

    matches += results;
    for i := 0 to High(results) do
      slots.Remove(results[i].Box);
  end;
  Result := True;
end;

function TItemFinder.Find(items: TRSItemArray; boxes: TBoxArray; out match: TImageMatch): Boolean;
var
  item: TRSItem;
begin
  for item in items do
  begin
     item := LowerCase(item);
     Self.ImageCompare.Filter := @Self.GetFilter(item);
     match := Self.ImageCompare.MatchAny(Self.GetImages(item), boxes, Self.Similarity);
     if match.Index > -1 then Exit(True);
  end;
end;


var
  ItemFinder: TItemFinder;
