(*
# ItemFinder
Methods to find and compare item images
*)

{$DEFINE SRLT_ITEMFINDER_INCLUDED}
{$IFNDEF SRLT_OSRS}
  {$I SRLT/osrs.simba}
{$ENDIF}

type
  TItemFinder = record
    ItemImages: TStringMap<TImage>;
    Filters: array of record
      Name: String;
      Filter: TImageCompareFilter;
    end;
    Version: String;
    Similarity: Single;
    ImageCompare: TImageCompareUtils;
    Database: TDatabase;
    CacheDir: String;
    const ZIP: String = {$MACRO DIR} + 'images.zip';
  end;


procedure TItemFinder.Align(image, template: TImage);
var
  borderA, borderB: TPointArray;
begin
  borderA  := image.FindColor(RSColors.ITEM_BORDER, 0);
  borderB := template.FindColor(RSColors.ITEM_BORDER, 0) + template.FindColor(RSColors.ITEM_BORDER_WHITE, 0);

  image.Crop(borderA.Bounds());
  template.Crop(borderB.Bounds());
end;

procedure TItemFinder.Clean(image, template: TImage);
var
  color: TColor;
  tpa: TPointArray;
begin
  image.DrawColor := $0;
  template.DrawColor := $0;

  template.DrawTPA(image.FindColor($0, 0));

  tpa := image.FindColor(RSColors.ITEM_SHADOW, 0);
  for color in RSColors.STACK_COLORS do
    tpa += template.FindColor(color, 0);

  image.DrawTPA(tpa);
  template.DrawTPA(tpa);
end;

procedure TItemFinder.Setup();
var
  dir, tmp: String;
begin
  Self.Version := HashFile(EHashAlgo.MD5, Self.ZIP);
  SetLength(Self.Version, 6);
  Self.Database.Setup('ItemFinder', ['id', 'item', 'hash'], {$MACRO DIR} + 'data' + PATH_SEP, Self.Version);

  Self.CacheDir := SRLTEnv.CacheDir + 'ItemFinder' + PATH_SEP;

  //Delete old cache files if they exist
  for dir in DirList(Self.CacheDir) do
  begin
    tmp := Copy(dir, 1, Length(dir)-Length(Self.Version));
    if tmp = Self.Version then Continue;
    DirDelete(dir, False);
  end;

  Self.CacheDir += Self.Version + PATH_SEP;

  if not DirCreate(Self.CacheDir) then
    raise GetDebugLn('ItemFinder', 'Failed to create cache directory: ' + Self.CacheDir);

  //only set similarity if the user didn't set it already
  if Self.Similarity = 0 then
    Self.Similarity := 0.999;

  Self.ItemImages.CaseSens := False;

  Self.ImageCompare.Align := @Self.Align;
  Self.ImageCompare.Clean := @Self.Clean;
end;


function TItemFinder.GetFilter(item: String): TImageCompareFilter;
var
  i: Integer;
begin
  for i := 0 to High(Self.Filters) do
    if Self.Filters[i].Name = item then
      Exit(@Self.Filters[i].Filter);
end;

function TItemFinder.GetImage(id: String): TImage;
var
  path: String;
begin
  if not Self.ItemImages.Exists(id) or
    (Self.ItemImages.Value[id] = nil) then
  begin
    path := Self.CacheDir + id + '.png';

    if not FileExists(path) then
      ZipExtractEntry(Self.ZIP, id + '.png', Self.CacheDir);

    Self.ItemImages.Value[id] := TImage.Create(path);
    Self.ItemImages.Value[id].FreeOnTerminate := True;
  end;

  Result := Self.ItemImages.Value[id];
end;

function TItemFinder.GetImages(item: String): TImageArray;
var
  ids: TStringArray;
  id: String;
begin
  if item.IsNumeric then
    ids := [item]
  else
    ids := Self.Database.GetAll(item, 'item', 'id');

  for id in ids do
    Result += Self.GetImage(id);
end;


function TItemFinder.FindAll(items: TRSItemArray; boxes: TBoxArray; maxToFind: Integer = 0): TImageMatchArray;
var
  item: TRSItem;
  img: TImage;
  i: Integer;
  skip: TBooleanArray;
  match: Single;
begin
  SetLength(skip, Length(boxes));

  for item in items do
  begin
    item := LowerCase(item);
    Self.ImageCompare.Filter := @Self.GetFilter(item);

    for img in Self.GetImages(item) do
      for i := 0 to High(boxes) do
      begin
        if skip[i] then Continue;
        if not RSColors.HasItem(boxes[i]) then
        begin
          skip[i] := True;
          Continue;
        end;

        match := Self.Similarity;
        if Self.ImageCompare.Compare(img, boxes[i], match) then
        begin
          Result += [i, boxes[i], match];
          if (maxToFind > 0) and (Length(Result) >= maxToFind) then Exit;
          skip[i] := True;
        end;
      end;
  end;
end;

function TItemFinder.FindAll(items: TRSItemArray; boxes: TBoxArray; out matches: TImageMatchArray): Boolean; overload;
var
  item: TRSItem;
  results: TImageMatchArray;
  i: Integer;
  img: TImage;
  match: Single;
  skip: TBooleanArray;
begin
  SetLength(skip, Length(boxes));

  for item in items do
  begin
    item := LowerCase(item);
    Self.ImageCompare.Filter := @Self.GetFilter(item);

    for img in Self.GetImages(item) do
      for i := 0 to High(boxes) do
      begin
        if skip[i] then Continue;
        if not RSColors.HasItem(boxes[i]) then
        begin
          skip[i] := True;
          Continue;
        end;

        match := Self.Similarity;
        if Self.ImageCompare.Compare(img, boxes[i], match) then
        begin
          results += [i, boxes[i], match];
          skip[i] := True;
        end;
      end;

    if results = [] then Exit;

    matches += results;
    results := [];
  end;

  Result := True;
end;

function TItemFinder.Find(items: TRSItemArray; boxes: TBoxArray; out match: TImageMatch): Boolean;
var
  item: TRSItem;
  img: TImage;
  i: Integer;
  similarity: Single;
  skip: TBooleanArray;
begin
  SetLength(skip, Length(boxes));

  for item in items do
  begin
    item := LowerCase(item);
    Self.ImageCompare.Filter := @Self.GetFilter(item);

    for img in Self.GetImages(item) do
    begin
      for i := 0 to High(boxes) do
      begin
        if skip[i] then Continue;
        if not RSColors.HasItem(boxes[i]) then
        begin
          skip[i] := True;
          Continue;
        end;

        similarity := Self.Similarity;
        if Self.ImageCompare.Compare(img, boxes[i], similarity) then
        begin
          match := [i, boxes[i], similarity];
          Exit(True);
        end;
      end;
    end;
  end;
end;

var
  ItemFinder: TItemFinder;

begin
  ItemFinder.Setup();
end;
