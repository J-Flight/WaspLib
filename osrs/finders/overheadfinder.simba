
{$DEFINE WL_OVERHEADFINDER_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}


type
  ERSOverhead = (
    MAGIC, RANGED, MELEE, RETRIBUTION, REDEMPTION, SMITE,
    MAGIC_AND_RANGED, MAGIC_AND_MELEE, RANGED_AND_MELEE, ALL,
    DAMPEN_MELEE
  );


  TRSOverhead = record
    Position: TPoint;
    Overhead: ERSOverhead;
  end;


  TRSOverheadArray = array of TRSOverhead;


  TRSOverheadFinder = record
    Images: array[ERSOverhead] of TImage;
    Version, CacheDir: String;
    Similarity: Single;
    const BACKGROUND_COLOR: TColorTolerance = [$74B0C7, 2.844, EColorSpace.RGB, [0.681, 1.299, 1.021]];
  end;


procedure TRSOverheadFinder.Setup();
var
  path, tmp: String;
begin
  Self.Version := WLAssets.OverheadFinder.Hash;
  Self.CacheDir := WLEnv.CacheDir + 'overheadfinder' + PATH_SEP;

  //Delete old cache files if they exist
  for path in DirList(Self.CacheDir) do
  begin
    tmp := Copy(path, Length(path) - Length(Self.Version) + 1, Length(path));
    if tmp <> Self.Version then
      DirDelete(path, False);
  end;

  Self.CacheDir += Self.Version + PATH_SEP;

  if not DirCreate(Self.CacheDir) then
    raise GetDebugLn('OverheadFinder', 'Failed to create cache directory: ' + Self.CacheDir);

  //only set similarity if the user didn't set it already
  if Self.Similarity = 0 then
    Self.Similarity := 0.90;
end;


function TRSOverheadFinder.GetImage(overhead: ERSOverhead): TImage;
var
  name, path: String;
begin
  if Self.Images[overhead] <> nil then
    Exit(Self.Images[overhead]);

  name := ToStr(overhead).ToLower().After('.') + '.png';
  path := Self.CacheDir + name;

  if not (FileExists(path) or ZipExtractEntry(WLAssets.OverheadFinder.Path, name, Self.CacheDir)) then
    raise GetDebugLn('OverheadFinder', Format('Failed to unzip overhead image %s', [name]));

  Result := Self.Images[overhead] := new TImage(path);
end;


function TRSOverheadFinder.Find(overheads: set of ERSOverhead; maxToFind: Integer = 5): TRSOverheadArray;
var
  background: TPointArray;
  overhead: ERSOverhead;
  bounds: TBox;
  searchingBounds: TBoxArray;
  overheadImage: TImage;
  matrix: TSingleMatrix;
begin
  background := Target.FindColor(TRSOverheadFinder.BACKGROUND_COLOR, MainScreen.Bounds);
  if background.Length = 0 then
    Exit;

  searchingBounds := background.Cluster(8).BoundsArray();

  for overhead in overheads do
  begin
    overheadImage := Self.GetImage(overhead);
    for bounds in searchingBounds do
    begin
      if (bounds.Width < overheadImage.Width) or (bounds.Height < overheadImage.Height) then
        Continue;

      matrix := MatchTemplate(Target.GetImage(bounds), overheadImage, ETMFormula.TM_CCOEFF_NORMED);

      with matrix.ArgMax do
      begin
        if matrix[Y,X] < Self.Similarity then
          Break;

        Result += [Point(X + 6,Y + 7).Offset(bounds.TopLeft).Offset(MainScreen.Bounds.TopLeft), overhead];
        if Result.Length = maxToFind then
          Exit;
      end;
    end;
  end;
end;


var
  OverheadFinder: TRSOverheadFinder;
