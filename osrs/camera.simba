(*
# RSCamera
*)
{$DEFINE WL_CAMERA_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
(*
## TRSCamera
Record responsible of handling projection, similar to {ref}`MM2MS`.
*)
  TRSCamera = record
    RenderDistance,
    X, Y, Z, Pitch, Yaw, Zoom: Integer;
    Player, Center, Offset: TPoint;

    HorizontalXs, HorizontalYs, VerticalXs, VerticalYs: TIntegerArray;
    Heights: TIntegerMatrix;

    Sines, Cosines: array [0..2047] of Int32;
    const MIN_ZOOM: Integer = 181;
    const MIN_PITCH: Integer = 128;
    const MAX_PITCH: Integer = 383;
    const SCENE_START: Integer = -((184 - 104) div 2) shl 7;
    const SCENE_END: Integer = (104 + ((184 - 104) div 2)) shl 7;
  end;

procedure TRSCamera.Setup();
var
  i: Integer;
begin
  Self.RenderDistance := 21;
  Self.Pitch := 383;
  Self.Zoom := 181;

  for i := 0 to 2047 do
  begin
    Self.Sines[i]   := Round(65536*Sin(i*PI/1024));
    Self.Cosines[i] := Round(65536*Cos(i*PI/1024));
  end;

  if RSClient.Mode = ERSMode.FIXED then
    Self.Offset := [4,4];

  Self.Offset.X += MainScreen.Bounds.Width div 2;
  Self.Offset.Y += MainScreen.Bounds.Height div 2;

  i := (Self.RenderDistance * 2 + 1) * Self.RenderDistance * 2 * 2;

  SetLength(Self.HorizontalXs, i);
  SetLength(Self.HorizontalYs, i);
  SetLength(Self.VerticalXs, i);
  SetLength(Self.VerticalYs, i);

  SetLength(Self.Heights, 184, 184);

  Self.X := 0;
  Self.Y := 0;
  Self.Center.X := Self.X;
  Self.Center.Y := Self.Y+674;

  Self.Player.X := Self.X;
  Self.Player.Y := Round(Self.Center.Y + Sin(3*HALF_PI) * (Self.X - Self.Center.X) + Cos(3*HALF_PI) * (Self.Y - Self.Center.Y));
end;

procedure TRSCamera.SetPitch(value: Integer);
const
  PITCH_DIFF: Integer := Self.MAX_PITCH - Self.MIN_PITCH;
begin
  Self.Pitch := value;
  Self.Y := 5150 - Round(235 * (Self.MAX_PITCH - value) / PITCH_DIFF);
end;

procedure TRSCamera.SetupGrid(zoom: Integer; rads: Double);
const
  PITCH_DIFF: Integer := Self.MAX_PITCH - Self.MIN_PITCH;
var
  x, y, xi, yi: Int32;
  pt, tile: TPoint;
begin
  Self.Z := -1650 + Round(1237 * (Self.MAX_PITCH - Self.Pitch) / PITCH_DIFF - (zoom/100) * 75);
  Self.Yaw := Trunc((rads / TAU) * 2047);
  Self.Zoom := Self.MIN_ZOOM + Round(ZOOM2RSZOOM[zoom] * 1267);

  for x := -Self.RenderDistance to Self.RenderDistance do
  begin
    pt.X := Self.Player.X + x * 128;
    tile.X := pt.X div 128;

    for y := -Self.RenderDistance+1 to Self.RenderDistance do
    begin
      pt.Y := Self.Player.Y + y * 128;
      tile.Y := pt.Y div 128;

      Self.HorizontalXs[xi]   := pt.X - 64;
      Self.HorizontalXs[xi+1] := pt.X + 63;
      Self.HorizontalYs[yi]   := pt.Y - 64;
      Self.HorizontalYs[yi+1] := pt.Y - 64;

      xi += 2;
      yi += 2;
    end;
  end;

  xi := 0;
  yi := 0;

  for y := -Self.RenderDistance to Self.RenderDistance do
  begin
    pt.Y := Self.Player.Y + y * 128;
    tile.Y := pt.Y div  128;

    for x := -Self.RenderDistance+1 to Self.RenderDistance do
    begin
      pt.X := Self.Player.X + x * 128;
      tile.X := pt.X div 128;

      Self.VerticalXs[xi]   := pt.X - 64;
      Self.VerticalXs[xi+1] := pt.X - 64;
      Self.VerticalYs[yi]   := pt.Y - 64;
      Self.VerticalYs[yi+1] := pt.Y + 63;

      xi += 2;
      yi += 2;
    end;
  end;
end;

function TRSCamera.GetHeights(xs, ys: TIntegerArray): TIntegerArray;
var
  local, scene: TPoint;
  i, x, y, nHeight, sHeight: Int32;
begin
  SetLength(Result, Length(xs));

  for i := 0 to High(xs) do
  begin
    local.X := xs[I];
    local.Y := ys[I];

    scene.X := Sar(local.X, 7) + 40;
    scene.Y := Sar(local.Y, 7) + 40;

    if not InRange(scene.X, 0, 183) or not InRange(scene.Y, 0, 183) then
      Continue;

    x := local.X and 127;
    y := local.Y and 127;

    nHeight := Sar(x * Self.Heights[scene.X+1, scene.Y] + (128 - x) * Self.Heights[scene.X, scene.Y], 7);
    sHeight := Sar((128 - x) * Self.Heights[scene.X, scene.Y+1] + x * Self.Heights[scene.X+1, scene.Y+1], 7);

    Result[i] := Sar((128 - y) * nHeight + y * sHeight, 7);
  end;
end;


function TRSCamera.GetLinePoints(xs, ys: TIntegerArray; rads: Double): TPointArray;
var
  zs: TIntegerArray;
  i, x, y, z, pitchSin, pitchCos, yawSin, yawCos,
  x1, y1, y2, z1: Int32;
  calc: Double;
  camX, camY, camZ: Int32;
begin
  zs := Self.GetHeights(xs, ys);
  SetLength(Result, Length(xs));

  camX := Round(Self.Center.X + Cos(rads) * (Self.X - Self.Center.X) - Sin(rads) * (Self.Y - Self.Center.Y));
  camY := Round(Self.Center.Y + Sin(rads) * (Self.X - Self.Center.X) + Cos(rads) * (Self.Y - Self.Center.Y));
  camZ := Self.Z;

  pitchSin := Self.Sines[Self.Pitch];
  pitchCos := Self.Cosines[Self.Pitch];
  yawSin := Self.Sines[Self.Yaw];
  yawCos := Self.Cosines[Self.Yaw];

  for i := 0 to High(xs) do
  begin
    x := xs[i];
    y := ys[i];
    z := zs[i];

    if InRange(x, Self.SCENE_START, Self.SCENE_END) and InRange(y, Self.SCENE_START, Self.SCENE_END) then
    begin
      x -= camX;
      y -= camY;
      z -= camZ;

      y1 := Sar(y * yawCos - x * yawSin, 16);
      z1 := Sar(y1 * pitchCos + z * pitchSin, 16);

      if (z1 < 50) then Continue;

      x1 := Sar(x * yawCos + y * yawSin, 16);
      y2 := Sar(z * pitchCos - y1 * pitchSin, 16);

      calc := Self.Zoom / z1;
      Result[i].X := Round(Self.Offset.X + x1 * calc);
      Result[i].Y := Round(Self.Offset.Y + y2 * calc);
    end;
  end;
end;

function TRSCamera.GetPoints(zoom: Integer; rads: Double): TPointArray;
var
  hPts, vPts: TPointArray;
  i: Integer;
begin
  Self.SetupGrid(zoom, rads);
  hPts := Self.GetLinePoints(Self.HorizontalXs, Self.HorizontalYs, rads);
  vPts := Self.GetLinePoints(Self.VerticalXs, Self.VerticalYs, rads);

  for i := 0 to High(hPts) with 2 do
  begin
    Result += TPointArray.CreateFromLine(hPts[i], hPts[i+1]);
    Result += TPointArray.CreateFromLine(vPts[i], vPts[i+1]);
  end;
end;

var
(*
## RSCamera variable
Global {ref}`TRSCamera` variable.
*)
  RSCamera: TRSCamera;
