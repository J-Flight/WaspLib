(*
# POHMap
The POH Map is what's responsible for mapping a user's POH.
*)

{$DEFINE WL_POHMAP_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
(*
## ERSHouseRoom
```pascal
ERSHouseRoom = enum(UNKNOWN, GARDEN..WORKSHOP);
```
Enum used to represent the POH rooms.
*)
  ERSHouseRoom = enum(
    UNKNOWN, GARDEN, SUPERIOR_GARDEN, MENAGERIE_OPEN, MENAGERIE_CLOSED,
    STUDY_PARLOUR, KITCHEN_BEDROOM, ACHIEVEMENT_GALLERY, QUEST_NEXUS, COMBAT,
    COSTUME, ALTAR, PORTAL, WORKSHOP
  );

(*
## ERSHouseDecoration
```pascal
ERSHouseDecoration = enum(WOOD..WINTER);
```
Enum used to represent the POH decorations available.
*)
  ERSHouseDecoration = enum(
    WOOD, STONE, WHITE_STONE, FREMENNIK_WOOD, TROPICAL_WOOD, FANCY_STONE, DEATHLY, TWISTED, HOSIDIUS, WINTER
  );

(*
## TPOHMap
Helper record used by the {ref}`TRSPOH`.

All `TPOHMap` methods are helper methods for the {ref}`TRSPOH` and you shouldn't
have to call them for anything.
*)
  TPOHMap = record
    Map, RoomsMap: TImage;
    Sample: TRSMapSample;
    Rooms: array of array of ERSHouseRoom;
    RoomImages: array [ERSHouseRoom] of TImage;
    GrassColor: TColor;
    const SIZE: Integer = 32;
    const AMOUNT: Integer = 12;
  end;

(*
## TPOHMap.Init()
```pascal
procedure TPOHMap.Init(size, amount: Integer);
```
Internal method automatically called for your on script startup along with POH.Init().
You do not have to call it yourself.
*)
procedure TPOHMap.Init();
begin
  Self.Map := new TImage(Self.SIZE * Self.AMOUNT, Self.SIZE * Self.AMOUNT);
  Self.RoomsMap := new TImage({$MACRO DIR} + 'poh.png');
  SetLength(Self.Rooms, Self.AMOUNT, Self.AMOUNT);
end;

(*
## TPOHMap.GetRoomBitmapBox()
```pascal
function TPOHMap.GetRoomBitmapBox(room: ERSHouseRoom): TBox;
```
Internal method used to get the box of the {ref}`ERSHouseRoom` you pass in.

This box is a box of the following image:

![poh rooms](../../../osr/walker/poh.png)

Example:
```pascal
{$I WaspLib/optional/handlers/poh.simba}
begin
  WriteLn POH.Map.GetRoomBitmapBox(ERSHouseRoom.SUPERIOR_GARDEN);
end;
```
*)
function TPOHMap.GetRoomBitmapBox(room: ERSHouseRoom): TBox;
var
  i: Integer;
begin
  i := Ord(room)-1;
  Result := [i * Self.SIZE, 0, i * Self.SIZE + Self.SIZE - 1, Self.SIZE-1];
end;

(*
## TPOHMap.GetRoomBitmap()
```pascal
function TPOHMap.GetRoomBitmap(room: ERSHouseRoom; color: Integer = -1): TImage;
```
Internal method used to retrieve a bitmap of the {ref}`ERSHouseRoom` you pass in.

Example:
```pascal
{$I WaspLib/optional/handlers/poh.simba}
var
  bmp: TImage;
begin
  bmp := POH.Map.GetRoomBitmap(ERSHouseRoom.SUPERIOR_GARDEN);
  bmp.Debug();
  bmp.Free();
end;
```
*)
function TPOHMap.GetRoomBitmap(room: ERSHouseRoom; color: Integer = -1): TImage;
begin
  if Self.RoomImages[room] = nil then
  begin
    Result := Self.RoomsMap.Copy(Self.GetRoomBitmapBox(room));
    Self.RoomImages[room] := Result.Copy();
  end
  else
    Result := Self.RoomImages[room].Copy();

  if color <> -1 then
    Result.ReplaceColor($FFFFFF, color);
end;

(*
## TPOHMap.RotateBitmap()
```pascal
function TPOHMap.RotateBitmap(bitmap: TImage; rotation: Integer): TImage; static;
```
Rotates a bitmap by 90ยบ increments a `rotation` number of times.
This was made specifically for room bitmaps, but you could use it for other stuff I guess.
It's also a static method and can be called directly from the type.

Example:
```pascal
{$I WaspLib/optional/handlers/poh.simba}
var
  bmp: TImage;
begin
  bmp := POH.Map.GetRoomBitmap(ERSHouseRoom.MENAGERIE_OPEN);
  bmp.Debug();
  Wait(2000);
  TPOHMap.RotateBitmap(bmp, 1);
  bmp.Debug();
  bmp.Free();
end;
```
*)
function TPOHMap.RotateBitmap(img: TImage; rotation: Integer): TImage; static;
var
  p: TPoint;
begin
  if rotation = 0 then
    Exit(img.Copy());

  img.Pad(1);
  Result := img.Rotate(EImageRotateAlgo.NEAREST_NEIGHBOUR, PI/2*rotation, False);

  for p.X := 0 to 3 do
    for p.Y := 0 to 3 do
      if Result.Pixel[p.X, p.Y] <> $0 then
        Break(2);

  Result.Crop([p.X, p.Y, p.X + 31, p.Y + 31]);
end;


(*
## TPOHMap.WriteRoom()
```pascal
procedure TPOHMap.WriteRoom(room: ERSHouseRoom; index: TPoint);
```
Internal method used to write a room to `TPOHMap.Rooms` cache.
This uses an `TPoint` as a room `index` in a 2D array of {ref}`ERSHouseRoom`.

Unless you know what you are doing, you definitly should not use this for anything.

Example:
```pascal
POH.Map.WriteRoom(ERSHouseRoom.SUPERIOR_GARDEN, [3,3]);
```
*)
procedure TPOHMap.WriteRoom(room: ERSHouseRoom; index: TPoint);
begin
  if not InRange(index.X, 0, High(Self.Rooms)) then
    TerminateScript('index.X is not between 0 and ' + ToStr(High(Self.Rooms)) + ', got ' + ToStr(index));
  if not InRange(index.Y, 0, High(Self.Rooms[0])) then
    TerminateScript('index.Y is not between 0 and ' + ToStr(High(Self.Rooms[0])) + ', got: ' + ToStr(index));

  Self.Rooms[index.Y,index.X] := room;
end;

(*
## TPOHMap.ReadRoom()
```pascal
function TPOHMap.ReadRoom(index: TPoint): ERSHouseRoom;
```
Internal method used to read a cached room in `TPOHMap.Rooms`.
This uses an `TPoint` as a room `index`.

Unless you know what you are doing, you don't need this, but there's no harm in using it.

Example:
```pascal
WriteLn POH.Map.ReadRoom([3,3]);
```
*)
function TPOHMap.ReadRoom(index: TPoint): ERSHouseRoom;
begin
  if not InRange(index.X, 0, High(Self.Rooms)) then
    TerminateScript('p.X is not between 0 and ' + ToStr(High(Self.Rooms)) + ', got ' + ToStr(index));
  if not InRange(index.Y, 0, High(Self.Rooms[0])) then
    TerminateScript('p.Y is not between 0 and ' + ToStr(High(Self.Rooms[0])) + ', got: ' + ToStr(index));

  Result := Self.Rooms[index.Y,index.X];
end;


(*
## TPOHMap.PrintRooms()
```pascal
procedure TPOHMap.PrintRooms();
```
Debugging helper method used to read a cached rooms in `TPOHMap.Rooms`.
This will print the whole cache nicely formated in a way that is human friendly like you were looking at the house map.

Unless you know what you are doing, you don't need this, but there's no harm in using it.

```{note}
:class: dropdown
It's a extremely useful debugging tool when paired with `POH.Map.Map.Debug()`.
```

Example:
```pascal
POH.Setup();
POH.Map.PrintRooms();
```
*)
procedure TPOHMap.PrintRooms();
var
  str: String;
  i, j: Integer;
begin
  str := '[' + LINE_SEP;
  for i := 0 to High(Self.Rooms) do
  begin
    for j := 0 to High(Self.Rooms[i]) do
    begin
      if j = 0 then
      begin
        str += '  [';
      end;
        str += ToStr(Self.Rooms[i,j]);
      if j < High(Self.Rooms[i]) then
        str += ', ';
    end;
      str += ', ' + LINE_SEP;
  end;
  str += ']';
  WriteLn str;
end;


(*
## TPOHMap.DrawMap()
```pascal
procedure TPOHMap.DrawMap(img: TImage; room: ERSHouseRoom; pt: TPoint);
procedure TPOHMap.DrawMap(room: ERSHouseRoom; color: Integer; pt: TPoint); overload;
```
Methods used to draw the POH map and cache the rooms drawn in `TPOHMap.Rooms`.

Example:
```pascal
POH.Map.DrawMap(ERSHouseRoom.SUPERIOR_GARDEN, POH.GrassColor, [3,3]);
POH.Map.Debug();
POH.Map.PrintRooms();
```
*)
procedure TPOHMap.DrawMap(img: TImage; room: ERSHouseRoom; pt: TPoint);
begin
  Self.WriteRoom(room, pt);
  Self.Map.DrawImage(img, [Self.SIZE * pt.X, Self.SIZE * pt.Y]);
end;

procedure TPOHMap.DrawMap(room: ERSHouseRoom; color: Integer; pt: TPoint); overload;
var
  img: TImage;
begin
  img := Self.GetRoomBitmap(room, color);
  Self.DrawMap(img, room, pt);
end;


(*
## TPOHMap.GetPointIndex()
```pascal
function TPOHMap.GetPointIndex(p: TPoint): TPoint;
```
Helper method that converts a normal TPoint to a index used by {ref}`TPOHMap.ReadRoom()`.

Example:
```pascal
WriteLn POH.Map.GetPointIndex(POH.GetPos());
```
*)
function TPOHMap.GetPointIndex(p: TPoint): TPoint;
begin
  Result := [p.X div Self.SIZE, p.Y div Self.SIZE];
end;

(*
## TPOHMap.GetRoom()
```pascal
function TPOHMap.GetRoom(p: TPoint): ERSHouseRoom;
```
Helper method that returns the cached room in `TPOHMap.Rooms`with the help of
{ref}`TPOHMap.GetPointIndex()` and {ref}`TPOHMap.ReadRoom()`.

Example:
```pascal
WriteLn POH.Map.GetRoom(POH.GetPos());
```
*)
function TPOHMap.GetRoom(p: TPoint): ERSHouseRoom;
begin
  Result := Self.ReadRoom(Self.GetPointIndex(p));
end;


(*
## TPOHMap.GetRoomTopLeft()
```pascal
function TPOHMap.GetRoomTopLeft(p: TPoint): TPoint;
```
Helper method that returns the top left point of a mapped room that the specified `p` belongs to.
This is required to do accurate "room math".

Example:
```pascal
WriteLn POH.Map.GetRoomTopLeft(POH.GetPos());
```
*)
function TPOHMap.GetRoomTopLeft(p: TPoint): TPoint;
begin
  Result := [p.X div Self.SIZE * Self.SIZE, p.Y div Self.SIZE * Self.SIZE];
end;

(*
## TPOHMap.GetAdjacentIndices()
```pascal
function TPOHMap.GetAdjacentIndices(index: TPoint): TPointArray; static;
```
Helper method that returns indices of the adjacent rooms (north, west, south and east) on the `TPOHMap.Rooms` cache.
It's also a static method and can be called directly from the type.

Example:
```pascal
WriteLn TPOHMap.GetAdjacentIndices([3,3]);
```
*)
function TPOHMap.GetAdjacentIndices(index: TPoint): TPointArray; static;
begin
  Result := [index.Offset(-1,0), index.Offset(1, 0), index.Offset(0, -1), index.Offset(0, 1)];
end;


(*
## TPOHMap.SampleSearch()
```pascal
function TPOHMap.SampleSearch(minimapBMP: TImage; sampleSize: Integer = 50; sampleAmount: Integer = 3): TPoint;
```
Helper method that returns the the position of the minimapBMP in the `TPOHMap.Map`, essentially getting the player position.

Example:
```pascal
{$I WaspLib/optional/handlers/poh.simba}
var
  minimapBMP: TImage;
begin
  minimapBMP := TRSPOH.GetCleanMinimap();
  minimapBMP.ReplaceColor(1, POH.Map.GrassColor);
  WriteLn POH.Map.SampleSearch(minimapBMP, SAMPLE_SIZE);
  minimapBMP.Free();
end;
```
*)
function TPOHMap.SampleSearch(minimapBMP: TImage; sampleSize: Integer = 50; sampleAmount: Integer = 3): TPoint;
var
  sampleSM, sampleLG: TImage;
  offset: TPoint;
  b: TBox;
  matrixSM, matrixLG: TSingleMatrix;
  resultSM, resultLG: TPointArray;
  i, j, s: Integer;
  p: TPoint;
begin
  s := 20;
  offset := minimapBMP.Center.Offset(2, 5);
  b := Box(offset, s, s);
  sampleSM := minimapBMP.Copy(b);
  b := Box(offset, sampleSize, sampleSize);
  sampleLG := minimapBMP.Copy(b);

  matrixSM := MatchTemplate(sampleSM, Self.Map, ETMFormula.TM_CCOEFF_NORMED);
  matrixLG := MatchTemplate(sampleLG, Self.Map, ETMFormula.TM_CCOEFF_NORMED);

  Dec(sampleAmount);

  for i := 0 to sampleAmount do
    with matrixSM.ArgMax() do
    begin
      p := Point(X - (sampleSize - s), Y - (sampleSize - s)).Offset(sampleSize - 3, sampleSize - 5);
      if Self.GetRoom(p) <> ERSHouseRoom.UNKNOWN then
        resultSM += p
      else
        Dec(i);
      matrixSM.Fill([X - 5, Y - 5, X + 5, Y + 5], 0);
    end;

  for i := 0 to sampleAmount do
    with matrixLG.ArgMax() do
    begin
      p := Point(X, Y).Offset(sampleSize - 3, sampleSize - 5);
      if Self.GetRoom(p) <> ERSHouseRoom.UNKNOWN then
        resultLG += p
      else
        Dec(i);
      matrixLG.Fill([X - 5, Y - 5, X + 5, Y + 5], 0);
    end;

  for i := 0 to High(resultLG) do
    for j := 0 to High(resultSM) do
      if resultLG[i].InRange(resultSM[j], 6) then
        Exit(resultLG[i]);

  Result := resultSM[0];
end;
