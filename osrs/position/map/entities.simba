(*
# RSEntities
This file is responsible for interacting with `RSEntities`.

`RSEntities` is anything in the game that has a {ref}`ERSMinimapDot` assign to
it on the {ref}`Minimap`.

These are functionally very similar to {ref}`RSObjects` and you create and
interact with them almost the same way.

They only differ in the fact that `TRSEntity` can use a {ref}`ERSMinimapDot` to
help find them and/or {ref}`TRSDotFilters`.
Also, due to the unpredictability of entities that move, unlike {ref}`RSObjects`
these do not have a rotation field.
*)

{$DEFINE WL_RSENTITIES_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
  ENPCData = enum(ID, NAME, LEVEL, CATEGORY, MINIMAPDOT, ACTIONS, SIZE, COORDINATES, COLORS);

(*
## TRSEntity
Main type to handle {ref}`RSEntity`.
*)
  TRSEntity = record
    UpText: TStringArray;
    Size: TVector3;
    Model: TModel;
    Coordinates: TPointArray;
    Filter: TRSDotFilterArray;
    Finder: TColorFinder;
    MinimapDots: ERSMinimapDots;
    LastCoordinate: TPoint;
    Walker: PRSWalker;
    MinDistance: Integer;
  end;

(*
## TRSEntityArray
Array of {ref}`TRSEntity`.
*)
  TRSEntityArray = array of TRSEntity;

(*
## TRSEntity.Create
```pascal
function TRSEntity.Create(var walker: TRSWalker; size: TVector3; coordinates: TPointArray; uptext: TStringArray = []; dots: ERSMinimapDots = []): TRSEntity; static;
function TRSEntity.Create(var walker: TRSWalker; json: TJSONObject): TRSEntity; static; overload;
```
Create function to create your {ref}`TRSEntity`.

Assuming you create the `RSEntity` manually, the create function will provide
you with a fully built `TRSEntity` without a finder.

You may optionally assign one later if you want:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([ERSChunk.VARROCK]);             //varrock west southern most banker
  npc := TRSEntity.Create(Map.Walker, [1,1,7], [[8652,36686]], ['Banker'], [ERSMinimapDot.NPC]);
  //npc.Finder.Colors += [$543B3B, 10.121, EColorSpace.HSV, [0.528, 1.275, 1.199]];
end;
```

The `json` version of the function expects a specific json structure which is
the one that {ref}`Map JSONs` provide:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([ERSChunk.VARROCK]);
  //Item[0] because this returns a JSON array. For more info read Map JSONs documentation.
  npc := TRSEntity.Create(Map.Walker, NPCsJSON.GetByName('banker', 1).Item[0]);
end;
```
*)
function TRSEntity.Create(var walker: TRSWalker; size: TVector3; radius: Integer; coordinates: TPointArray; uptext: TStringArray = []; dots: ERSMinimapDots = []): TRSEntity; static;
var
  pt: TPoint;
begin
  Result.Coordinates := coordinates;
  Result.Size := size;

  if dots <> [] then
    Result.MinimapDots := dots;
  if uptext <> [] then
    Result.UpText := uptext;

  Result.Finder := Default(TColorFinder);
  Result.Walker := @walker;
  Result.MinDistance := 32;

  for pt in coordinates do
    Result.Filter += TRSDotFilter.Create([], TCircle.Create(pt.X, pt.Y, radius), True);
end;

function TRSEntity.Create(var walker: TRSWalker; json: TJSONObject): TRSEntity; static; overload;
var
  i, j, l: Integer;
  unique: array of TColorArray;
  color: TColor;
  best: TBestColor;
  coord: TJSONArray;
begin
  if json.Typ <> EJSONType.OBJ then
    raise GetDebugLn('TRSEntity', 'JSON Object expected, got ' + ToStr(json.Typ) + '.');

  with json.Item[Ord(ENPCData.NAME)] do
    if AsString <> 'null' then
      Result.UpText := [AsString];

  if json.Item[Ord(ENPCData.MINIMAPDOT)].AsBool then
    Result.MinimapDots := [ERSMinimapDot.NPC];

  with json.Item[Ord(ENPCData.SIZE)] do
  begin
    Result.Size.X := Item[0].AsInt * 0.8;
    Result.Size.Y := Item[1].AsInt * 0.8;
    Result.Size.Z := Item[2].AsInt / 128;
  end;

  if Abs(Result.Size.Z) < 0.05 then
    Result.Size.Z := 3.0;

  with json.Item[Ord(ENPCData.COORDINATES)] do
    for i := 0 to Count-1 do
    begin
      coord := Item[i];
      Result.Coordinates += [coord.Item[0].AsInt, coord.Item[1].AsInt];
      Result.Filter += TRSDotFilter.Create([], TCircle.Create(coord.Item[0].AsInt, coord.Item[1].AsInt, 40), True);
    end;

  with json.Item[Ord(ENPCData.COLORS)] do
    for i := 0 to Count-1 do
    begin
      color := Item[i].AsInt;

      for j := 0 to High(unique) do
      begin
        for l := 0 to High(unique[j]) do
          if ColorDistance(color, unique[j, l], EColorSpace.HSL, [1.5, 1.5, 1.5]) < 15 then
          begin
            unique[j] += color;
            Continue(3);
          end;
      end;

      unique += [color];
    end;

  for i := 0 to High(unique) do
  begin
    best := GetBestColor(EColorSpace.HSL, unique[i]);
    Result.Finder.Colors += [best.Color, best.Tolerance*1.5, EColorSpace.HSL, [best.Mods[0]*1.5, best.Mods[1]*1.5, best.Mods[2]*1.5]];
  end;

  Result.Walker := @walker;
  Result.MinDistance := 32;
end;

(*
## TRSEntityArray.Create
```pascal
function TRSEntityArray.Create(json: TJSONArray): TRSEntityArray; static;
```
Create function to build your {ref}`TRSEntityArray`.

This only accepts a `json` array and it expects a specific json structure which is
the one that {ref}`Map JSONs` provide.

Example:
```pascal
{$I WaspLib/osrs.simba}

var
  entities: TRSEntityArray;
begin
  Map.Setup([ERSChunk.VARROCK]);
  entities := TRSEntityArray.Create(Map.Walker, NPCsJSON.GetByName('Banker'));
end;
```
*)
function TRSEntityArray.Create(var walker: TRSWalker; json: TJSONArray): TRSEntityArray; static;
var
  i: Integer;
begin
  if json.Typ <> EJSONType.ARR then
    raise GetDebugLn('TRSEntity', 'JSON Array expected, got ' + ToStr(json.Typ) + '.');

  SetLength(Result, json.Count);
  for i := 0 to High(Result) do
    Result[i] := TRSEntity.Create(walker, json.Item[i]);
end;


(*
## Entity._GetBounds
```pascal
function TRSEntity._GetBounds(me: TPoint; vector: TVector2; size: TVector3; height, radians: Single): TCuboid;
```
Internal helper function for {ref}`TRSEntity.GetBoundsArray`.
*)
function TRSEntity._GetBounds(me: TPoint; vector: TVector2; size: TVector3; height, radians: Single): TPolygon;
var
  corners: TVector3Array;
  pt: TPoint;
begin
  pt := me + vector.ToPoint() - Minimap.Center;
  if Self.Model <> nil then
    Exit(Self.Model.GetArea(Projection.ProjectModel(Self.Model, vector.ToVec3(Self.Walker^.Height(pt, False) - height), 0, radians)));

  if Abs(size.X - 0) < 0.005 then
    raise GetDebugLn('TRSEntity', 'Your entity has a size.X of 0 or is simply too small! An entity can''t be ' + ToStr(size.X) + ' tiles wide.');
  if Abs(size.Y - 0) < 0.005 then
    raise GetDebugLn('TRSEntity', 'Your entity has a size.Y of 0 or is simply too small! An entity can''t be ' + ToStr(size.Y) + ' tiles wide.');

  size.X := size.X*2;
  size.Y := size.Y*2;

  corners := [
    [vector.X-size.X, vector.Y-size.Y, Self.Walker^.Height(pt - [1,3],  False) - height],
    [vector.X+size.X, vector.Y-size.Y, Self.Walker^.Height(pt + [3,-3], False) - height],
    [vector.X+size.X, vector.Y+size.Y, Self.Walker^.Height(pt + [3,1],  False) - height],
    [vector.X-size.X, vector.Y+size.Y, Self.Walker^.Height(pt - [1,1],  False) - height],
    [vector.X-size.X, vector.Y-size.Y, Self.Walker^.Height(pt - [1,3],  False) - height+size.Z],
    [vector.X+size.X, vector.Y-size.Y, Self.Walker^.Height(pt + [3,-3], False) - height+size.Z],
    [vector.X+size.X, vector.Y+size.Y, Self.Walker^.Height(pt + [3,1],  False) - height+size.Z],
    [vector.X-size.X, vector.Y+size.Y, Self.Walker^.Height(pt - [1,1],  False) - height+size.Z]
  ];

  Result := Projection.Run(corners, radians).ConvexHull();
end;

(*
## Entity.GetBoundsArray
```pascal
function TRSEntity.GetBoundsArray(me: TPoint; angle: Single = $FFFF): TCuboidArray;
```
Internal function that returns an array of cuboids of the entity if it's visible
on the {ref}`MainScreen`.
*)
function TRSEntity.GetBoundsArray(me: TPoint; out coordinates: TPointArray; radians: Single = $FFFF): TPolygonArray;
var
  weights: TDoubleArray;
  meLocal, pt: TPoint;
  i: Integer;
  h, dist: Double;
  vector: TVector2;
  dots: TPointArray;
begin
  coordinates := [];
  if radians = $FFFF then
    radians := Minimap.CompassRadians;

  meLocal := Self.Walker^.GetLocal(me);

  h := Self.Walker^.Height(meLocal - [1,3], False) + Self.Walker^.Height(meLocal + [3,-3], False) +
       Self.Walker^.Height(meLocal + [3,1], False) + Self.Walker^.Height(meLocal - [1,1], False);
  h := h/4;

  if Self.Filter <> [] then
  begin
    dots := Minimap.GetFilteredDotArray(Self.MinimapDots, Self.Walker^.FiltersToMM(me, Self.Filter, radians));
    if dots = [] then
      Exit;

    dots := dots.SortFrom(Minimap.Center);
    for i := 0 to High(dots) do
    begin
      pt := Self.Walker^.MM2Map(me, dots[i], radians);
      coordinates += pt;

      vector := Self.Walker^.Point2MMVec(me, pt, radians);
      vector := vector.Rotate(-radians, Minimap.Center);
      Result += Self._GetBounds(meLocal, vector, Self.Size, h, radians);
    end;
    Exit;
  end;

  for i := 0 to High(Self.Coordinates) do
  begin
    pt := Self.Coordinates[i];
    dist := me.DistanceTo(pt);
    if dist > 85 then
      Continue;

    weights += dist;
    coordinates += pt;

    vector := Self.Walker^.Point2MMVec(me, pt, radians);
    vector := vector.Rotate(-radians, Minimap.Center);
    Result += Self._GetBounds(meLocal, vector, Self.Size, h, radians);
  end;

  if Result <> [] then
  begin
    Sort(Result, weights, True);
    coordinates.Sort(weights, True);
  end;
end;

(*
## TRSEntity.Find
```pascal
function TRSEntity.Find(cuboidArray: TCuboidArray): T2DPointArray;
```
Internal TRSEntity method responsible for filtering a TCuboidArray by what's visible in the mainscren.
This is meant to filter TRSEntity.GetBoundsArray() so targets that are outside of the mainscreen are filtered out.
You will probably never need to use this directly.
*)
function TRSEntity.FindOnMainScreen(out coordinates: TPointArray; boundsArray: TPolygonArray): T2DPointArray;
var
  i: Integer;
  found: TBooleanArray;
begin
  if Self.Finder <> Default(TColorFinder) then
  begin
    Self.Finder.FindEx(Result, found, boundsArray, Self.Model = nil);

    for i := High(found) downto 0 do
      if not found[i] then
        Delete(coordinates, i, 1);

    Exit;
  end;

  if Self.Model <> nil then
    Exit(boundsArray);

  for i := 0 to High(boundsArray) do
    Result += TPointArray(boundsArray[i]).Connect().ShapeFill();
end;

(*
## TRSEntity.FindEx
```pascal
function TRSEntity.FindEx(me: TPoint; out boundsArray: TPolygonArray; out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
```
Internal {ref}`TRSEntity` method used to find a {ref}`RSEntity`.

You also have {ref}`RSEntity.Find` to find entities, this version of the method
is internal because it returns extra information about the found entities for
internal use, like it's `cuboids` for example.

This also returns an `atpa` containing the colors of the entity that were found
assuming the entity has a {ref}`TColorFinder` setup.
If not, the cuboids area are returned as the match.
*)
function TRSEntity.FindEx(me: TPoint; out boundsArray: TPolygonArray; out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
begin
  boundsArray := Self.GetBoundsArray(me, coordinates);
  if boundsArray = [] then Exit;
  atpa := Self.FindOnMainScreen(coordinates, boundsArray);

  Result := atpa <> [];
end;


(*
## RSEntity.Find
```pascal
function TRSEntity.Find(out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
function TRSEntity.Find(out atpa: T2DPointArray): Boolean; overload;
```
{ref}`TRSEntity` method used to find a {ref}`RSEntity`.
This returns True/False if the entity was found and it's `atpa` which cointains
the colors of it that were found.

For more information on this refer to {ref}`TRSEntity.FindEx`, it's an internal
function but is used within this one and will go into more detail.
*)
function TRSEntity.Find(out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
var
  boundsArray: TPolygonArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), boundsArray, coordinates, atpa);
end;

function TRSEntity.Find(out atpa: T2DPointArray): Boolean; overload;
var
  coordinates: TPointArray;
  boundsArray: TPolygonArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), boundsArray, coordinates, atpa);
end;


(*
## Entity.IsVisible
```pascal
function TRSEntity.IsVisible(): Boolean;
```
Returns a boolean whether the entity is currently visible or not.
*)
function TRSEntity.IsVisible(): Boolean;
var
  coordinates: TPointArray;
  boundsArray: TPolygonArray;
  atpa: T2DPointArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), boundsArray, coordinates, atpa);
end;


function TRSEntity.FindFrom(position: TPoint; out atpa: T2DPointArray): Boolean;
var
  boundsArray: TPolygonArray;
  coordinates: TPointArray;
begin
  Result := Self.FindEx(position, boundsArray, coordinates, atpa);
end;

(*
## TRSEntity._UpTextCheck
```pascal
function TRSEntity._UpTextCheck(out shouldExit: Boolean; action: TStringArray): Boolean;
```
Internal TRSEntity helper method that is used by all hovering methods.
You probably don't need to use this directly.
*)
function TRSEntity._UpTextCheck(out shouldExit: Boolean; action: TStringArray): Boolean;
var
  text: String;
begin
  shouldExit := True;

  if (RSClient.Mode = ERSMode.FIXED) and MSInterface.IsOpen() then
    Exit;

  if Self.UpText <> [] then
    Self.Walker^.TargetUpText := Copy(Self.UpText);

  text := MainScreen.UpText;

  if text.Contains('>') and not action.Contains(['>']) then
  begin
    ChooseOption.Close();
    Exit;
  end;

  if (Self.UpText <> []) and text.ContainsAny(Self.UpText) then
    Exit(True);

  shouldExit := False;
end;


(*
## TRSEntity._ClickHelper
```pascal
function TRSEntity._ClickHelper(leftClick: Boolean): Boolean;
```
Internal TRSEntity helper method that is used by other clicking methods.
You probably don't need to use this directly.

This is what's responsible for deciding if we click a target we are hovering or not.
*)
function TRSEntity._ClickHelper(leftClick: Boolean): Boolean;
begin
  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Select(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
    Exit;
  end;

  if leftClick and Biometrics.RedClick(EMouseButton.LEFT, 2) then
    Exit(True);

  Result := not leftClick and (Self.UpText <> []) and ChooseOption.Select(Self.UpText);
end;

(*
## TRSEntity._SelectHelper
```pascal
function TRSEntity._SelectHelper(action: TStringArray): Boolean;
```
Internal TRSEntity helper method that is used by other select methods.
You probably don't need to use this directly.

This is what is responsible for deciding if we just left click a target we are hovering or right click it and choose an option.
*)
function TRSEntity._SelectHelper(action: TStringArray): Boolean;
begin
  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() and ChooseOption.Select(action) then
    Exit(True);

  if MainScreen.IsUpText(action) then
    Exit(Biometrics.RedClick(EMouseButton.LEFT, 2));

  Result := ChooseOption.Select(action);
end;


(*
## TRSEntity.Hover
```pascal
function TRSEntity.Hover(action: TStringArray = []; attempts: Integer = 2): Boolean;
```
Method used to hover a TRSEntity target if it's found on the {ref}`MainScreen`.

Example:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([Chunk(Box(40,49,41,48), 0)]);
  npc := TRSEntity.Create(Map.Walker, [1,1,7], 8, [[10432, 37966]], ['Dominic Onion'], [ERSMinimapDot.NPC]);
  WriteLn npc.Hover();
end.
```
*)
function TRSEntity.Hover(action: TStringArray = []; attempts: Integer = 2): Boolean;
var
  me: TPoint;
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
begin
  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Find(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the entity to have coordinates.');

  me := Self.Walker^.Position();
  if not TRSWalker.MakePointVisibleEx(me, Self.Coordinates.NearestPoint(me)) then
    Exit;

  Result := Self._UpTextCheck(shouldExit, action);
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i].ExtractBox(MainScreen.Bounds);
      if tpa = [] then
        Continue;

      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if TRSObject._HoverHelper(Self.UpText + action, attempt, attempts) then
      Exit(True);
  end;
end;

(*
## TRSEntity.WalkHover
```pascal
function TRSEntity.WalkHover(action: TStringArray = []; attempts: Integer = 2): Boolean;
```
Method used to walk and hover a TRSEntity target if it's found on the
{ref}`MainScreen` after walking.

Example:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([Chunk(Box(40,49,41,48), 0)]);
  npc := TRSEntity.Create(Map.Walker, [1,1,7], 8, [[10432, 37966]], ['Dominic Onion'], [ERSMinimapDot.NPC]);
  WriteLn npc.WalkHover();
end.
```
*)
function TRSEntity.WalkHover(action: TStringArray = []; attempts: Integer = 2): Boolean;
var
  me, closest: TPoint;
  path: TPointArray;
  hasPath, shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
begin
  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Find(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  me :=  Self.Walker^.Position();
  closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

  //if the point is not reachable with the webgraph (like a banker behind a booth) then pick nearest node as target
  if path = [] then
  begin
    path := Self.Walker^.WebGraph^.PathToNear(me, closest, 0.33);
    if path = [] then
      raise GetDebugLn('TRSEntity', 'Can''t path to object.');
    hasPath := True;
  end;

  Self.Walker^.TargetUpText := Copy(Self.UpText);
  Self.Walker^.ActionUpText := action;

  try
    // check if doors need to be passed to reach target
    if hasPath or Self.Walker^.WebGraph^.WalkableClusters.InSameTPA(me, closest) then
    begin
      if not Self.Walker^.MakePointVisible(closest) and not Self.Walker^.WebWalkEx(me, closest, Self.MinDistance, 0.15) then
        Exit;
    end
    else
    if not Self.Walker^.WebWalk(closest, Self.MinDistance, 0.15) then
      Exit;

    me := Self.Walker^.Position();
    if not TRSWalker.MakePointVisibleEx(me, Self.Coordinates.NearestPoint(me)) then
      Exit;

    Result := Self._UpTextCheck(shouldExit, action) or Self.Walker^.RedClicked;
    if shouldExit then Exit;

    for attempt := 0 to attempts do
    begin
      if Self.Find(coordinates, atpa) then
      begin
        if attempt < 2 then i := 0
        else if Length(atpa) > (attempt - 2) then i := attempt - 2
        else i := Random(Low(atpa), High(atpa));

        tpa := atpa[i].ExtractBox(MainScreen.Bounds);
        if tpa = [] then
          Continue;

        Self.LastCoordinate := coordinates[i];

        Mouse.Move(tpa.RandomMean());

        if Self.UpText = [] then
          Exit(True);
        Sleep(50); //give uptext 1~ frame time to update
      end;

      if TRSObject._WalkHoverHelper(Self.UpText + action, Self.Walker, Self.MinDistance, attempt, attempts, Self.Coordinates, path) then
        Exit(True);
    end;
  finally
    Self.Walker^.TargetUpText := [];
    Self.Walker^.ActionUpText := [];
  end;
end;


(*
## TRSEntity.Click
```pascal
function TRSEntity.Click(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
```
Method used to click a TRSEntity target if it's found on the {ref}`MainScreen`.

Example:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([Chunk(Box(40,49,41,48), 0)]);
  npc := TRSEntity.Create(Map.Walker, [1,1,7], 8, [[10432, 37966]], ['Dominic Onion'], [ERSMinimapDot.NPC]);
  WriteLn npc.Click();
end.
```
*)
function TRSEntity.Click(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  Result := Self.Hover([], attempts) and Self._ClickHelper(leftClick);
end;

(*
## TRSEntity.Interact
```pascal
function TRSEntity.Interact(action: TStringArray; attempts: Integer = 2): Boolean;
```
Method used to select an option on a TRSEntity target if it's found on the
{ref}`MainScreen`.

Example:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([Chunk(Box(40,49,41,48), 0)]);
  npc := TRSEntity.Create(Map.Walker, [1,1,7], 8, [[10432, 37966]], ['Dominic Onion'], [ERSMinimapDot.NPC]);
  WriteLn npc.Interact(['Dream']);
end.
*)
function TRSEntity.Interact(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  Result := Self.Hover(action, attempts) and Self._SelectHelper(action);
end;

(*
## TRSEntity.WalkClick
```pascal
function TRSEntity.WalkClick(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
```
Method used to walk and click a TRSEntity target if it's found on the
{ref}`MainScreen`.

Example:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([Chunk(Box(40,49,41,48), 0)]);
  npc := TRSEntity.Create(Map.Walker, [1,1,7], 8, [[10432, 37966]], ['Dominic Onion'], [ERSMinimapDot.NPC]);
  WriteLn npc.WalkClick();
end.
```
*)
function TRSEntity.WalkClick(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  Result := Self.WalkHover([], attempts) and Self._ClickHelper(leftClick);
end;

(*
## TRSEntity.WalkInteract
```pascal
function TRSEntity.WalkInteract(action: TStringArray; attempts: Integer = 2): Boolean;
```
Method used to walk and select an option on a TRSEntity target if it's found on
the mainscreen.

Example:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([Chunk(Box(40,49,41,48), 0)]);
  npc := TRSEntity.Create(Map.Walker, [1,1,7], 8, [[10432, 37966]], ['Dominic Onion'], [ERSMinimapDot.NPC]);
  WriteLn npc.WalkInteract(['Dream']);
end.
```
*)
function TRSEntity.WalkInteract(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  Result := Self.WalkHover(action, attempts) and Self._SelectHelper(action);
end;


function TRSEntity.DistanceTo(pt: TPoint): Double;
var
  dist: Double;
  i: Integer;
begin
  Result := $FFFFFF;
  for i := 0 to High(Self.Coordinates) do
  begin
    dist := Self.Coordinates[i].DistanceTo(pt);
    if dist < Result then
      Result := dist;
  end;
end;

function TRSEntityArray.ClosestIndex(pt: TPoint): Integer;
var
  closest, dist: Double;
  i, j: Integer;
begin
  closest := $FFFFFF;
  for i := 0 to High(Self) do
    for j := 0 to High(Self[i].Coordinates) do
    begin
      dist := Self[i].Coordinates[j].DistanceTo(pt);
      if dist >= closest then Continue;

      closest := dist;
      Result := i;
    end;
end;

(*
## TImage.DrawEntity
```pascal
procedure TImage.DrawEntity(npc: TRSEntity);
```
Helper method to debug TRSEntity.
*)
procedure TImage.DrawEntity(entity: TRSEntity);
var
  me: TPoint;
  atpa: T2DPointArray;
  boundsArray: TPolygonArray;
  i: Integer;
  filters: TRSDotFilterArray;
  filter: TRSDotFilter;
  coordinates: TPointArray;
begin
  me := entity.Walker^.Position();
  filters := entity.Walker^.FiltersToMM(me, entity.Filter, Minimap.CompassRadians);

  for filter in filters do
  begin
    if not Minimap.Bounds.Overlap(filter.Poly.Bounds()) and
       not Minimap.Bounds.Overlap(filter.Circle.Bounds) then Continue;

    if filter.Inside then
      Self.DrawColor := $00FF00
    else
      Self.DrawColor := $0000FF;

    Self.DrawPolygon(filter.Poly);
    Self.DrawCircle(filter.Circle);
  end;

  if entity.FindEx(me, boundsArray, coordinates, atpa) then
  begin
    Self.DrawColor := TColor.Random();
    Self.DrawATPA(atpa);
  end;

  Self.DrawColor := $FFFFF;
  for i := 0 to High(boundsArray) do
    Self.DrawTPA(boundsArray[i].Connect());
end;

(*
## ShowOnTarget TRSEntity
```pascal
procedure ShowOnTarget(entity: TRSEntity); overload;
```
Shows an image of the target with the `TRSEntity` drawn on it.
*)
procedure ShowOnTarget(entity: TRSEntity); overload;
var
  img: TImage;
begin
  img := Target.GetImage();
  img.DrawEntity(entity);
  img.Show();
end;

(*
## ShowOnTarget TRSEntityArray
```pascal
procedure ShowOnTarget(entities: TRSEntityArray); overload;
```
Shows an image of the target with the `TRSEntityArray` drawn on it.
*)

procedure ShowOnTarget(entities: TRSEntityArray); overload;
var
  img: TImage;
  i: Integer;
begin
  img := Target.GetImage();
  for i := 0 to High(entities) do
    img.DrawEntity(entities[i]);
  img.Show();
end;


function ToString(constref entity: TRSEntity): String; override;
begin
  Result := '[' + ToString(entity.UpText) + ', ' +
                  ToString(entity.Size) + ', ' +
                  ToString(entity.Coordinates) + ', ' +
                  ToString(entity.Finder) + ', ' +
                  ToString(entity.MinimapDots) + ']';
end;
