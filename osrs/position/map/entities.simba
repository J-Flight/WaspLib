(*
# Entities
This file is responsible for interacting with `RSEntities`.

`RSEntities` is anything in the game that has a {ref}`ERSMinimapDot` assign to
it on the {ref}`Minimap`.

These are functionally very similar to {ref}`RSObjects` and you create and
interact with them almost the same way.

They only differ in the fact that `TRSEntity` can use a {ref}`ERSMinimapDot` to
help find them and/or {ref}`TRSDotFilters`.
Also, due to the unpredictability of entities that move, unlike {ref}`RSObjects`
these do not have a rotation field.
*)

{$DEFINE WL_RSENTITIES_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
(*
## TRSEntity
Main type to handle {ref}`RSEntity`.
*)
  TRSEntity = record
    UpText: TStringArray;
    Size: TVector3;
    Coordinates: TPointArray;
    Filter: TRSDotFilterArray;
    Finder: TColorFinder;
    Track: Boolean;
    MinimapDots: ERSMinimapDots;
    LastCoordinate: TPoint;
    Walker: PRSWalker;
  end;

(*
## TRSEntityArray
Array of {ref}`TRSEntity`.
*)
  TRSEntityArray = array of TRSEntity;

(*
## RSEntity.Create
```pascal
function TRSEntity.Create(walker: PRSWalker; size: TVector3; coordinates: TPointArray; uptext: TStringArray = []; dots: ERSMinimapDots = []): TRSEntity; static;
function TRSEntity.Create(json: TJSONItem): TRSEntity; static; overload;
```
Createors to create your {ref}`TRSEntity`.

Assuming you create the `RSEntity` manually, the Createor will provide you
with a fully built `TRSEntity` without a finder.

You may optionally assign one later if you want:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([ERSChunk.VARROCK]);             //varrock west southern most banker
  npc := TRSEntity.Create(@Map.Walker, [1,1,7], [[8652,36686]], ['Banker'], [ERSMinimapDot.NPC]);
  //npc.Finder.Colors += [$543B3B, 10.121, EColorSpace.HSV, [0.528, 1.275, 1.199]];
end;
```

The `json` version of the function expects a specific json structure which is
the one that {ref}`Map JSONs` provide:
```pascal
{$I WaspLib/osrs.simba}
var
  npc: TRSEntity;
begin
  Map.Setup([ERSChunk.VARROCK]);
  //Item[0] because this returns a JSON array. For more info read Map JSONs documentation.
  npc := TRSEntity.Create(NPCsJSON.GetByName('banker', 1).Item[0]);
end;
```
*)
function TRSEntity.Create(walker: PRSWalker; size: TVector3; radius: Integer; coordinates: TPointArray; uptext: TStringArray = []; dots: ERSMinimapDots = []): TRSEntity; static;
var
  pt: TPoint;
begin
  Result.Coordinates := coordinates;
  Result.Size := size;

  if dots <> [] then
    Result.MinimapDots := dots;
  if uptext <> [] then
    Result.UpText := uptext;

  Result.Finder := Default(TColorFinder);
  Result.Walker := walker;

  for pt in coordinates do
    Result.Filter += TRSDotFilter.Create([], TCircle.Create(pt.X, pt.Y, radius), True);
end;

function TRSEntity.Create(json: TJSONItem): TRSEntity; static; overload;
var
  i: Integer;
  colors: TColorArray;
  best: TBestColor;
  coord: TJSONArray;
begin
  if json.Typ <> EJSONType.OBJ then
    raise GetDebugLn('TRSEntity', 'JSON Object expected, got ' + ToStr(json.Typ) + '.');

  if json.Item[1].AsString <> 'null' then
    Result.UpText := [json.Item[1].AsString];
  if json.Item[4].AsBool then //4 is minimapdot key in TRSMap jsons
    Result.MinimapDots := [ERSMinimapDot.NPC];

  //6 is size key in TRSMap jsons
  Result.Size.X := Round(json.Item[6].Item[0].AsInt * 0.8, 2);
  Result.Size.Y := Round(json.Item[6].Item[1].AsInt * 0.8, 2);
  Result.Size.Z := Round(json.Item[6].Item[2].AsInt / 40, 2);

  if Result.Size.Z = 0.0 then
    Result.Size.Z := 3.0;

  //7 is coordinates key in TRSMap jsons
  for i := 0 to json.Item[7].Count-1 do
  begin
    coord := json.Item[7].Item[i];
    Result.Coordinates += [coord.Item[0].AsInt, coord.Item[1].AsInt];
    Result.Filter += TRSDotFilter.Create([], TCircle.Create(coord.Item[0].AsInt, coord.Item[1].AsInt, 40), True);
  end;
  //8 is colors key in TRSMap jsons
  for i := 0 to json.Item[8].Count-1 do
    colors += json.Item[8].Item[i].AsInt;

  if colors <> [] then
  begin
    best := GetBestColor(EColorSpace.HSV, colors);
    Result.Finder.Colors += [best.Color, best.Tolerance, EColorSpace.HSV, best.Mods];
  end;

  Result.Walker := @Map.Walker;
end;

function TRSEntityArray.Create(json: TJSONItem): TRSEntityArray; static;
var
  i: Integer;
begin
  if json.Typ <> EJSONType.ARR then
    raise GetDebugLn('TRSEntity', 'JSON Array expected, got ' + ToStr(json.Typ) + '.');

  SetLength(Result, json.Count);
  for i := 0 to High(Result) do
    Result[i] := TRSEntity.Create(json.Item[i]);
end;


function TRSEntity.GetCuboidArray(me: TPoint; out coordinates: TPointArray; angle: Single = $FFFF): TCuboidArray;
var
  pt: TPoint;
  h, diff: Single;
  i: Integer;
  vec2: TVector2;
  dots: TPointArray;
  dist: Double;
  weights: TDoubleArray;
begin
  coordinates := [];
  if angle = $FFFF then angle := Minimap.GetCompassAngle(False);

  h := Self.Walker^.Height(me);

  if Self.Filter <> [] then
  begin
    dots := Minimap.GetFilteredDotArray(Self.MinimapDots, Self.Walker^.FiltersToMM(me, Self.Filter, angle));
    if dots = [] then Exit;

    dots := dots.SortFrom(Minimap.Center);
    for i := 0 to High(dots) do
    begin
      pt := Self.Walker^.MM2Map(me, dots[i], angle); // transfer back from minimap grid to map grid
      pt := RSTranslator.NormalizeNearestTile(pt) + [2,2]*(Ceil(Max(Self.Size.X, Self.Size.Y))-1); //Go from topleft corner of npc to center
      diff := -(h-Self.Walker^.Height(pt))/4;
      vec2 := Self.Walker^.Point2MMVec(me, pt, angle); //translate back to MM space, use vectors to avoid rounding errors
      Result += Minimap.Vector2MSCuboid(vec2.ToVec3(diff), Self.Size, angle, [0,0,diff]);
      coordinates += pt;
    end;
    Exit;
  end;

  for i := 0 to High(Self.Coordinates) do
  begin
    pt := Self.Coordinates[i];
    dist := me.DistanceTo(pt);
    if dist <= 85 then
    begin
      weights += dist;
      coordinates += pt;
      diff := -(h-Self.Walker^.Height(pt));
      with Self.Walker^.Point2MMVec(me, pt, angle) do
        Result += Minimap.Vector2MSCuboid([X + 0.15*diff, Y + 0.11*diff, 0], Self.Size, angle,  [0,0,diff]);
    end;
  end;

  if Result <> [] then
  begin
    Result.Sort(weights, True);
    coordinates.Sort(weights, True);
  end;
end;

(*
## TRSEntity.Find
```pascal
function TRSEntity.Find(cuboidArray: TCuboidArray): T2DPointArray;
```
Internal TRSEntity method responsible for filtering a TCuboidArray by what's visible in the mainscren.
This is meant to filter TRSEntity.GetCuboidArray() so targets that are outside of the mainscreen are filtered out.
You will probably never need to use this directly.
*)
function TRSEntity.FindOnMainScreen(out coordinates: TPointArray; cuboidArray: TCuboidArray): T2DPointArray;
var
  i: Integer;
  found: TBooleanArray;
begin
  if Self.Finder <> Default(TColorFinder) then
  begin
    Self.Finder.FindEx(Result, found, cuboidArray);

    for i := High(found) downto 0 do
      if not found[i] then
        Delete(coordinates, i, 1);

    Exit;
  end;

  for i := 0 to High(cuboidArray) do
    Result += cuboidArray[i].ShapeFill();
end;

(*
## TRSEntityV2.Find
```pascal
function TRSEntityV2.FindEx(out cuboids: TCuboidArray; out atpa: T2DPointArray): Boolean;
function TRSEntityV2.Find(out atpa: T2DPointArray): Boolean;
function TRSEntityV2.FindFromPosition(me: TPoint; out atpa: T2DPointArray): Boolean;
```
TRSEntityV2 method used to find a {ref}`TRSEntityV2`. If found returns true, if not returns false.
The "extended" method in particular is mostly meant for debugging and is the one used when you call `Debug(TRSEntity)`.

Example:
```pascal
WriteLn RSObjects.GEBank.Find(atpa); //Be in ge and with a walker setup there.
Debug(atpa);
```
*)
function TRSEntity.FindEx(me: TPoint; out cuboids: TCuboidArray; out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
begin
  cuboids := Self.GetCuboidArray(me, coordinates);
  if cuboids = [] then Exit;
  atpa := Self.FindOnMainScreen(coordinates, cuboids);

  Result := atpa <> [];
end;


function TRSEntity.Find(out coordinates: TPointArray; out atpa: T2DPointArray): Boolean;
var
  cuboids: TCuboidArray;
begin
  Result := Self.FindEx(Self.Walker^.Position(), cuboids, coordinates, atpa);
end;

function TRSEntity.FindFrom(position: TPoint; out atpa: T2DPointArray): Boolean;
var
  cuboids: TCuboidArray;
  coordinates: TPointArray;
begin
  Result := Self.FindEx(position, cuboids, coordinates, atpa);
end;

(*
## TRSEntity._UpTextCheck
```pascal
function TRSEntity._UpTextCheck(out shouldExit: Boolean): Boolean;
```
Internal TRSEntity helper method that is used by all hovering methods.
You probably don't need to use this directly.
*)
function TRSEntity._UpTextCheck(out shouldExit: Boolean): Boolean;
var
  text: String;
begin
  shouldExit := True;

  if (RSClient.Mode = ERSMode.FIXED) and MSInterface.IsOpen() then
    Exit;

  if Self.UpText <> [] then
    Self.Walker^.TargetUpText := Copy(Self.UpText);

  text := MainScreen.UpText;

  if text.Contains('>') and not Self.Walker^.ActionUpText.Contains(['>']) then
  begin
    ChooseOption.Close();
    Exit;
  end;

  if (Self.UpText <> []) and text.ContainsAny(Self.UpText) then
    Exit(True);

  shouldExit := False;
end;

(*
## TRSEntity._HoverHelper
```pascal
function TRSEntity._HoverHelper(attempts: Integer; trackTarget: Boolean): Boolean;
```
Internal helper method used to hover a TRSEntity target.
You should not use this directly.
*)
function TRSEntity._HoverHelper(attempts: Integer): Boolean;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa: TPointArray;
  angle: Double;
begin
  Result := Self._UpTextCheck(shouldExit);
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if Length(coordinates) <> Length(atpa) then
        raise 'SOMETHING WENT WRONG CACHING COORDINATES.';

      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then Exit(True);

    if attempt <> (attempts - 1) then Continue;

    angle := Minimap.GetCompassAngle();
    Minimap.SetCompassAngle(angle-50, angle+50);
  end;
end;

(*
## TRSEntity._WalkHoverHelper
```pascal
function TRSEntity._WalkHoverHelper(attempts: Integer; trackTarget: Boolean): Boolean;
```
Internal helper method used to walk and hover a TRSEntity target.
You should not use this directly.

This is responsible for deciding wether we should walk to a TRSEntity target or not before attempting to hover it.
*)
function TRSEntity._WalkHoverHelper(attempts: Integer): Boolean;
var
  shouldExit: Boolean;
  attempt, i: Integer;
  atpa: T2DPointArray;
  coordinates, tpa, path: TPointArray;
  me, closest: TPoint;
begin
  Result := Self._UpTextCheck(shouldExit) or Self.Walker^.RedClicked;
  if shouldExit then Exit;

  for attempt := 0 to attempts do
  begin
    if Self.Find(coordinates, atpa) then
    begin
      if Length(coordinates) <> Length(atpa) then
        raise 'SOMETHING WENT WRONG CACHING COORDINATES.';

      if attempt < 2 then i := 0
      else if Length(atpa) > (attempt - 2) then i := attempt - 2
      else i := Random(Low(atpa), High(atpa));

      tpa := atpa[i];
      Self.LastCoordinate := coordinates[i];

      Mouse.Move(tpa.RandomMean());

      if Self.UpText = [] then Exit(True);
    end;

    if MainScreen.IsUpText(Self.UpText) then Exit(True);

    me := Self.Walker^.Position();
    closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

    if path = [] then
    begin
      path := Self.Walker^.WebGraph^.FindObjectPath(me, closest);
      if path = [] then
        raise GetDebugLn('TRSEntity', 'Can''t path to object.');
    end;

    if me.DistanceTo(closest) > 50 then
    begin
      Self.Walker^.WebWalkEx(me, closest, 30, 0.15);
      Continue;
    end;

    if attempt <> (attempts - 1) then Continue;

    if me.DistanceTo(closest) > 25 then
    begin
      Self.Walker^.WebWalkEx(me, closest, 25, 0.15);
      Continue;
    end;

    Minimap.SetCompassAngle(Minimap.GetCompassAngle(), 50);
  end;
end;

(*
## TRSEntity._PreHoverHelper
```pascal
function TRSEntity.PreHoverHelper(attempts: Integer): Boolean;
```
Internal helper method used to pre-hover a TRSEntity target.
You should not use this directly.
*)
function TRSEntity._PreHoverHelper(me: TPoint; attempts: Integer = 2): Boolean;
var
  attempt: Integer;
  atpa: T2DPointArray;
begin
  for attempt := 0 to attempts do
  begin
    if not Self.FindFrom(me, atpa) then Continue;
    AsyncMouse.Move(atpa.Random().Random());
    Exit(True);
  end;
end;


(*
## TRSEntity._ClickHelper
```pascal
function TRSEntity._ClickHelper(leftClick: Boolean): Boolean;
```
Internal TRSEntity helper method that is used by other clicking methods.
You probably don't need to use this directly.

This is what's responsible for deciding if we click a target we are hovering or not.
*)
function TRSEntity._ClickHelper(leftClick: Boolean): Boolean;
begin
  Self.Walker^.TargetUpText := [];
  Self.Walker^.ActionUpText := [];

  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Select(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
    Exit;
  end;

  if leftClick and Biometrics.RedClick(EMouseButton.LEFT, 2) then
    Exit(True);

  Result := not leftClick and (Self.UpText <> []) and ChooseOption.Select(Self.UpText);
end;

(*
## TRSEntity._SelectHelper
```pascal
function TRSEntity._SelectHelper(action: TStringArray): Boolean;
```
Internal TRSEntity helper method that is used by other select methods.
You probably don't need to use this directly.

This is what is responsible for deciding if we just left click a target we are hovering or right click it and choose an option.
*)
function TRSEntity._SelectHelper(action: TStringArray): Boolean;
begin
  Self.Walker^.TargetUpText := [];
  Self.Walker^.ActionUpText := [];

  if Self.Walker^.RedClicked then
  begin
    Self.Walker^.RedClicked := False;
    Exit(True);
  end;

  if ChooseOption.IsOpen() and ChooseOption.Select(action) then
    Exit(True);

  if MainScreen.IsUpText(action) then
    Exit(Biometrics.RedClick(EMouseButton.LEFT, 2));

  Result := ChooseOption.Select(action);
end;


(*
## TRSEntity.Hover
```pascal
function TRSEntity.Hover(attempts: Integer = 2; trackTarget: Boolean = TRSEntity.TrackTarget): Boolean;
```
Method used to hover a TRSEntity target if it's found on the mainscreen.
It can update the target position while the mouse moves with **trackTarget**.

Example:
```pascal
RSW.WebWalk(WaspWeb.LOCATION_VARROCK);
RSObjects.GEBank.Hover(); //Be in GE with a walker setup there.
```
*)
function TRSEntity.Hover(attempts: Integer = 2): Boolean;
begin
  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Find(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  //TODO:
  //if not Self.Walker^.MakePointVisible(Self.Coordinates) then Exit;

  Result := Self._HoverHelper(attempts);
end;

(*
## TRSEntity.WalkHover
```pascal
function TRSEntity.WalkHover(attempts: Integer = 2; trackTarget: Boolean = TRSEntity.TrackTarget): Boolean;
```
Method used to walk and hover a TRSEntity target if it's found on the mainscreen after walking.
It can update the target position while the mouse moves with **trackTarget**.

Example:
```pascal
//Be in varrock with a varrock map loaded.
RSW.WebWalk(WaspWeb.LOCATION_VARROCK);
RSObjects.GEBank.WalkHover();
```
*)
function TRSEntity.WalkHover(attempts: Integer = 2): Boolean;
var
  me, closest: TPoint;
  path: TPointArray;
  hasPath: Boolean;
begin
  if ChooseOption.IsOpen() then
  begin
    if (Self.UpText <> []) and ChooseOption.Find(Self.UpText) then
      Exit(True);
    ChooseOption.Close();
  end;

  if Self.UpText <> [] then
    Self.Walker^.TargetUpText := Copy(Self.UpText);

  me :=  Self.Walker^.Position();
  closest := Self.Walker^.GetClosestPoint(me, Self.Coordinates, path);

  //if the point is not reachable with the webgraph (like a banker behind a booth) then pick nearest node as target
  if path = [] then
  begin
    path := Self.Walker^.WebGraph^.FindObjectPath(me, closest);
    if path = [] then
      raise GetDebugLn('TRSEntity', 'Can''t path to object.');
    hasPath := True;
  end;

  // check if doors need to be passed to reach target
  if hasPath or Self.Walker^.WebGraph^.WalkableClusters.InSameTPA(me, closest) then
  begin
    if not Self.Walker^.MakePointVisible(closest) and not Self.Walker^.WebWalkEx(me, closest, 30, 0.15) then
      Exit;
  end
  else
  if not Self.Walker^.WebWalk(closest, 30, 0.15) then
    Exit;

  Result := Self._WalkHoverHelper(attempts);
end;


(*
## TRSEntity.Click
```pascal
function TRSEntity.Click(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
```
Method used to click a TRSEntity target if it's found on the mainscreen.

Example:
```pascal
//Be in ge with a ge map loaded.
WriteLn RSObjects.GEBank.Click();
```
*)
function TRSEntity.Click(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  Result := Self.Hover(attempts) and Self._ClickHelper(leftClick);
end;

(*
## TRSEntity.SelectOption
```pascal
function TRSEntity.SelectOption(action: TStringArray; attempts: Integer = 2): Boolean;
```
Method used to select an option on a TRSEntity target if it's found on the mainscreen.

Example:
```pascal
//Be in ge with a ge map loaded.
WriteLn RSObjects.GEBank.SelectOption(['Collect']);
```
*)
function TRSEntity.Select(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  Self.Walker^.ActionUpText := action;
  Result := Self.Hover(attempts) and Self._SelectHelper(action);
  Self.Walker^.ActionUpText := [];
end;

(*
## TRSEntity.WalkClick
```pascal
function TRSEntity.WalkClick(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
```
Method used to walk and click a TRSEntity target if it's found on the mainscreen.

Example:
```pascal
//Be in ge with a ge map loaded, preferably far away so it has to walk.
WriteLn RSObjects.GEBank.WalkClick();
```
*)
function TRSEntity.WalkClick(leftClick: Boolean = True; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  Result := Self.WalkHover(attempts) and Self._ClickHelper(leftClick);
  Self.Walker^.TargetUpText := [];
end;

(*
## TRSEntity.WalkSelectOption
```pascal
function TRSEntity.WalkSelectOption(action: TStringArray; attempts: Integer = 2): Boolean;
```
Method used to walk and select an option on a TRSEntity target if it's found on the mainscreen.

Example:
```pascal
//Be in ge with a ge map loaded, preferably far away so it has to walk.
WriteLn RSObjects.GEBank.WalkSelectOption(['Collect']);
```
*)
function TRSEntity.WalkSelect(action: TStringArray; attempts: Integer = 2): Boolean;
begin
  if Self.Walker = nil then
    raise GetDebugLn('TRSEntity', 'Missing the walker pointer.');
  if Self.Coordinates = [] then
    raise GetDebugLn('TRSEntity', 'FindFrom requires the object to have coordinates.');

  Self.Walker^.ActionUpText := action;

  Result := Self.WalkHover(attempts) and Self._SelectHelper(action);

  Self.Walker^.TargetUpText := [];
  Self.Walker^.ActionUpText := [];
end;


function TRSEntity.DistanceTo(pt: TPoint): Double;
var
  dist: Double;
  i: Integer;
begin
  Result := $FFFFFF;
  for i := 0 to High(Self.Coordinates) do
  begin
    dist := Self.Coordinates[i].DistanceTo(pt);
    if dist < Result then
      Result := dist;
  end;
end;

function TRSEntityArray.ClosestIndex(pt: TPoint): Integer;
var
  closest, dist: Double;
  i, j: Integer;
begin
  closest := $FFFFFF;
  for i := 0 to High(Self) do
    for j := 0 to High(Self[i].Coordinates) do
    begin
      dist := Self[i].Coordinates[j].DistanceTo(pt);
      if dist >= closest then Continue;

      closest := dist;
      Result := i;
    end;
end;

(*
## TImage.DrawEntity
```pascal
procedure TImage.DrawEntity(npc: TRSEntity);
```
Helper method to debug TRSEntity.
*)
procedure TImage.DrawEntity(entity: TRSEntity);
var
  me: TPoint;
  atpa: T2DPointArray;
  cuboids: TCuboidArray;
  i: Integer;
  filters: TRSDotFilterArray;
  filter: TRSDotFilter;
  coordinates: TPointArray;
begin
  me := entity.Walker^.Position();
  filters := entity.Walker^.FiltersToMM(me, entity.Filter, Minimap.GetCompassAngle(False));

  for filter in filters do
  begin
    if not Minimap.Bounds.Overlap(filter.Poly.Bounds()) and
       not Minimap.Bounds.Overlap(filter.Circle.Bounds) then Continue;

    if filter.Inside then
      Self.DrawColor := $00FF00
    else
      Self.DrawColor := $0000FF;

    Self.DrawPolygon(filter.Poly);
    Self.DrawCircle(filter.Circle);
  end;

  if not entity.FindEx(me, cuboids, coordinates, atpa) then
    Exit;

  Self.DrawColor := $00FFFF;
  for i := 0 to High(cuboids) do
  begin
    Self.DrawTPA(cuboids[i].Bottom.Corners.Connect().Grow(1));
    Self.DrawTPA(cuboids[i].Top.Corners.Connect().Grow(1));
  end;

  Self.DrawColor := TColor.Random();
  Self.DrawATPA(atpa);

  Self.DrawColor := $FFFFFF;
  for i := 0 to High(cuboids) do
    Self.DrawTPA(cuboids[i].Edges());
end;

procedure ShowOnTarget(entity: TRSEntity); overload;
var
  img: TImage;
begin
  img := Target.GetImage();
  img.DrawEntity(entity);
  img.Show();
end;


function ToString(constref entity: TRSEntity): String; override;
begin
  Result := '[' + ToString(entity.UpText) + ', ' +
                  ToString(entity.Size) + ', ' +
                  ToString(entity.Coordinates) + ', ' +
                  ToString(entity.Finder) + ', ' +
                  ToString(entity.MinimapDots) + ', ' +
                  ToString(entity.Track) + ']';
end;
