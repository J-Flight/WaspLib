(*
# Map JSONs
Utilities to help load and parse json files related to {ref}`Map`.
*)
{$DEFINE WL_MAPJSON_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
  EMapJSON = enum(OBJECTS, NPCS);

  TMapJSON = record
    Data: TJSONArray;
    Version, CacheDir: String;
    Unzipping: Boolean;
    Timeout: TCountDown;
    Typ: EMapJSON;
    const ZIP: String = WLEnv.AssetsDir + 'map' + PATH_SEP;
  end;

procedure TMapJSON.Unzipped(constref result: TASyncUnzipResult);
var
  name, msg: String;
begin
  if not result.Success then
  begin
    DirDelete(Self.CacheDir, False);
    raise GetDebugLn('MapJSON', result.Exception);
  end;
  name := PathExtractName(result.ZipFile);
  msg := 'Finished async unzip of ' +  name + ' in ' + ToStr(Round(result.TimeUsed, 2)) + 'ms.';
  WriteLn GetDebugLn('MapJSON', msg, ELogLevel.SUCCESS);
  Self.Unzipping := False;
end;

procedure TMapJSON.Setup(typ: EMapJSON);
var
  path, tmp, filename: String;
begin
  Self.Typ := typ;
  case Self.Typ of
    EMapJSON.OBJECTS:
    begin
      Self.Version := WLAssets.JSON.Item['map/objects.zip'].AsString;
      Self.CacheDir := WLEnv.CacheDir + 'map' + PATH_SEP + 'objects' + PATH_SEP;
      filename := Self.ZIP + 'objects.zip';
    end;
    EMapJSON.NPCS:
    begin
      Self.Version := WLAssets.JSON.Item['map/npcs.zip'].AsString;
      Self.CacheDir := WLEnv.CacheDir + 'map' + PATH_SEP + 'npcs' + PATH_SEP;
      filename := Self.ZIP + 'npcs.zip';
    end;
  end;
  //Delete old cache files if they exist
  for path in DirList(Self.CacheDir) do
  begin
    tmp := Copy(path, Length(path) - Length(Self.Version) + 1, Length(path));
    if tmp = Self.Version then Continue;
    DirDelete(path, False);
  end;

  Self.CacheDir += Self.Version + PATH_SEP;

  if not DirCreate(Self.CacheDir) then
    raise GetDebugLn('MapJSON', 'Failed to create cache directory: ' + Self.CacheDir);

  Self.Data := new TJSONArray();
  if not DirIsEmpty(Self.CacheDir) then
    Exit;

  Self.Unzipping := True;
  Self.Timeout.Start(ONE_MINUTE);
  Async.FileUnZip(filename, Self.CacheDir, @Self.Unzipped);
end;

(*
## MapJSON.GetFile
```pascal
function MapJSON.GetFile(cachedir: String; chunk: TPoint; plane: Integer): TJSONArray;
```
Internal function to return a `JSONArray` of objects or npcs associated with the
specified `chunk` and `plane`.
*)
function TMapJSON.GetFile(cacheDir: String; chunk: TPoint; plane: Integer): TJSONArray;
var
  filename, cachename: String;
begin
  filename := ToStr(plane) + '-' + ToStr(chunk.X) + '-' + ToStr(chunk.Y) + '.json';
  cachename := cacheDir + filename;

  if not FileExists(cachename) then
    Exit(nil);

  Result := new TJSONArray();
  TJSONParser(Result).Load(cachename);
end;

(*
## MapJSON.Load
```pascal
procedure TMapJSON.Load(regions: array of TRSMapRegion = []);
```
Internal method to load all objects or npcs JSON data associated with the
specified `regions` merged into a single `TJSONArray`.
*)
procedure TMapJSON.Load(regions: array of TRSMapRegion = []);
var
  region: TRSMapRegion;
  json: TJSONArray;
  i, idx: Integer;
begin
  if regions = [] then
    regions := Map.Loader.Regions;

  for region in regions do
    for i := 0 to High(region.Chunks) do
    begin
      json := Self.GetFile(Self.CacheDir, region.Chunks[i], region.Plane);
      if json = nil then Continue;
      for idx := 0 to json.Count - 1 do
        Self.Data.AddObject('data', json.Item[idx].Clone());
    end;
end;


(*
## MapJSON.GetByName
```pascal
function TMapJSON.GetByName(name: String; amount: Integer = 0): TJSONArray;
```
Returns a `TJSONArray` of `JSONObjects` of a map object or npc that matches the
specified `name`.

By default you get all entries that match the `name`, however, if you want you
can specify how many unique IDs you want through `amount`.
*)
function TMapJSON.GetByName(name: String; amount: Integer = 0): TJSONArray;
var
  i, idx, id: Integer;
  ids: TIntegerArray;
begin
  if Self.Data.Count = 0 then
    Self.Load();

  Result := new TJSONArray();
  for i := 0 to Self.Data.Count-1 do
    if Self.Data.Item[i].Item['name'].AsString = name then
    begin
      idx := i;
      Result.AddObject('result', Self.Data.Item[idx].Clone());
      id := Self.Data.Item[idx].Item['id'].AsInt;
      if not ids.Contains(id) then
      begin
        ids += id;
        if Length(ids) = amount then
          Break;
      end;
    end;

  if ids = [] then
    raise GetDebugLn('MapJSON', 'Entry with name ' + name + ' doesn''t exist on the loaded maps.');

  if amount = 0 then
    Exit;

  for i := idx+1 to Self.Data.Count - 1 do
    if Self.Data.Item[i].Item['id'].AsInt in ids then
      Result.AddObject('result', Self.Data.Item[i].Clone());
end;

(*
## MapJSON.GetByID
```pascal
function TMapJSON.GetByID(id: Integer): TJSONObject;
```
Returns a `TJSONObject` of a map object that matches the specified `id`.
*)
function TMapJSON.GetByID(id: Integer): TJSONObject;
var
  i, idx: Integer;
begin
  if Self.Data.Count = 0 then
    Self.Load();

  idx := -1;
  for i := 0 to Self.Data.Count - 1 do
    if Self.Data.Item[i].Item['id'].AsInt = id then
    begin
      idx := i;
      Break;
    end;

  if idx = -1 then
    raise GetDebugLn('MapJSON', 'Entry with ID ' + ToStr(id) + ' doesn''t exist on the loaded maps.');

  Result := Self.Data.Item[idx].Clone();

  for i := idx+1 to Self.Data.Count - 1 do
    if Self.Data.Item[i].Item['id'].AsInt = id then
      for idx := 0 to Self.Data.Item[i].Item['coordinates'].Count - 1 do
      begin
        Result.Item['coordinates'].AddArray(
          'coordinate',
          Self.Data.Item[i].Item['coordinates'].Item[idx].Clone()
        );
      end;
end;

(*
## MapJSON.GetByAction
```pascal
function TMapJSON.GetByAction(action: String; amount: Integer = 0): TJSONArray;
```
Returns a `TJSONArray` of `JSONObjects` of a map object or npc that has an
action that matches the specified `action`.

By default you get all entries that match the `action`, however, if you want
you can specify how many unique IDs you want through `amount`.
*)
function TMapJSON.GetByAction(action: String; amount: Integer = 0): TJSONArray;
var
  i, j, idx, id: Integer;
  ids: TIntegerArray;
begin
  if Self.Data.Count = 0 then
    Self.Load();

  Result := new TJSONArray();
  for i := 0 to Self.Data.Count-1 do
    for j := 0 to Self.Data.Item[i].Item['actions'].Count-1 do
      if Self.Data.Item[i].Item['actions'].Item[j].AsString = action then
      begin
        idx := i;
        Result.AddObject('result', Self.Data.Item[idx].Clone());
        id := Self.Data.Item[idx].Item['id'].AsInt;
        if not ids.Contains(id) then
        begin
          ids += id;
          if Length(ids) = amount then
            Break(2);
        end;
        Break;
      end;

  if ids = [] then
    raise GetDebugLn('MapJSON', 'Entry with action ' + action + ' doesn''t exist on the loaded maps.');

  if amount = 0 then
    Exit;

  for i := idx+1 to Self.Data.Count - 1 do
    if Self.Data.Item[i].Item['id'].AsInt in ids then
      Result.AddObject('result', Self.Data.Item[i].Clone());
end;


procedure TMapJSON.Print();
begin
  if Self.Data.Count = 0 then
    Self.Load();
  WriteLn Self.Data.Format([EJSONFormatOption.NO_QUOTE_MEMBERS, EJSONFormatOption.SINGLE_LINE_ARR]);
end;

var
  ObjectsJSON, NPCsJSON: TMapJSON;
