(*
# RSCamera
*)
{$DEFINE WL_CAMERA_INCLUDED}
{$INCLUDE_ONCE WaspLib/osrs.simba}

type
(*
## TRSCamera
Record responsible of handling projection, similar to {ref}`MM2MS`.
*)
  TRSCamera = record
    X, Y, Z, Pitch, Yaw, Scale, MinScale, MaxScale, ZOffset: Integer;
    Player, Center, Camera, Offset, ViewportOffset, Origin: TPoint;
    Sines, Cosines: array [0..2047] of Int32;
    const MIN_PITCH: Integer = 128;
    const MAX_PITCH: Integer = 383;
  end;

procedure TRSCamera.Setup();
var
  i: Integer;
  percent: Double;
begin
  Self.Pitch := 383;

  for i := 0 to 2047 do
  begin
    Self.Sines[i]   := Round(65536*Sin(i*PI/1024));
    Self.Cosines[i] := Round(65536*Cos(i*PI/1024));
  end;

  Self.Player.X := 0;
  Self.Player.Y := 0;

  Self.Center.X := Self.Player.X;
  Self.Center.Y := Self.Player.Y;

  Self.X := Self.Player.X;

  case RSClient.Mode of
    ERSMode.FIXED:
    begin
      Self.Y := Self.Player.Y - 674;
      Self.ZOffset := -1650;
      Self.Offset := [4,4];
      Self.MinScale := 181;
      Self.MaxScale := 1448;
    end;
    ERSMode.RESIZABLE..ERSMode.MODERN_WIDE:
    begin
      Self.Y := Self.Player.Y - 842;
      Self.ZOffset := -2054;
      Self.Offset := [0,0];
      //scale increases with client height between 272 and 574 for min and 2180 and 4599 for max
      percent := (MainScreen.Bounds.Height - 503) / (1061-503);
      Self.MinScale := 272+Round((574-272) * percent);
      Self.MaxScale := 2180+Round((4599-2180) * percent);
    end;
  end;

  Self.Scale := Self.MinScale;

  Self.ViewportOffset.X := MainScreen.Bounds.Width div 2 + Self.Offset.X;
  Self.ViewportOffset.Y := MainScreen.Bounds.Height div 2 + Self.Offset.Y;
end;

procedure TRSCamera.SetPitch(value: Integer);
begin
  Self.Pitch := value;
  Self.Y := Self.Player.Y - 674 - Round(235 * (Self.MAX_PITCH - value) / (Self.MAX_PITCH - Self.MIN_PITCH));
end;

procedure TRSCamera.Update(zoom: Integer; rads: Double);
begin
  Self.Z := Self.ZOffset + Round(1237 * (Self.MAX_PITCH - Self.Pitch) / (Self.MAX_PITCH - Self.MIN_PITCH) - (zoom/100) * 75);
  Self.Yaw := Trunc((rads / TAU) * 2047);
  Self.Scale := Round(Self.MinScale + ZOOM2RSZOOM[zoom] * (Self.MaxScale-Self.MinScale));

  Self.Camera.X := Round(Self.Center.X + Cos(rads) * (Self.X - Self.Center.X) - Sin(rads) * (Self.Y - Self.Center.Y));
  Self.Camera.Y := Round(Self.Center.Y + Sin(rads) * (Self.X - Self.Center.X) + Cos(rads) * (Self.Y - Self.Center.Y));
  Self.Origin.X := Self.Camera.X - Self.Player.X;
  Self.Origin.Y := Self.Camera.Y - Self.Player.Y;
end;


function TRSCamera.MinimapOffset(constref coordinate: TVector3): TVector3;
begin
  Result.X := (coordinate.X-Minimap.Center.X)/4*128 - Self.Origin.X;
  Result.Y := (coordinate.Y-Minimap.Center.Y)/4*128 - Self.Origin.Y;
  Result.Z := -coordinate.Z/4*128 - Self.Z;
end;

function TRSCamera.Transform(constref coordinate: TVector3): TVector2;
var
  x1, y1, y2, z1, x, y, z: Int32;
  scale: Double;
begin
  x := Round(coordinate.X);
  y := Round(coordinate.Y);
  z := Round(coordinate.Z);

  y1 := Sar(y * Self.Cosines[Self.Yaw] - x * Self.Sines[Self.Yaw], 16);
  z1 := Sar(y1 * Self.Cosines[Self.Pitch] + z * Self.Sines[Self.Pitch], 16);

  if z1 < 50 then
    Exit;

  x1 := Sar(x * Self.Cosines[Self.Yaw] + y * Self.Sines[Self.Yaw], 16);
  y2 := Sar(z * Self.Cosines[Self.Pitch] - y1 * Self.Sines[Self.Pitch], 16);

  scale := Self.Scale / z1;
  Result.X := Self.ViewportOffset.X + x1 * scale;
  Result.Y := Self.ViewportOffset.Y + y2 * scale;
end;

function TRSCamera.RunEx(coordinates: TVector3Array): TVector2Array;
var
  i: Integer;
begin
  for i := 0 to High(coordinates) do
    Result += Self.Transform(Self.MinimapOffset(coordinates[i]));
end;

function TRSCamera.Run(coordinates: TVector3Array): TPointArray;
var
  i: Integer;
begin
  for i := 0 to High(coordinates) do
    Result += Self.Transform(Self.MinimapOffset(coordinates[i])).ToPoint();
end;

function TRSCamera.Run(coordinate: TVector3): TPoint; overload;
begin
  Result := Self.Run([coordinate]).First;
end;


function TRSCamera.ReverseMinimapOffset(constref transformed: TVector3): TVector3;
begin
  Result.X := (transformed.X + Self.Origin.X)*4/128 + Minimap.Center.X;
  Result.Y := (transformed.Y + Self.Origin.Y)*4/128 + Minimap.Center.Y;
  Result.Z := -(transformed.Z + Self.Z)*4/128;
end;

function TRSCamera.ReverseTransform(constref screen: TVector3): TVector3;
var
  x1, y1, y2, z1, x, y, z: Double;
begin
  z1 := screen.Z;

  x1 := (screen.X - Self.ViewportOffset.X) * z1 / Self.Scale;
  y2 := (screen.Y - Self.ViewportOffset.Y) * z1 / Self.Scale;

  y1 := (z1 * Self.Cosines[Self.Pitch] - y2 * Self.Sines[Self.Pitch]) / 65536;
  z  := (z1 * Self.Sines[Self.Pitch] + y2 * Self.Cosines[Self.Pitch]) / 65536;

  x := (x1 * Self.Cosines[Self.Yaw] - y1 * Self.Sines[Self.Yaw]) / 65536;
  y := (x1 * Self.Sines[Self.Yaw] + y1 * Self.Cosines[Self.Yaw]) / 65536;

  Result.X := x;
  Result.Y := y;
  Result.Z := z;
end;

function TRSCamera.ReverseRunEx(coordinates: TVector3Array): TVector2Array;
var
  i: Integer;
begin
  for i := 0 to High(coordinates) do
    Result += Self.ReverseMinimapOffset(Self.ReverseTransform(coordinates[i])).ToVec2();
end;

function TRSCamera.ReverseRun(coordinates: TVector3Array): TPointArray;
var
  i: Integer;
begin
  for i := 0 to High(coordinates) do
    Result += Self.ReverseMinimapOffset(Self.ReverseTransform(coordinates[i])).ToPoint();
end;

function TRSCamera.ReverseRun(coordinate: TVector3): TPoint; overload;
begin
  Result := Self.ReverseRun([coordinate]).First;
end;
