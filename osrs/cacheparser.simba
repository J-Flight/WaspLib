

{$DEFINE WL_CACHEPARSER_INCLUDED}
{$I WaspLib/osrs.simba}

type
  TIndexData = record
    Size: Integer;
    Sector: Integer;
  end;

  TIndex = record
    Sectors: Integer;
    Data: array of TIndexData;
  end;


  TRSCacheParser = record
    Disabled: Boolean;
    Directory: String;
    const IDX_FILE:  String = PATH_SEP + 'jagexcache' + PATH_SEP + 'oldschool' + PATH_SEP + 'LIVE' + PATH_SEP + 'main_file_cache.idx';
    const PREFERENCES:  String = PATH_SEP + 'jagexcache' + PATH_SEP + 'oldschool' + PATH_SEP + 'LIVE' + PATH_SEP + 'preferences.dat';
    const PREFERENCES2:  String = PATH_SEP + 'jagexcache' + PATH_SEP + 'oldschool' + PATH_SEP + 'LIVE' + PATH_SEP + 'preferences2.dat';
  end;


procedure TRSCacheParser.Setup();
var
  {$IFDEF WINDOWS}
  paths: TStringArray;
  {$ENDIF}
begin
  case RSClient.Client of
    ERSClient.LEGACY:
    begin
      {$IFDEF WINDOWS}
      paths := [GetEnvVar('ONEDRIVE'), GetEnvVar('USERPROFILE'), GetEnvVar('HOMEPATH')];

      for Self.Directory in paths do
        if FileExists(Self.Directory + Self.PREFERENCES) then Break;
      {$ELSE}
        Self.Directory := GetEnvVar('HOME');
      {$ENDIF}
    end;

    ERSClient.RUNELITE:
      Self.Directory := {$IFDEF WINDOWS} GetEnvVar('USERPROFILE') {$ELSE} GetEnvVar('HOME') {$ENDIF} + PATH_SEP + '.runelite';

    else
    begin
      Self.Disabled := True;
      Exit;
    end;
  end;

  if not FileExists(Self.Directory + Self.PREFERENCES) then
  begin
    Self.Disabled := True;
    Exit;
  end;
end;





function TRSCacheParser.ReadPreference(pref: Integer = 1): TByteArray;
begin
  case pref of
    1: Result := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);
    2: Result := OpenFileReadBytes(Self.Directory + Self.PREFERENCES2);
  end;
end;



function TRSCacheParser.CountOptions(bytes: TByteArray = []): Integer;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);
  if Length(bytes) > 0 then Result := bytes[0];
end;



function TRSCacheParser.RoofsHidden(bytes: TByteArray = []): Boolean;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);
  if Length(bytes) > 0 then Result := Boolean(bytes[1]);
end;


function TRSCacheParser.LoginMusicDisabled(bytes: TByteArray = []): Boolean;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);
  if Length(bytes) > 1 then Result := Boolean(bytes[2]);
end;


function TRSCacheParser.WindowMode(bytes: TByteArray = []): Integer;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);
  if Length(bytes) > 2 then Result := bytes[3];
end;



function TRSCacheParser.CountAuthenticators(bytes: TByteArray = []): Integer;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);
  if Length(bytes) > 4 then Result := bytes[4];
end;


function TRSCacheParser.GetAuthenticators(bytes: TByteArray = []): TStringArray;
var
  i, count: Int32;
  authStr: String;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);

  count := Self.CountAuthenticators(bytes);
  if count = 0 then Exit;

  SetLength(Result, count);
  SetLength(authStr, 8);

  for i := 0 to count - 1 do
  begin
    Move(bytes[5 + (i * 8)], authStr[1], 8);
    Result[i] := authStr;
  end;
end;


function TRSCacheParser.GetUsernameIndex(bytes: TByteArray = []): Integer;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);

  Result := 5 + Self.CountAuthenticators(bytes) * 8;
end;


function TRSCacheParser.GetUsername(bytes: TByteArray = []): String;
var
  i, startIdx: Int32;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);

  startIdx := Self.GetUsernameIndex(bytes);
  for i := startIdx to Length(bytes) do
  begin
    if bytes[i] = 0 then
      Break;
    Result += Char(bytes[i]);
  end;
end;


function TRSCacheParser.UsernameEndIndex(bytes: TByteArray = []): Int32;
var
  i: Int32;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);

  for i := Self.GetUsernameIndex(bytes) to Length(bytes) do
    if bytes[i] = 0 then
      Break;
  Result := i + 1;
end;


function TRSCacheParser.LoginHideUsername(bytes: TByteArray = []): Boolean;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);

  Result := Boolean(bytes[Self.UsernameEndIndex(bytes)]);
end;


function TRSCacheParser.Brightness(bytes: TByteArray = []): Integer;
var
  i: Int32;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);

  i := Self.UsernameEndIndex(bytes) + 1;
  if Length(bytes) >= i then
    Result := (Int32(bytes[i]) - 100) * -2;
end;


function TRSCacheParser.MusicVolume(bytes: TByteArray = []): Integer;
var
  i: Integer;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);

  i := Self.UsernameEndIndex(bytes) + 2;
  if Length(bytes) >= i then
    Result := Round(Integer(bytes[i]) / 2.55);
end;


function TRSCacheParser.SoundEffectsVolume(bytes: TByteArray = []): Integer;
var
  i: Integer;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);

  i := Self.UsernameEndIndex(bytes) + 3;
  if Length(bytes) >= i then
    Result := Round(Integer(bytes[i]) / 1.27);
end;


function TRSCacheParser.AreaSoundVolume(bytes: TByteArray = []): Integer;
var
  i: Integer;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);

  i := Self.UsernameEndIndex(bytes) + 4;
  if Length(bytes) >= i then
    Result := Round(Integer(bytes[i]) / 1.27);
end;


function TRSCacheParser.Field1247(bytes: TByteArray = []): Integer;
var
  i: Integer;
begin
  if bytes = [] then
    bytes := OpenFileReadBytes(Self.Directory + Self.PREFERENCES);

  i := Self.UsernameEndIndex(bytes) + 5;
  if Length(bytes) >= i then
    Result := Integer(bytes[i]);
end;





function TRSCacheParser.ReadMediumInt(const bytes: TByteArray; offset: Integer): Integer;
begin
  Result := (bytes[offset] shl 16) or (bytes[offset + 1] shl 8) or bytes[offset + 2]; //Read 3 byte big endian int
end;


function TRSCacheParser.DecodeIndexSector(const bytes: TByteArray; offset: Integer): TIndexData;
begin
  Result.Size := Self.ReadMediumInt(bytes, offset);
  Result.Sector := Self.ReadMediumInt(bytes, offset + 3);
end;


function TRSCacheParser.ReadIndex(idx: Integer): TIndex;
var
  bytes: TByteArray;
  i: Integer;
begin
  bytes := OpenFileReadBytes(Self.Directory + Self.IDX_FILE + ToStr(idx));

  Result.Sectors := Length(bytes) div 6;
  for i := 0 to Result.Sectors - 1 do
    Result.Data += Self.DecodeIndexSector(bytes, i * 6);
end;

var

  RSCacheParser: TRSCacheParser;
