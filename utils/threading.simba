

{$DEFINE WL_THREADING_INCLUDED}

type

  PThreadTask = ^TThreadTask;

  PThreadWorker = ^TThreadWorker;

  PThreadPool = ^TThreadPool;


  EDebugLevel = enum(NONE, INFO, VERBOSE);


  TOnException = procedure(const TaskName, Error: String) of object;

  TOnComplete = procedure(const TaskName: String; Success: Boolean) of object;


  TThreadTask = record
    ID: String;
    Method: procedure() of object;
    Priority: Integer;
    Created: Int64;
    Next: PThreadTask;
  end;


  TThreadWorker = record
    ID: Integer;
    Name: String;
    Thread: TThread;
    Pool: PThreadPool;
    Active: Boolean;
    Busy: Boolean;
    Processed: Integer;
    WaitTimeMS: Integer;
    MaxWaitTimeMS: Integer;
    LastActive: Int64;
  end;


  TTaskQueue = record
    Head: PThreadTask;
    Tail: PThreadTask;
    Count: Integer;
    Lock: TLock;
  end;


  TThreadPool = record
    Name: String;
    Workers: array of TThreadWorker;
    Queue: TTaskQueue;
    LogLock: TLock;
    Running: Boolean;
    Terminating: Boolean;
    ShuttingDown: Boolean;
    DebugLevel: EDebugLevel;
    TasksQueued: Integer;
    TasksProcessed: Integer;
    TasksFailed: Integer;
    StartTime: Int64;
    MinWorkerCount: Integer;
    MaxWorkerCount: Integer;
    DefaultWorkerWaitMS: Integer;
    DefaultWorkerMaxWaitMS: Integer;
    OnException: TOnException;
    OnComplete: TOnComplete;
  end;


  TScheduledTask = record
    ID: String;
    Method: procedure() of object;
    Interval: Integer;
    LastRun: Int64;
    Active: Boolean;
  end;
  TScheduledTaskArray = array of TScheduledTask;


  TThreadScheduler = record
    Pool: TThreadPool;
    Tasks: TScheduledTaskArray;
    Thread: TThread;
    Running: Boolean;
    SleepIntervalMS: Integer;
  end;


  TThreadManager = record
    Pool: TThreadPool;
    Scheduler: TThreadScheduler;
    IsSetup: Boolean;
    DebugLevel: EDebugLevel;
    ThreadCount: Integer;
    ExceptionHandler: TOnException;
    CompletionHandler: TOnComplete;
  end;


procedure TTaskQueue.Init();
begin
  Self.Head := nil;
  Self.Tail := nil;
  Self.Count := 0;
  Self.Lock := TLock.Create();
end;


procedure TTaskQueue.Free();
begin
  Self.Clear();
  if Assigned(Self.Lock) then
  begin
    Self.Lock.Free();
    Self.Lock := nil;
  end;
end;


procedure TTaskQueue.Add(Task: PThreadTask);
var
  Current, Previous: PThreadTask;
begin
  if Task = nil then
    Exit;

  Self.Lock.Enter();
  try
    Task^.Next := nil;

    if (Self.Head = nil) or (Task^.Priority > Self.Head^.Priority) then
    begin
      Task^.Next := Self.Head;
      Self.Head := Task;
      if Self.Tail = nil then
        Self.Tail := Task;
    end
    else
    begin
      Previous := Self.Head;
      Current := Self.Head^.Next;
      while (Current <> nil) and (Task^.Priority <= Current^.Priority) do
      begin
        Previous := Current;
        Current := Current^.Next;
      end;

      Previous^.Next := Task;
      Task^.Next := Current;

      if Current = nil then
        Self.Tail := Task;
    end;

    Inc(Self.Count);
  finally
    Self.Lock.Leave();
  end;
end;


function TTaskQueue.Get(): PThreadTask;
begin
  Result := nil;
  Self.Lock.Enter();
  try
    if Self.Head <> nil then
    begin
      Result := Self.Head;
      Self.Head := Result^.Next;

      if Self.Head = nil then
        Self.Tail := nil;

      Result^.Next := nil;
      Dec(Self.Count);
    end;
  finally
    Self.Lock.Leave();
  end;
end;


function TTaskQueue.IsEmpty(): Boolean;
begin
  Self.Lock.Enter();
  try
    Result := (Self.Head = nil);
  finally
    Self.Lock.Leave();
  end;
end;


procedure TTaskQueue.Clear();
var
  Task: PThreadTask;
begin
  Self.Lock.Enter();
  try
    while Self.Head <> nil do
    begin
      Task := Self.Head;
      Self.Head := Task^.Next;
      Dispose(Task);
    end;

    Self.Tail := nil;
    Self.Count := 0;
  finally
    Self.Lock.Leave();
  end;
end;


procedure TThreadWorker.Execute();
var
  Task: PThreadTask;
begin
  Self.Pool^.Log(EDebugLevel.VERBOSE, Format('Worker %d (%s) started', [Self.ID, Self.Name]));
  Self.Active := True;
  Self.LastActive := Time();
  Self.WaitTimeMS := 1;

  while Self.Pool^.Running and not Self.Pool^.Terminating do
  begin
    Task := Self.Pool^.GetTask();

    if Task <> nil then
    begin
      Self.Busy := True;
      Self.WaitTimeMS := 1;
      Self.Pool^.Log(EDebugLevel.VERBOSE, Format('Worker %d processing task: %s', [Self.ID, Task^.ID]));
      Self.Pool^.ProcessTask(Task, Self.ID);
      Self.Busy := False;
      Inc(Self.Processed);
      Self.LastActive := Time();
    end
    else
    begin
      System.Sleep(Self.WaitTimeMS);
      if Self.WaitTimeMS < Self.MaxWaitTimeMS then
        Self.WaitTimeMS := Self.WaitTimeMS * 2;
    end;
  end;

  Self.Pool^.Log(EDebugLevel.VERBOSE, Format('Worker %d (%s) stopped', [Self.ID, Self.Name]));
  Self.Active := False;
end;


procedure TThreadPool.Log(Level: EDebugLevel; const Msg: String);
begin
  if Self.DebugLevel >= Level then
  begin
    Self.LogLock.Enter();
    try
      WriteLn(Format('[%s] %s', [Self.Name, Msg]));
    finally
      Self.LogLock.Leave();
    end;
  end;
end;


function TThreadPool.GetDefaultThreadCount(): Integer;
begin
  Result := CPUInfo.ThreadCount;
  if Result < Self.MinWorkerCount then
    Result := Self.MinWorkerCount;
  if Result > Self.MaxWorkerCount then
    Result := Self.MaxWorkerCount;
end;


procedure TThreadPool.Init(const PoolName: String; ThreadCount: Integer = 0; DebugLevel: EDebugLevel = EDebugLevel.NONE);
var
  i: Integer;
begin
  Self.Name := PoolName;
  Self.DebugLevel := DebugLevel;

  if Self.MinWorkerCount <= 0 then
    Self.MinWorkerCount := 2;

  if Self.MaxWorkerCount <= 0 then
    Self.MaxWorkerCount := 16;

  if Self.DefaultWorkerWaitMS <= 0 then
    Self.DefaultWorkerWaitMS := 1;

  if Self.DefaultWorkerMaxWaitMS <= 0 then
    Self.DefaultWorkerMaxWaitMS := 50;

  Self.LogLock := TLock.Create();

  if ThreadCount <= 0 then
    ThreadCount := Self.GetDefaultThreadCount();

  Self.Log(EDebugLevel.INFO, Format('Initializing with %d workers', [ThreadCount]));

  Self.Queue.Init();
  SetLength(Self.Workers, ThreadCount);

  Self.Running := True;
  Self.Terminating := False;
  Self.ShuttingDown := False;
  Self.StartTime := Time();
  Self.TasksProcessed := 0;
  Self.TasksQueued := 0;
  Self.TasksFailed := 0;

  for i := 0 to High(Self.Workers) do
  begin
    Self.Workers[i].ID := i;
    Self.Workers[i].Name := Format('%s-Worker-%d', [PoolName, i]);
    Self.Workers[i].Pool := @Self;
    Self.Workers[i].Active := False;
    Self.Workers[i].Busy := False;
    Self.Workers[i].Processed := 0;
    Self.Workers[i].WaitTimeMS := Self.DefaultWorkerWaitMS;
    Self.Workers[i].MaxWaitTimeMS := Self.DefaultWorkerMaxWaitMS;
    Self.Workers[i].Thread := TThread.Create(@Self.Workers[i].Execute);
    Self.Workers[i].Thread.Name := Self.Workers[i].Name;
  end;
end;


procedure TThreadPool.Shutdown(TimeoutMS: Integer = 30000);
var
  StartTime: Int64;
  i: Integer;
begin
  if Self.Terminating then
    Exit;

  Self.Log(EDebugLevel.INFO, Format('Starting shutdown (timeout: %dms)', [TimeoutMS]));
  Self.ShuttingDown := True;

  StartTime := Time();
  while (Self.BusyWorkers() > 0) and ((Time() - StartTime) < TimeoutMS) do
    Sleep(100);

  if Self.BusyWorkers() > 0 then
    Self.Log(EDebugLevel.INFO, Format('Timeout reached, forcing shutdown with %d busy workers', [Self.BusyWorkers()]));

  Self.Log(EDebugLevel.INFO, 'Stopping workers');
  Self.Terminating := True;
  Self.Running := False;

  for i := 0 to High(Self.Workers) do
    if Assigned(Self.Workers[i].Thread) then
    begin
      Self.Workers[i].Thread.WaitForTerminate();
      Self.Workers[i].Thread.Free();
      Self.Workers[i].Thread := nil;
    end;

  Self.Log(EDebugLevel.INFO, 'All workers terminated');
end;


procedure TThreadPool.Free();
begin
  if not Self.Terminating then
    Self.Shutdown(5000);

  Self.Log(EDebugLevel.VERBOSE, 'Pool resources freed');

  Self.Queue.Clear();
  Self.Queue.Free();
  SetLength(Self.Workers, 0);

  if Assigned(Self.LogLock) then
  begin
    Self.LogLock.Free();
    Self.LogLock := nil;
  end;
end;


function TThreadPool.ValidateTask(const TaskID: String; Method: procedure() of object): String;
begin
  Result := '';
  if TaskID = '' then
    Result := 'Task ID cannot be empty'
  else if not Assigned(@Method) then
    Result := 'Method not assigned';
end;


function TThreadPool.HasPendingTask(const TaskID: String): Boolean;
var
  Current: PThreadTask;
begin
  Result := False;
  Self.Queue.Lock.Enter();
  try
    Current := Self.Queue.Head;
    while Current <> nil do
    begin
      if Current^.ID = TaskID then
      begin
        Result := True;
        Break;
      end;
      Current := Current^.Next;
    end;
  finally
    Self.Queue.Lock.Leave();
  end;
end;


function TThreadPool.Submit(const TaskID: String; Method: procedure() of object; Priority: Integer = 0; AllowDuplicates: Boolean = False): Boolean;
var
  NewTask: PThreadTask;
  ValidationError: String;
begin
  Result := False;

  ValidationError := Self.ValidateTask(TaskID, @Method);
  if ValidationError <> '' then
  begin
    Self.Log(EDebugLevel.INFO, Format('Task validation failed: %s', [ValidationError]));
    if Assigned(@Self.OnException) then
      Self.OnException(TaskID, 'Task validation failed: ' + ValidationError);
    Exit;
  end;

  if Self.Terminating or not Self.Running or Self.ShuttingDown then
  begin
    Self.Log(EDebugLevel.INFO, Format('Cannot submit task "%s" - pool is shutting down', [TaskID]));
    Exit;
  end;

  // Check for duplicates unless explicitly allowed
  if not AllowDuplicates and Self.HasPendingTask(TaskID) then
  begin
    Self.Log(EDebugLevel.VERBOSE, Format('Task "%s" already pending - skipping duplicate', [TaskID]));
    Exit;
  end;

  New(NewTask);
  NewTask^.ID := TaskID;
  NewTask^.Method := @Method;
  NewTask^.Priority := Priority;
  NewTask^.Created := Time();
  NewTask^.Next := nil;

  Self.Queue.Add(NewTask);
  Inc(Self.TasksQueued);
  Result := True;
  Self.Log(EDebugLevel.INFO, Format('Task "%s" submitted with priority %d', [TaskID, Priority]));
end;


function TThreadPool.GetTask(): PThreadTask;
begin
  Result := Self.Queue.Get();
end;


procedure TThreadPool.ProcessTask(Task: PThreadTask; WorkerID: Integer);
var
  Success: Boolean;
  Error: String;
  StartTime, ExecutionTime: Int64;
begin
  Success := True;
  Error := '';
  StartTime := Time();

  try
    if Assigned(@Task^.Method) then
      Task^.Method()
    else
    begin
      Success := False;
      Error := 'Method not assigned';
    end;
  except
    Success := False;
    Error := GetExceptionMessage();
  end;

  ExecutionTime := Time() - StartTime;

  if Success then
    Self.Log(EDebugLevel.VERBOSE, Format('Worker %d completed task "%s" in %dms', [WorkerID, Task^.ID, ExecutionTime]))
  else
  begin
    Self.Log(EDebugLevel.INFO, Format('Worker %d FAILED task "%s" in %dms: %s', [WorkerID, Task^.ID, ExecutionTime, Error]));
    Inc(Self.TasksFailed);
  end;

  if Assigned(@Self.OnComplete) then
    Self.OnComplete(Task^.ID, Success);

  if not Success and Assigned(@Self.OnException) then
    Self.OnException(Task^.ID, Format('%s [Task: %s, Worker: %d, Duration: %dms]', [Error, Task^.ID, WorkerID, ExecutionTime]));

  Inc(Self.TasksProcessed);
  Dispose(Task);
end;


function TThreadPool.QueueSize(): Integer;
begin
  Result := Self.Queue.Count;
end;


function TThreadPool.ActiveWorkers(): Integer;
var
  i: Integer;
begin
  Result := 0;
  for i := 0 to High(Self.Workers) do
    if Self.Workers[i].Active then
      Inc(Result);
end;


function TThreadPool.BusyWorkers(): Integer;
var
  i: Integer;
begin
  Result := 0;
  for i := 0 to High(Self.Workers) do
    if Self.Workers[i].Busy then
      Inc(Result);
end;


procedure TThreadPool.Await(TimeoutMS: Integer = 30000);
var
  StartTime: Int64;
begin
  StartTime := Time();
  Self.Log(EDebugLevel.INFO, 'Awaiting task completion');

  while ((Self.QueueSize() > 0) or (Self.BusyWorkers() > 0)) and ((Time() - StartTime) < TimeoutMS) do
    System.Sleep(10);

  if (Time() - StartTime) >= TimeoutMS then
    Self.Log(EDebugLevel.INFO, 'Await timed out')
  else
    Self.Log(EDebugLevel.INFO, 'All tasks completed');
end;


function TThreadPool.GetStats(): String;
var
  Runtime: Int64;
  SuccessRate: Double;
begin
  Runtime := Time() - Self.StartTime;

  if Self.TasksProcessed > 0 then
    SuccessRate := ((Self.TasksProcessed - Self.TasksFailed) * 100.0) / Self.TasksProcessed
  else
    SuccessRate := 100.0;

  Result := Format('[%s] Workers: %d (Active: %d, Busy: %d) | Tasks: %d processed (%d failed, %.1f%% success) | Queue: %d | Runtime: %dms',
                   [Self.Name, Length(Self.Workers), Self.ActiveWorkers(), Self.BusyWorkers(),
                    Self.TasksProcessed, Self.TasksFailed, SuccessRate, Self.QueueSize(), Runtime]);
end;


procedure TThreadPool.ResetStats();
begin
  Self.TasksProcessed := 0;
  Self.TasksQueued := 0;
  Self.TasksFailed := 0;
  Self.StartTime := Time();
end;


procedure TThreadScheduler.Loop();
var
  i: Integer;
  CurrentTime: Int64;
  TaskID: String;
begin
  while Self.Running do
  begin
    CurrentTime := Time();

    for i := 0 to High(Self.Tasks) do
      if Self.Tasks[i].Active and
         ((CurrentTime - Self.Tasks[i].LastRun) >= Self.Tasks[i].Interval) then
      begin
        TaskID := Format('%s-%d', [Self.Tasks[i].ID, CurrentTime]);

        // Check if previous execution is still running (optional overlap prevention)
        if not Self.Pool.HasPendingTask(Self.Tasks[i].ID) then
        begin
          Self.Pool.Log(EDebugLevel.INFO, Format('Submitting recurring task "%s" (Interval: %dms)', [Self.Tasks[i].ID, Self.Tasks[i].Interval]));
          // Use base task ID without timestamp for overlap detection
          Self.Pool.Submit(Self.Tasks[i].ID, @Self.Tasks[i].Method);
          Self.Tasks[i].LastRun := CurrentTime;
        end
        else
          Self.Pool.Log(EDebugLevel.VERBOSE, Format('Skipping task "%s" - previous execution still running', [Self.Tasks[i].ID]));
      end;

    Sleep(Self.SleepIntervalMS);
  end;
end;


procedure TThreadScheduler.Init(const Name: String; ThreadCount: Integer = 0; DebugLevel: EDebugLevel = EDebugLevel.NONE);
begin
  Self.Pool.Init(Name + '-Pool', ThreadCount, DebugLevel);
  SetLength(Self.Tasks, 0);
  Self.Running := True;
  Self.SleepIntervalMS := 10;
  Self.Thread := TThread.Create(@Self.Loop);
  Self.Thread.Name := Name + '-Scheduler';
end;


procedure TThreadScheduler.Free();
begin
  Self.Running := False;

  if Assigned(Self.Thread) then
  begin
    Self.Thread.Terminate();
    Self.Thread.WaitForTerminate();
    Self.Thread.Free();
  end;

  Self.Pool.Free();
  SetLength(Self.Tasks, 0);
end;


function TThreadScheduler.Schedule(const TaskID: String; Method: procedure() of object; IntervalMS: Integer = 100): Boolean;
var
  Index: Integer;
begin
  Result := False;
  if not Assigned(@Method) then
    Exit;

  Index := Length(Self.Tasks);
  SetLength(Self.Tasks, Index + 1);

  Self.Tasks[Index].ID := TaskID;
  Self.Tasks[Index].Method := @Method;
  Self.Tasks[Index].Interval := IntervalMS;
  Self.Tasks[Index].LastRun := 0;
  Self.Tasks[Index].Active := True;

  Result := True;
  Self.Pool.Log(EDebugLevel.INFO, Format('Task "%s" scheduled to run every %dms', [TaskID, IntervalMS]));
end;


function TThreadScheduler.Pause(const TaskID: String): Boolean;
var
  i: Integer;
begin
  Result := False;
  for i := 0 to High(Self.Tasks) do
    if Self.Tasks[i].ID = TaskID then
    begin
      Self.Tasks[i].Active := False;
      Result := True;
      Self.Pool.Log(EDebugLevel.INFO, Format('Paused task "%s"', [TaskID]));
      Break;
    end;
end;


procedure TThreadScheduler.PauseAll();
var
  i: Integer;
begin
  for i := 0 to High(Self.Tasks) do
    Self.Tasks[i].Active := False;
end;


function TThreadScheduler.Unschedule(const TaskID: String): Boolean;
var
  i, j: Integer;
  Found: Boolean;
  NewTasks: TScheduledTaskArray;
begin
  Result := False;
  Found := False;

  for i := 0 to High(Self.Tasks) do
    if Self.Tasks[i].ID = TaskID then
    begin
      Found := True;
      Result := True;
      Self.Pool.Log(EDebugLevel.INFO, Format('Canceled task "%s"', [TaskID]));
      break;
    end;

  if Found then
  begin
    j := 0;
    SetLength(NewTasks, Length(Self.Tasks) - 1);
    for i := 0 to High(Self.Tasks) do
      if Self.Tasks[i].ID <> TaskID then
      begin
        NewTasks[j] := Self.Tasks[i];
        Inc(j);
      end;
    Self.Tasks := NewTasks;
  end;
end;


function TThreadScheduler.Resume(const TaskID: String): Boolean;
var
  i: Integer;
begin
  Result := False;
  for i := 0 to High(Self.Tasks) do
    if Self.Tasks[i].ID = TaskID then
    begin
      Self.Tasks[i].Active := True;
      Self.Tasks[i].LastRun := 0;
      Result := True;
      Self.Pool.Log(EDebugLevel.INFO, Format('Resumed task "%s"', [TaskID]));
      Break;
    end;
end;


function TThreadScheduler.GetTasks(): TStringArray;
var
  i, Count: Integer;
begin
  Count := 0;

  for i := 0 to High(Self.Tasks) do
    if Self.Tasks[i].Active then
      Inc(Count);

  SetLength(Result, Count);
  Count := 0;

  for i := 0 to High(Self.Tasks) do
    if Self.Tasks[i].Active then
    begin
      Result[Count] := Self.Tasks[i].ID;
      Inc(Count);
    end;
end;


procedure TThreadManager.Init(ThreadCount: Integer = 0; DebugLevel: EDebugLevel = EDebugLevel.NONE);
begin
  if Self.IsSetup then
    Exit;

  Self.DebugLevel := DebugLevel;
  Self.ThreadCount := ThreadCount;
  if Self.ThreadCount <= 0 then
    Self.ThreadCount := Self.Pool.GetDefaultThreadCount();

  Self.Pool.Init('MainPool', Self.ThreadCount, Self.DebugLevel);
  Self.Scheduler.Init('Scheduler', Max(1, Self.ThreadCount div 2), Self.DebugLevel);

  if Assigned(@Self.CompletionHandler) then
  begin
    Self.Pool.OnComplete := @Self.CompletionHandler;
    Self.Scheduler.Pool.OnComplete := @Self.CompletionHandler;
  end;

  if Assigned(@Self.ExceptionHandler) then
  begin
    Self.Pool.OnException := @Self.ExceptionHandler;
    Self.Scheduler.Pool.OnException := @Self.ExceptionHandler;
  end;

  Self.IsSetup := True;
end;


procedure TThreadManager.Free();
begin
  if not Self.IsSetup then
    Exit;

  Self.Scheduler.Free();
  Self.Pool.Free();
  Self.IsSetup := False;
end;


function TThreadManager.Submit(const TaskID: String; Method: procedure() of object; Priority: Integer = 0; AllowDuplicates: Boolean = False): Boolean;
begin
  if not Self.IsSetup then
    Self.Init(0, Self.DebugLevel);

  Result := Self.Pool.Submit(TaskID, @Method, Priority, AllowDuplicates);
end;






function TThreadManager.Schedule(const TaskID: String; Method: procedure() of object; IntervalMS: Integer): Boolean;
begin
  if not Self.IsSetup then
    Self.Init(0, Self.DebugLevel);

  Result := Self.Scheduler.Schedule(TaskID, @Method, IntervalMS);
end;


function TThreadManager.PauseTask(const TaskID: String): Boolean;
begin
  if not Self.IsSetup then
    Exit(False);
  Result := Self.Scheduler.Pause(TaskID);
end;


function TThreadManager.ResumeTask(const TaskID: String): Boolean;
begin
  if not Self.IsSetup then
    Exit(False);
  Result := Self.Scheduler.Resume(TaskID);
end;


function TThreadManager.CancelTask(const TaskID: String): Boolean;
begin
  if not Self.IsSetup then
    Exit(False);
  Result := Self.Scheduler.Unschedule(TaskID);
end;


function TThreadManager.SubmitBatch(const TaskIDs: TStringArray; Methods: array of procedure() of object): Boolean;
var
  i: Integer;
begin
  Result := True;
  if not Self.IsSetup then
    Self.Init(0, Self.DebugLevel);

  if Length(TaskIDs) <> Length(Methods) then
    Exit(False);

  for i := 0 to High(TaskIDs) do
    if not Self.Pool.Submit(TaskIDs[i], @Methods[i], 0, False) then
      Result := False;
end;


procedure TThreadManager.Await(TimeoutMS: Integer = 30000);
begin
  if Self.IsSetup then
    Self.Pool.Await(TimeoutMS);
end;


function TThreadManager.Stats(): String;
begin
  if not Self.IsSetup then
    Exit('Not Setup');

  Result := Self.Pool.GetStats() + LINE_SEP +
            Format('Scheduled: %d', [Length(Self.Scheduler.GetTasks())]);
end;


procedure TThreadManager.SetExceptionHandler(Handler: TOnException);
begin
  Self.ExceptionHandler := @Handler;

  if Self.IsSetup then
  begin
    Self.Pool.OnException := @Handler;
    Self.Scheduler.Pool.OnException := @Handler;
  end;
end;


procedure TThreadManager.SetCompletionHandler(Handler: TOnComplete);
begin
  Self.CompletionHandler := @Handler;
  if Self.IsSetup then
  begin
    Self.Pool.OnComplete := @Handler;
    Self.Scheduler.Pool.OnComplete := @Handler;
  end;
end;


procedure TThreadManager.SetDebugLevel(Level: EDebugLevel);
begin
  Self.DebugLevel := Level;
  if Self.IsSetup then
  begin
    Self.Pool.DebugLevel := Level;
    Self.Scheduler.Pool.DebugLevel := Level;
    if Level > EDebugLevel.NONE then
      WriteLn(Format('Debug level set to %d', [Ord(Level)]));
  end;
end;
