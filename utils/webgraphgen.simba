(*
# WebGraph Generator
File responsible for webgraph generation out of collision map images.
*)

{$DEFINE SRLT_WEBGRAPHGEN_INCLUDED}
{$IFNDEF SRLT_UTILS}
  {$I SRLT/utils.simba}
{$ENDIF}

type
  TWebGraphSettings = record
    Spacing, MinimumTiles, NodeRadius, MaxConnections: Integer;
    WallCrossings, Disabled: Boolean;
  end;

function TWebGraphSettings.Hash(): String;
var
  data: TIntegerArray;
begin
  data := [Self.Spacing, Self.MinimumTiles, Self.NodeRadius, Self.MaxConnections, Integer(Self.WallCrossings)];
  Result := HashData(EHashAlgo.MD5, @data[0], Length(data));
  SetLength(Result, 6);
end;

var
  GENERATED_GRAPH: TWebGraphSettings;

begin
  GENERATED_GRAPH.Spacing := 18;         //low = better/slower, high = worse/faster
  GENERATED_GRAPH.MinimumTiles := 4;     //spaces with less tiles than this will be ignored.
  GENERATED_GRAPH.NodeRadius := 50;      //closed space less than NodeRadius pixels will have a single node.
  GENERATED_GRAPH.MaxConnections := 6;   //Max connections per node.
  GENERATED_GRAPH.WallCrossings := True; //Whether to allow wall crossings when there's a close path around it.
end;


function TWebGraph._FindDoors(doors: T2DPointArray; img: TImage): TRSDoorArray; static;
var
  direction, inverted: TPoint;
  i, idx, j: Integer;
  doorType: ERSDoorType;
  splitA, splitB: Boolean;
begin
  for i := 0 to High(doors) do
  begin
    case Length(doors[i]) of
      4: doorType := ERSDoorType.NORMAL;
      8: doorType := ERSDoorType.WIDE;
      else Continue;
    end;

    with doors[i].Mean() do
    begin
      if (img.Pixel[X+1, Y] = $0000FF) or (img.Pixel[X-1, Y] = $0000FF) then
        direction := [0,1]
      else if (img.Pixel[X, Y+1] = $0000FF) or (img.Pixel[X, Y-1] = $0000FF) then
        direction := [1,0]
      else if (img.Pixel[X+1, Y+1] = $0000FF) or (img.Pixel[X-1, Y-1] = $0000FF) then
        direction := [1,-1]
      else if (img.Pixel[X+1, Y-1] = $0000FF) or (img.Pixel[X-1, Y+1] = $0000FF) then
        direction := [1,1]
      else
        Continue;

      if (img.Pixel[X+direction.X, Y+direction.Y] <> $FFFFFF) or
         (img.Pixel[X + (direction.X*-1), Y+ (direction.Y*-1)] <> $FFFFFF) then
        Continue;

      inverted := direction.Rotate(PI/2, [0,0]);
      splitA := False;
      splitB := False;

      for j := 1 to 6 do
        with Point(X,Y) + (inverted * j) do
          case img.Pixel[X, Y] of
            $FFFFFF: Break;
            $333333, $0:
            begin
              splitA := True;
              Break;
            end;
          end;

      for j := 1 to 6 do
        with Point(X,Y) - (inverted * j) do
          case img.Pixel[X, Y] of
            $FFFFFF: Break;
            $333333, $0:
            begin
              splitB := True;
              Break;
            end;
          end;

      if not splitA or not splitB then Continue;

      idx := Length(Result);
      SetLength(Result, idx+1);
      Result[idx].Center := [X,Y];
    end;

    Result[idx].DoorType := doorType;
    Result[idx].Direction := direction;
    Result[idx].Before := Result[idx].Center + direction * 2;
    Result[idx].After  := Result[idx].Center - direction * 2;
  end;
end;


(*
## TRSChunkLoader.BuildGraph
```pascal
function TRSChunkLoader._BuildGraph(map: TMufasaBitmap; white, red: TPointArray): TWebGraphV2;
function TRSChunkLoader.BuildGraph(name: String; map: TMufasaBitmap): TWebGraphV2;
```
Magically builds a webgraph for you for a given collision map passed into `map`.

The collision map can only have 4 colors:
- white ($FFFFFF) for walkable space
- black ($000000) for non walkable space
- red ($0000FF) for doors (optional)
- gray ($333333) for objects (optional)

```{note}
This is an internal method. Don't use it if you don't know what you are doing.
```
*)
function TWebGraph._BuildGraph(map: TImage; white, red: TPointArray): TWebGraph; static;
var
  a, b, i, j, n, len, hi: Integer;
  atpa, parts: T2DPointArray;
  skeleton, nodes, tpa, doorsInTpa, doorNodes: TPointArray;
  bounds: TBox;
  p, q: TPoint;
  nodesTree, skeletonTree: TSlackTree;
  jInRange, nInRange: Boolean;
  connectionMap: array of TIntegerMatrix;
  doors: TRSDoorArray;
  door: TRSDoor;
  doorPaths: T2DIntegerArray;
begin
  atpa := white.ClusterEx(1).SortBySize(True);
  doors := TWebGraph._FindDoors(red.ClusterEx(1), map);

  for i := 0 to High(doors) do
  begin
    Result.Doors += doors[i];
    doorNodes += [doors[i].Before, doors[i].After];
    SetLength(doorPaths, Length(doorNodes));
    doorPaths[i*2] += i*2+1;
    doorPaths[i*2+1] += i*2;
  end;

  for i := 0 to High(atpa) do
  begin
    if Length(atpa[i]) <= GENERATED_GRAPH.MinimumTiles * RSTranslator.TileArea then
      Continue; //remove very small spaces

    bounds := atpa[i].Bounds();
    if Max(bounds.Width, bounds.Height) < GENERATED_GRAPH.NodeRadius then
    begin
      Result.Nodes += atpa[i].Median(); //mark spaces less than NodeRadius with a single node and continue
      Continue;
    end;

    skeleton := atpa[i].Erode(1).Skeleton(2, 6);

    if skeleton = [] then
    begin
      Result.Nodes += atpa[i].Median();
      Continue;
    end;

    for tpa in skeleton.Partition(GENERATED_GRAPH.Spacing) do
    begin
      if tpa = [] then Continue;
      for tpa in tpa.ClusterEx(1.5) do nodes += tpa.Mean();
    end;

    SetLength(connectionMap, bounds.X2, bounds.Y2);

    skeletonTree.Init(skeleton);
    nodesTree.Init(nodes);
    for j := 0 to High(nodesTree.Data) do
    begin
      p := nodesTree.Data[j].Split;
      tpa := nodesTree.KNearest(p, GENERATED_GRAPH.MaxConnections, True);

      for q in tpa do
      begin
        if Max(Abs(p.X - q.X), Abs(p.Y - q.Y)) > GENERATED_GRAPH.Spacing * 4 then
          Continue;

        if GENERATED_GRAPH.WallCrossings then
        begin
          connectionMap[q.X, q.Y] += j;
          Continue;
        end;

        bounds := TBox.Create(p.X, p.Y, q.X, q.Y).Expand(GENERATED_GRAPH.Spacing);


        parts := skeletonTree.RangeQuery(bounds).Cluster(1);

        for a := 0 to High(parts) do
        begin
          jInRange := False;
          nInRange := False;

          for b := 0 to High(parts[a]) do
          begin
            jInRange := jInRange or (parts[a,b].DistanceTo(p) <= Sqrt(2));
            nInRange := nInRange or (parts[a,b].DistanceTo(q) <= Sqrt(2));

            if jInRange and nInRange then Break(2);
          end;

          if jInRange <> nInRange then Break;
        end;

        if not jInRange or not nInRange then Continue;

        connectionMap[q.X, q.Y] += j;
      end;
    end;

    len := Length(Result.Nodes);
    SetLength(Result.Nodes, len + Length(nodes));
    SetLength(Result.Paths, Length(Result.Nodes));

    for j := 0 to High(nodesTree.Data) do
    begin
      p := nodesTree.Data[j].Split;
      Result.Nodes[j+len] := p;
      for n in connectionMap[p.X, p.Y] do
      begin
        Result.Nodes[n+len] := nodesTree.Data[n].Split;

        if not Result.Paths[j+len].Contains(n+len) then
          Result.Paths[j+len] += n+len;
        if not Result.Paths[n+len].Contains(j+len) then
          Result.Paths[n+len] += j+len;
      end;
    end;

    nodes := [];
  end;

  SetLength(Result.Paths, Length(Result.Nodes));
  SetLength(Result.Names, Length(Result.Nodes));

  //Connect doornodes to nearest node
  nodes := Copy(Result.Nodes);
  nodesTree.Init(nodes);

  len := Length(Result.Nodes);

  for i := 0 to High(atpa) do
  begin
    doorsInTpa := atpa[i].Intersection(doorNodes);

    for j := 0 to High(doorsInTpa) do
    begin
      for p in nodesTree.KNearest(doorsInTpa[j], 20) do
      begin
        if atpa[i].Contains(p) then
        begin
          n := Result.Nodes.IndexOf(p);
          Result.Nodes += doorsInTpa[j];
          SetLength(Result.Paths, Length(Result.Nodes));
          Result.Paths[n] += High(Result.Nodes);
          Result.Paths[High(Result.Nodes)] += n;
          Break;
        end;
      end;

      if not Result.Nodes.Contains(doorsInTpa[j]) then
      begin
        Result.Nodes += doorsInTpa[j];
        SetLength(Result.Paths, Length(Result.Nodes));
        Result.Paths[High(Result.Paths)] += High(Result.Nodes);
      end;
    end;
  end;

  nodes := Copy(Result.Nodes, len, Length(Result.Nodes)-len);

  for n := 0 to High(doorNodes) do
  begin
    i := nodes.IndexOf(doorNodes[n]);
    j := nodes.IndexOf(doorNodes[doorPaths[n][0]]);
    if (i < 0) or (j < 0) then Continue;
    Result.Paths[len + i] += len + j;
  end;

  SetLength(Result.Paths, Length(Result.Nodes));
  SetLength(Result.Names, Length(Result.Nodes));
end;

function TWebGraph.BuildGraph(name: String; map: TImage): TWebGraph; static;
var
  white, red, gray, merged, graySubset: TPointArray;
  whiteClusters, grayClusters, mergedClusters: T2DPointArray;
  i, j: Integer;
  t: UInt64;
begin
  white := map.FindColor($FFFFFF, 0);
  red := map.FindColor($0000FF, 0);

  WriteLn GetDebugLn('Generating webgraph for region: ' + name);

  t := GetTickCount();
  Result := Self._BuildGraph(map, white, red);

  gray := map.FindColor($333333, 0);

  whiteClusters := white.ClusterEx(1);
  grayClusters := gray.ClusterEx(1);

  for i := 0 to High(whiteClusters) do
  begin
    if Length(whiteClusters[i]) <= 6 then Continue;

    graySubset := gray.ExtractBox(whiteclusters[i].Bounds().Expand(80));
    merged := whiteclusters[i] + graySubset;
    mergedClusters := merged.ClusterEx(1);

    for j := 0 to high(mergedClusters) do
      if mergedClusters[j].Contains(whiteClusters[i][0]) then
      begin
        Result.WalkableClusters += mergedClusters[j];
        Break;
      end;
  end;

  Result.WalkableSpace    := white + gray;
  Result.ObjectClusters   := grayClusters;

  WriteLn GetDebugLn('WebGraph', 'Generating webgraph took ' + ToStr(Round(((GetTickCount()-t)/1000), 3)) + 'seconds.', EErrorLevel.SUCCESS);
end;
