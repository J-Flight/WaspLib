(*
# WebGraph Generator
This page is about webgraph generation out of collision map images.

You can force WaspLib's graph generator to always run even if there's already
cached graphs by adding the following compiler directive at the top of your
script **BEFORE INCLUDING WASPLIB**:
```pascal
{$DEFINE WL_GENERATE_GRAPH_ALWAYS}
```
*)

{$DEFINE WL_WEBGRAPHGEN_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}
{$R-}

type
(*
## TWebGraphGenerator
Record responsible for generating webgraphs from collision map images.
*)
  TWebGraphGenerator = record
    Spacing, MinimumTiles, NodeRadius, MaxConnections,
    MaxDoorConnections: Integer;
    Skeletonize: Boolean;
    Disabled: Boolean;
  end;

function TWebGraphGenerator.Hash(): String;
var
  data: TIntegerArray;
begin
  data := [
    Self.Spacing, Self.MinimumTiles, Self.NodeRadius, Self.MaxConnections,
    Self.MaxDoorConnections, Int32(Self.Skeletonize)
  ];
  Result := HashData(EHashAlgo.CRC32, @data[0], Length(data));
end;

(*
## WebGraphGenerator.Setup
```pascal
procedure TWebGraphGenerator.Setup(spacing, minimumTiles, nodeRadius, maxConnections, maxDoorConnections: Integer);
```
Sets up the `TWebGraphGenerator` with the following settings which are the
defaults:
```pascal
WebGraphGenerator.Setup(18, 4, 50, 6, 3);
```

Parameters explanation
- `spacing`: Lower values have better results but the generation is slower, high
values have worse results but geneartion is faster.
- `minimumTiles`: spaces with less tiles than this will be ignored.
- `nodeRadius`: closed spaces that are less than this values in pixels will have a single node in the middle.
- `maxConnections`: max connections per node.
- `maxDoorConnections`: max connections per door node.

Feel free to change the settings to suit your need and use the
{ref}`Map Debugger` to see what the results look like.

To do so you **MUST DO IT BEFORE** setting up your {ref}`Map`.
*)
procedure TWebGraphGenerator.Setup(spacing, minimumTiles, nodeRadius, maxConnections, maxDoorConnections: Integer; skeletonize: Boolean);
begin
  Self.Spacing := spacing;
  Self.MinimumTiles := minimumTiles;
  Self.NodeRadius := nodeRadius;
  Self.MaxConnections := maxConnections;
  Self.MaxDoorConnections := maxDoorConnections;
  Self.Skeletonize := skeletonize;
end;

function TWebGraphGenerator.GetDoorDirection(center: TPoint; img: TImage): TPoint;
var
  imgBounds: TBox;
  
  function SafePixelCheck(x, y: Integer): Boolean;
  begin
    Result := imgBounds.Contains([x, y]) and (img.Pixel[x, y] = $0000FF);
  end;
  
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  
  if SafePixelCheck(center.X+1, center.Y) or SafePixelCheck(center.X-1, center.Y) then
    Exit([0,1]);

  if SafePixelCheck(center.X, center.Y+1) or SafePixelCheck(center.X, center.Y-1) then
    Exit([1,0]);

  if SafePixelCheck(center.X+1, center.Y+1) or SafePixelCheck(center.X-1, center.Y-1) then
    Exit([1,-1]);

  if SafePixelCheck(center.X+1, center.Y-1) or SafePixelCheck(center.X-1, center.Y+1) then
    Exit([1,1]);

  Result := [0,0];
end;

function TWebGraphGenerator.DoorIsSeparating(center, direction: TPoint; img: TImage): Boolean;
var
  inverted: TPoint;
  i: Integer;
  splitA, splitB: Boolean;
  testPoint: TPoint;
  imgBounds: TBox;
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  inverted := direction.Rotate(HALF_PI, [0,0]);

  for i := 1 to 5 do
  begin
    testPoint := Point(center.X, center.Y) + (inverted*i);
    
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(testPoint.X - direction.X, testPoint.Y - direction.Y);
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(center.X, center.Y) + (inverted*i) + direction;
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;
  end;

  for i := 1 to 5 do
  begin
    testPoint := Point(center.X, center.Y) - (inverted * i);
    
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(testPoint.X - direction.X, testPoint.Y - direction.Y);
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(center.X, center.Y) - (inverted * i) + direction;
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;
  end;

  Result := splitA and splitB;
end;


function TWebGraphGenerator.FindDoors(doors: T2DPointArray; img: TImage): T2DPointArray;
var
  direction: TPoint;
  i, idx: Integer;
  imgBounds: TBox;
  centerPt, testPt1, testPt2: TPoint;
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  
  for i := 0 to High(doors) do
  begin
    case Length(doors[i]) of
      4, 8: ;
      else Continue;
    end;

    centerPt := doors[i].Mean();
    direction := Self.GetDoorDirection(centerPt, img);
    if direction = [0,0] then Continue;

    testPt1 := Point(centerPt.X + direction.X, centerPt.Y + direction.Y);
    testPt2 := Point(centerPt.X - direction.X, centerPt.Y - direction.Y);
    
    if not imgBounds.Contains(testPt1) or not imgBounds.Contains(testPt2) then
      Continue;
      
    if (img.Pixel[testPt1.X, testPt1.Y] <> $FFFFFF) or
       (img.Pixel[testPt2.X, testPt2.Y] <> $FFFFFF) then
      Continue;

    if not Self.DoorIsSeparating(centerPt, direction, img) then
      Continue;

    idx := Length(Result);
    SetLength(Result, idx+1);
    Result[idx] += centerPt;
    Result[idx] += centerPt + direction * 2;
    Result[idx] += centerPt - direction * 2;
  end;
end;


(*
## WebGraphGenerator.BuildGraph
```pascal
function TWebGraphGenerator._BuildGraph(map: TImage; white, red: TPointArray): TWebGraph;
function TWebGraphGenerator.BuildGraph(name: String; map: TImage): TWebGraph;
```
Magically builds a webgraph for you for a given collision map passed into `map`.

The collision map can only have 4 colors:
- white ($FFFFFF) for walkable space
- black ($000000) for non walkable space
- red ($0000FF) for doors (optional)
- gray ($333333) for objects (optional)

```{note}
This is an internal method. Don't use it if you don't know what you are doing.
```

It's hard to go into detail on how this works but if you want to see the result
run this example code:
```pascal
{$I WaspLib/osrs.simba}
begin
  Map.Setup([Chunk(Box(49,54,50,53), 0)]);
  Map.Debug();
end.
```

This will setup a map with a small piece of varrock and then open the
{ref}`Map Debugger`.

On the {ref}`Map Debugger` change the dropdown to the collision map if you want
to see what it looks like, that is what will go through this as the `map`
parameter and it should look something like this:

```{figure} ../../images/map_collision.png
```

As a bonus you can also see the resulting webgraph!
*)
function TWebGraphGenerator._BuildGraph(map: TImage; white, red: TPointArray): TWebGraph;
var
  i, j, l, n, hi, len, minLen, maxSpacing, minSpacing: Integer;
  clusters: T2DPointArray;
  skeleton, nodes, tpa, tmp: TPointArray;
  p, q: TPoint;
  tree: TKDPointTree;
  doors: T2DPointArray;
  connectMap: array of TIntegerMatrix;
  doorMapA, doorMapB, matrix: TIntegerMatrix;
  connectA, connectB: TIntegerArray;
  minRadius: Boolean;
begin
  minLen := Self.MinimumTiles * RSTranslator.TileArea;
  maxSpacing := Self.Spacing * 2;
  minSpacing := Self.Spacing div 2;

  clusters := white.Cluster(1);
  doors := Self.FindDoors(red.Cluster(1.5), map);

  SetLength(connectA, Length(doors));
  SetLength(connectB, Length(doors));

  with white.Bounds() do
  begin
    SetLength(connectMap, Y2+1, X2+1);
    SetLength(matrix, Y2+1, X2+1);
  end;

  SetLength(doorMapA, Length(clusters));
  SetLength(doorMapB, Length(clusters));

  for i := 0 to High(clusters) do
  begin
    if Length(clusters[i]) < minLen then
      Continue;

    for p in clusters[i] do
      matrix[p.Y, p.X] := i;
  end;

  for i := 0 to High(doors) do
  begin
    n  := matrix[doors[i,1].Y, doors[i,1].X];
    l := matrix[doors[i,2].Y, doors[i,2].X];

    if n = l then
      Continue;

    connectA[i] := n;
    doorMapA[n] += i;

    connectB[i] := l;
    doorMapB[l] += i;

    Result.Nodes += TGraphNode.Create(doors[i,0], EGraphNode.DOOR);
    matrix[doors[i,0].Y, doors[i,0].X] := High(Result.Nodes);
  end;

  SetLength(Result.Paths, Length(Result.Nodes));

  for i := 0 to High(clusters) do
  begin
    if not minRadius then
    begin
      if Length(clusters[i]) < minLen then
        Continue;
      with clusters[i].Bounds() do
      begin
        if Max(Width, Height) >= Self.NodeRadius then
          minRadius := True
        else
        begin
          Result.Nodes += TGraphNode.Create(clusters[i].Median());
          hi := High(Result.Nodes);
          SetLength(Result.Paths, hi+1);

          for n := High(doorMapA[i]) downto 0 do
          begin
            j := doorMapA[i,n];
            if connectA[j] = i then
            begin
              l := matrix[doors[j,0].Y, doors[j,0].X];
              if Result.Paths[l] <> [] then
                Delete(doorMapA[i], i, 1);
              Result.Paths[l] += [hi];
              Result.Paths[hi] += l;
            end;
          end;

          for n := High(doorMapB[i]) downto 0 do
          begin
            j := doorMapB[i,n];
            if connectB[j] = i then
            begin
              l := matrix[doors[j,0].Y, doors[j,0].X];
              if Result.Paths[l] <> [] then
                Delete(doorMapA[i], i, 1);
              Result.Paths[l] += [hi];
              Result.Paths[hi] += l;
            end;
          end;

          Continue;
        end;
      end;
    end;

    nodes := [];
    if Self.Skeletonize then
    begin
      skeleton := clusters[i].Erode(1).Skeleton(2, 6);
      for tpa in skeleton.Partition(Self.Spacing) do
        nodes += tpa.Cluster(1.5).Means();
    end
    else
    begin
      for tpa in clusters[i].Erode(1).Partition(Self.Spacing) do
        nodes += tpa.Cluster(1.5).Means();
    end;

    if nodes = [] then Continue;

    tree := TKDPointTree.Create(nodes);

    len := Length(Result.Nodes);
    SetLength(Result.Nodes, len + Length(nodes));
    SetLength(Result.Paths, Length(Result.Nodes));

    for j := 0 to High(tree.Data) do
    begin
      p := tree.Data[j].Split;
      for q in tree.KNearest(p, Self.MaxConnections*2, True) do
      begin
        if Max(Abs(p.X - q.X), Abs(p.Y - q.Y)) > maxSpacing then Continue;
        tpa := clusters[i].ExtractBox(TBox.Create(p, q).Expand(minSpacing));
        tpa := tpa.AStar(p, q, False);
        if (tpa = []) or (Length(tpa) > 80) then
          Continue;
        connectMap[q.Y,q.X] += j;
        if Inc(n) > Self.MaxConnections then
          Break;
      end;
      n := 0;
    end;

    for j := 0 to High(tree.Data) do
    begin
      p := tree.Data[j].Split;
      Result.Nodes[j+len] := TGraphNode.Create(p);
      for n in connectMap[p.Y,p.X] do
      begin
        q := tree.Data[n].Split;
        Result.Nodes[n+len] := TGraphNode.Create(q);

        if not Result.Paths[j+len].Contains(n+len) then
          Result.Paths[j+len] += n+len;
        if not Result.Paths[n+len].Contains(j+len) then
          Result.Paths[n+len] += j+len;
      end;
    end;

    for j in doorMapA[i] + doorMapB[i] do
    begin
      p := doors[j,0];
      l := matrix[p.Y, p.X];

      tmp := clusters[i];
      tmp += p;

      for q in tree.KNearest(p, Self.MaxDoorConnections, True) do
      begin
        if Max(Abs(p.X - q.X), Abs(p.Y - q.Y)) > maxSpacing then
          Continue;

        tpa := tmp.ExtractBox(TBox.Create(p, q).Expand(minSpacing));
        tpa := tpa.AStar(p, q, False);
        if (tpa = []) or (Length(tpa) > 80) then
          Continue;

        n := Result.Nodes.IndexOf(q);
        Result.Paths[l] += [n];
        Result.Paths[n] += l;
      end;
    end;
  end;
end;

function TWebGraphGenerator.BuildGraph(name: String; map: TImage): TWebGraph;
var
  white, red, gray, merged, graySubset: TPointArray;
  whiteClusters, grayClusters, mergedClusters: T2DPointArray;
  i, j: Integer;
  t: UInt64;
begin
  white := map.FindColor($FFFFFF, 0);
  red := map.FindColor($0000FF, 0);

  WriteLn GetDebugLn('Generating webgraph for region: ' + name);

  t := GetTimeRunning();
  Result := Self._BuildGraph(map, white, red);

  gray := map.FindColor($333333, 0);

  whiteClusters := white.Cluster(1);
  grayClusters := gray.Cluster(1);

  for i := 0 to High(whiteClusters) do
  begin
    if Length(whiteClusters[i]) <= 6 then Continue;

    graySubset := gray.ExtractBox(whiteclusters[i].Bounds().Expand(80));
    merged := whiteclusters[i] + graySubset;
    mergedClusters := merged.Cluster(1);

    for j := 0 to high(mergedClusters) do
      if mergedClusters[j].Contains(whiteClusters[i][0]) then
      begin
        Result.WalkableClusters += mergedClusters[j];
        Break;
      end;
  end;

  Result.WalkableSpace    := white + gray;
  Result.ObjectClusters   := grayClusters;

  WriteLn GetDebugLn('WebGraphGenerator', 'Generating webgraph took ' + ToStr(Round(((GetTimeRunning()-t)/1000), 2)) + ' seconds.', ELogLevel.SUCCESS);
end;
{$R+}

var
(*
## WebGraphGenerator variable
Global {ref}`TWebGraphGenerator` variable.
*)
  WebGraphGenerator: TWebGraphGenerator;
