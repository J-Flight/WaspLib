(*
# WebGraph Generator
This page is about webgraph generation out of collision map images.

You can force WaspLib's graph generator to always run even if there's already
cached graphs by adding the following compiler directive at the top of your
script **BEFORE INCLUDING WASPLIB**:
```pascal
{$DEFINE WL_GENERATE_GRAPH_ALWAYS}
```
*)

{$DEFINE WL_WEBGRAPHGEN_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}
{$R+}

type
(*
## TWebGraphGenerator
Record responsible for generating webgraphs from collision map images.
*)
  TWebGraphGenerator = record
    Spacing, MinimumTiles, NodeRadius, MaxConnections,
    MaxDoorConnections: Integer;
    Disabled: Boolean;
  end;

function TWebGraphGenerator.Hash(): String;
var
  data: TIntegerArray;
begin
  data := [Self.Spacing, Self.MinimumTiles, Self.NodeRadius, Self.MaxConnections, Self.MaxDoorConnections];
  Result := HashData(EHashAlgo.CRC32, @data[0], Length(data));
end;

(*
## WebGraphGenerator.Setup
```pascal
procedure TWebGraphGenerator.Setup();
```
Sets up the `TWebGraphGenerator` with the following settings which are the
defaults:
```pascal
WebGraphGenerator.Spacing := 18;           //low = better/slower, high = worse/faster
WebGraphGenerator.MinimumTiles := 4;       //spaces with less tiles than this will be ignored.
WebGraphGenerator.NodeRadius := 50;        //closed space less than NodeRadius pixels will have a single node.
WebGraphGenerator.MaxConnections := 6;     //Max connections per node.
WebGraphGenerator.MaxDoorConnections := 3; //Max connections per door node.
WebGraphGenerator.WallCrossings := True;   //Whether to allow wall crossings when there's a close path around it.
```

Feel free to change the settings to suit your need and use the
{ref}`Map Debugger` to see what the results look like.

To do so you **MUST DO IT BEFORE** setting up your {ref}`Map`.
*)
procedure TWebGraphGenerator.Setup();
begin
  Self.Spacing := 18;
  Self.MinimumTiles := 4;
  Self.NodeRadius := 50;
  Self.MaxConnections := 6;
  Self.MaxDoorConnections := 6;
end;

function TWebGraphGenerator.GetDoorDirection(center: TPoint; img: TImage): TPoint;
var
  imgBounds: TBox;
  
  function SafePixelCheck(x, y: Integer): Boolean;
  begin
    Result := imgBounds.Contains([x, y]) and (img.Pixel[x, y] = $0000FF);
  end;
  
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  
  if SafePixelCheck(center.X+1, center.Y) or SafePixelCheck(center.X-1, center.Y) then
    Exit([0,1]);

  if SafePixelCheck(center.X, center.Y+1) or SafePixelCheck(center.X, center.Y-1) then
    Exit([1,0]);

  if SafePixelCheck(center.X+1, center.Y+1) or SafePixelCheck(center.X-1, center.Y-1) then
    Exit([1,-1]);

  if SafePixelCheck(center.X+1, center.Y-1) or SafePixelCheck(center.X-1, center.Y+1) then
    Exit([1,1]);

  Result := [0,0];
end;

function TWebGraphGenerator.DoorIsSeparating(center, direction: TPoint; img: TImage): Boolean;
var
  inverted: TPoint;
  i: Integer;
  splitA, splitB: Boolean;
  testPoint: TPoint;
  imgBounds: TBox;
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  inverted := direction.Rotate(HALF_PI, [0,0]);

  for i := 1 to 5 do
  begin
    testPoint := Point(center.X, center.Y) + (inverted*i);
    
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(testPoint.X - direction.X, testPoint.Y - direction.Y);
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(center.X, center.Y) + (inverted*i) + direction;
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitA := True;
          Break;
        end;
      end;
    end;
  end;

  for i := 1 to 5 do
  begin
    testPoint := Point(center.X, center.Y) - (inverted * i);
    
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(testPoint.X - direction.X, testPoint.Y - direction.Y);
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;

    testPoint := Point(center.X, center.Y) - (inverted * i) + direction;
    if imgBounds.Contains(testPoint) then
    begin
      case img.Pixel[testPoint.X, testPoint.Y] of
        $333333, $0:
        begin
          splitB := True;
          Break;
        end;
      end;
    end;
  end;

  Result := splitA and splitB;
end;


function TWebGraphGenerator.FindDoors(doors: T2DPointArray; img: TImage): T2DPointArray;
var
  direction: TPoint;
  i, idx: Integer;
  imgBounds: TBox;
  centerPt, testPt1, testPt2: TPoint;
begin
  imgBounds := [0, 0, img.Width - 1, img.Height - 1];
  
  for i := 0 to High(doors) do
  begin
    case Length(doors[i]) of
      4, 8: ;
      else Continue;
    end;

    centerPt := doors[i].Mean();
    direction := Self.GetDoorDirection(centerPt, img);
    if direction = [0,0] then Continue;

    testPt1 := Point(centerPt.X + direction.X, centerPt.Y + direction.Y);
    testPt2 := Point(centerPt.X - direction.X, centerPt.Y - direction.Y);
    
    if not imgBounds.Contains(testPt1) or not imgBounds.Contains(testPt2) then
      Continue;
      
    if (img.Pixel[testPt1.X, testPt1.Y] <> $FFFFFF) or
       (img.Pixel[testPt2.X, testPt2.Y] <> $FFFFFF) then
      Continue;

    if not Self.DoorIsSeparating(centerPt, direction, img) then
      Continue;

    idx := Length(Result);
    SetLength(Result, idx+1);
    Result[idx] += centerPt;
    Result[idx] += centerPt + direction * 2;
    Result[idx] += centerPt - direction * 2;
  end;
end;


(*
## WebGraphGenerator.BuildGraph
```pascal
function TWebGraphGenerator._BuildGraph(map: TImage; white, red: TPointArray): TWebGraph;
function TWebGraphGenerator.BuildGraph(name: String; map: TImage): TWebGraph;
```
Magically builds a webgraph for you for a given collision map passed into `map`.

The collision map can only have 4 colors:
- white ($FFFFFF) for walkable space
- black ($000000) for non walkable space
- red ($0000FF) for doors (optional)
- gray ($333333) for objects (optional)

```{note}
This is an internal method. Don't use it if you don't know what you are doing.
```

It's hard to go into detail on how this works but if you want to see the result
run this example code:
```pascal
{$I WaspLib/osrs.simba}
begin
  Map.Setup([Chunk(Box(49,54,50,53), 0)]);
  Map.Debug();
end.
```

This will setup a map with a small piece of varrock and then open the
{ref}`Map Debugger`.

On the {ref}`Map Debugger` change the dropdown to the collision map if you want
to see what it looks like, that is what will go through this as the `map`
parameter and it should look something like this:

```{figure} ../../images/map_collision.png
```

As a bonus you can also see the resulting webgraph!
*)
function TWebGraphGenerator._BuildGraph(map: TImage; white, red: TPointArray): TWebGraph;
var
  i, j, l, n, hi, len, minLen, maxSpacing, minSpacing: Integer;
  clusters: T2DPointArray;
  skeleton, nodes, tpa: TPointArray;
  p, q: TPoint;
  tree: TKDPointTree;
  doors: T2DPointArray;
  connectMap: array of TIntegerMatrix;
  doorMapA, doorMapB, doorMap: TIntegerMatrix;
  skip, ignore: TBooleanArray;
  left, right: Boolean;
  connectA, connectB: TIntegerArray;
  tmp: TImage;
begin
  doors := Self.FindDoors(red.Cluster(1.5), map);

  SetLength(skip, Length(doors));
  SetLength(ignore, Length(doors));
  SetLength(connectA, Length(doors));
  SetLength(connectB, Length(doors));

  with white.Bounds() do
  begin
    SetLength(connectMap, Y2, X2);
    SetLength(doorMap, Y2, X2);
  end;

  minLen := Self.MinimumTiles * RSTranslator.TileArea;

  maxSpacing := Self.Spacing * 2;
  minSpacing := Self.Spacing div 2;

  clusters := white.Cluster(1).SortBySize(True);

  for i := High(clusters) downto 0 do
    if Length(clusters[i]) < minLen then
      Delete(clusters, i, 1);

  SetLength(doorMapA, Length(clusters));
  SetLength(doorMapB, Length(clusters));

  for i := 0 to High(clusters) do
  begin
    for j := 0 to High(doors) do
    begin
      if skip[j] or ignore[j] then Continue;
      left  := clusters[i].Contains(doors[j,1]);
      right := clusters[i].Contains(doors[j,2]);

      if left and right then
      begin
        ignore[j] := True;
        Continue;
      end;

      if left then
      begin
        connectA[j] := i;
        doorMapA[i] += j;
        skip[j] := connectB[j] <> 0;
      end
      else if right then
      begin
        connectB[j] := i;
        doorMapB[i] += j;
        skip[j] := connectA[j] <> 0;
      end
      else
        Continue;

      if not skip[j] then
      begin
        Result.Nodes += TGraphNode.Create(doors[j,0], EGraphNode.DOOR);
        doorMap[doors[j,0].Y, doors[j,0].X] := High(Result.Nodes);
        SetLength(Result.Paths, High(Result.Nodes));
      end;
    end;
  end;

  for i := 0 to High(clusters) do
  begin
    with clusters[i].Bounds() do
      if Max(Width, Height) < Self.NodeRadius then
      begin
        Result.Nodes += TGraphNode.Create(clusters[i].Median());
        hi := High(Result.Nodes);
        SetLength(Result.Paths, hi+1);

        for j in doorMapA[i] + doorMapB[i] do
          if not ignore[j] and ((connectA[j] = i) or (connectB[j] = i)) then
          begin
            l := doorMap[doors[j,0].Y, doors[j,0].X];
            ignore[j] := Result.Paths[l] <> [];
            Result.Paths[l] += [hi];
            Result.Paths[hi] += l;
          end;
        Continue;
      end;

    skeleton := clusters[i].Erode(1).Skeleton(2, 6);

    nodes := [];
    for tpa in skeleton.Partition(Self.Spacing) do
      nodes += tpa.Cluster(1.5).Means();

    tree := TKDPointTree.Create(nodes);

    len := Length(Result.Nodes);
    SetLength(Result.Nodes, len + Length(nodes));
    SetLength(Result.Paths, Length(Result.Nodes));

    for j := 0 to High(tree.Data) do
    begin
      p := tree.Data[j].Split;
      for q in tree.KNearest(p, Self.MaxConnections*2, True) do
      begin
        if Max(Abs(p.X - q.X), Abs(p.Y - q.Y)) > maxSpacing then Continue;
        tpa := clusters[i].ExtractBox(TBox.Create(p, q).Expand(minSpacing));
        tpa := tpa.AStar(p, q, False);
        if (tpa = []) or (Length(tpa) > 80) then
          Continue;
        connectMap[q.Y,q.X] += j;
        if Inc(n) > Self.MaxConnections then
          Break;
      end;
      n := 0;
    end;

    for j := 0 to High(tree.Data) do
    begin
      p := tree.Data[j].Split;
      Result.Nodes[j+len] := TGraphNode.Create(p);
      for n in connectMap[p.Y,p.X] do
      begin
        q := tree.Data[n].Split;
        Result.Nodes[n+len] := TGraphNode.Create(q);

        if not Result.Paths[j+len].Contains(n+len) then
          Result.Paths[j+len] += n+len;
        if not Result.Paths[n+len].Contains(j+len) then
          Result.Paths[n+len] += j+len;
      end;
    end;

    for j in (doorMapA[i] + doorMapB[i]) do
    begin
      if ignore[j] then Continue;

      p := doors[j,0];
      l := doorMap[p.Y, p.X];

      for q in tree.KNearest(p, Self.MaxDoorConnections, True) do
      begin
        if Max(Abs(p.X - q.X), Abs(p.Y - q.Y)) > maxSpacing then
          Continue;
        n := Result.Nodes.IndexOf(q);
        //ignore[j] := Result.Paths[l] <> [];
        Result.Paths[l] += [n];
        Result.Paths[n] += l;
      end;
    end;
  end;
end;

function TWebGraphGenerator.BuildGraph(name: String; map: TImage): TWebGraph;
var
  white, red, gray, merged, graySubset: TPointArray;
  whiteClusters, grayClusters, mergedClusters: T2DPointArray;
  i, j: Integer;
  t: UInt64;
begin
  white := map.FindColor($FFFFFF, 0);
  red := map.FindColor($0000FF, 0);

  WriteLn GetDebugLn('Generating webgraph for region: ' + name);

  t := GetTimeRunning();
  Result := Self._BuildGraph(map, white, red);

  gray := map.FindColor($333333, 0);

  whiteClusters := white.Cluster(1);
  grayClusters := gray.Cluster(1);

  for i := 0 to High(whiteClusters) do
  begin
    if Length(whiteClusters[i]) <= 6 then Continue;

    graySubset := gray.ExtractBox(whiteclusters[i].Bounds().Expand(80));
    merged := whiteclusters[i] + graySubset;
    mergedClusters := merged.Cluster(1);

    for j := 0 to high(mergedClusters) do
      if mergedClusters[j].Contains(whiteClusters[i][0]) then
      begin
        Result.WalkableClusters += mergedClusters[j];
        Break;
      end;
  end;

  Result.WalkableSpace    := white + gray;
  Result.ObjectClusters   := grayClusters;

  WriteLn GetDebugLn('WebGraphGenerator', 'Generating webgraph took ' + ToStr(Round(((GetTimeRunning()-t)/1000), 2)) + ' seconds.', ELogLevel.SUCCESS);
end;
{$R+}

var
(*
## WebGraphGenerator variable
Global {ref}`TWebGraphGenerator` variable.
*)
  WebGraphGenerator: TWebGraphGenerator;
