(*
# Assets
Responsible for managing assets that WaspLib requires to run.
*)
{$DEFINE WL_ASSETS_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

type
  TWLAssets = record
    JSON: TJSONObject;
    Queue: TStringArray;
    URL: String;
    Timeout: TCountDown;
  end;

function TWLAssets.GetJSON(url: String): TJSONObject;
var
  parser: TJSONParser;
  response: String;
begin
  Self.URL := url;
  parser := new TJSONParser();

  try
    response := HTTPClient.Get(Self.URL + 'hashes.json');
  except
    WriteLn GetDebugLn('WLAssets', GetExceptionMessage(), ELogLevel.WARN);
    Exit(nil);
  end;

  if not InRange(HTTPClient.ResponseStatus.AsInteger, 200, 299) then
  begin
    WriteLn GetDebugLn('WLAssets', response, ELogLevel.WARN);
    Exit(nil);
  end;

  try
    parser.Parse(response);
  except
    WriteLn GetDebugLn('WLAssets', GetExceptionMessage(), ELogLevel.WARN);
    Exit(nil);
  end;

  Result := parser;
end;

function TWLAssets.LoadJSON(): TJSONObject;
var
  parser: TJSONParser;
begin
  WriteLn GetDebugLn('WLAssets', 'Couldn''t get assets information. WaspLib will attempt to run with whatever it has available.', ELogLevel.WARN);
  parser := new TJSONParser();

  try
    parser.Load(WLEnv.AssetsDir + 'hashes.json');
  except
    WriteLn GetDebugLn('WLAssets', GetExceptionMessage(), ELogLevel.WARN);
    Exit;
  end;

  Result := parser;
end;


procedure TWLAssets.DownloadFinished(constref result: TASyncHTTPResult);
var
  idx: Integer;
begin
  if not InRange(result.Response.AsInteger, 200, 299) then
  begin
    WriteLn GetDebugLn('WLAssets', result.Exception, ELogLevel.ERROR);
    raise GetDebugLn('WLAssets', 'If you keep having issues please delete your Assets and Cache folders.');
  end;
  idx := Self.Queue.IndexOf(result.Data);
  if idx = -1 then
    raise GetDebugLn('WLAssets', 'Can''t find ' + result.Data + ' in the download queue.');
  Delete(Self.Queue, idx, 1);
  Self.Timeout.Extend(-18 * ONE_SECOND);
end;

procedure TWLAssets.Update();
var
  i: Integer;
  timer: TCountDown;
  key, path: String;
begin
  Self.JSON := Self.GetJSON('https://db.waspscripts.dev/storage/v1/object/public/data/');

  if Self.JSON = nil then
    Self.JSON := Self.GetJSON('https://raw.githubusercontent.com/WaspScripts/wasp-data/refs/heads/main/');

  if Self.JSON = nil then
  begin
    Self.JSON := Self.LoadJSON();
    Exit;
  end;

  FileDelete(WLEnv.AssetsDir + 'hashes.json');
  TJSONParser(Self.JSON).Save(WLEnv.AssetsDir + 'hashes.json');

  Self.Timeout.Start(1);
  for i := 0 to Self.JSON.Count-1 do
  begin
    key := Self.JSON.Key[i];
    path := WLEnv.AssetsDir + key;
    if HashFile(EHashAlgo.CRC32, path) <> Self.JSON.Item[i].AsString then
    begin
      key := key.Replace('\', '/');
      WriteLn GetDebugLn('WLAssets', 'Updating ' + key, ELogLevel.WARN);
      FileDelete(path);
      DirCreate(PathExtractDir(path));
      Self.Queue += path;
      Self.Timeout.Extend(20 * ONE_SECOND);
      Async.HTTPGetFile(Self.URL + key, path, @Self.DownloadFinished);
    end;
  end;

  timer.Start(8 * ONE_SECOND);
  while Length(Self.Queue) > 0 do
  begin
    Sleep(100);

    if timer.IsFinished then
    begin
      WriteLn GetDebugLn('WLAssets', 'Downloading files. ' + ToStr(Length(Self.Queue)) + ' files left, please wait.');
      WriteLn GetDebugLn('WLAssets', 'Files left: ' + ToStr(Self.Queue).Replace(WLEnv.AssetsDir, ''));
      timer.Restart();
    end;

    if Self.Timeout.IsFinished then
    begin
      if Self.Queue = [] then Exit;
      for i := 0 to High(Self.Queue) do
        FileDelete(Self.Queue[i]);
      raise GetDebugLn('WLAssets', 'Timed out downloading assets: ' + ToStr(Self.Queue));
    end;
  end;
end;

var
  WLAssets: TWLAssets;
