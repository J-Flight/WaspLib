

{$DEFINE WL_MOUSE_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

{.$DEFINE WL_DEBUG_MOUSE}

{$IFDEF SIMBAHEADLESS}{$UNDEF WaspLib_DEBUG_MOUSE}{$ENDIF}


type
  EMouseDistribution = enum(DEFAULT, RANDOM, GAUSS, SKEWED, ROWP);


  PMouse = ^TMouse;

  TMouse = record
    Distribution: EMouseDistribution;

    MissChance: Double;
    IdleInterval, IdleProgress, IdleGoal: Double;
    CanIdle: Boolean;

    {$IFDEF WaspLib_DEBUG_MOUSE}
    DebugMovement: TSingleMatrix;
    DebugClicks: TSingleMatrix;
    {$ENDIF}
  end;

{$IFDEF WaspLib_DEBUG_MOUSE}
procedure TMouse._Debug();
var
  p: TPoint;
  i,x,y,wid,hei: Integer;
  clr, tol,heat: Integer;
  hue,sat: Double;
  m: TSingleMatrix;
  mats: array of TSingleMatrix;
  tmp,ClientBitmap, DebugBitmap: TImage;
  TPA: TPointArray;
  function AlphaColor(A,B: TColor; Weight: Double): TColor;
  var R1,R2,G1,G2,B1,B2: Integer;
  begin
    ColorToRGB(A, R1,G1,B1);
    ColorToRGB(A, R1,G1,B1);
    Result := RGBtoColor(Round(R1*weight+R2*(1-Weight)), Round(G1*weight+G2*(1-Weight)), Round(B1*weight+B2*(1-Weight)))
  end;
begin
  self.DebugLn('Generating a heatmap from clicks and movements...');

  ClientBitmap := Target.GetImage();
  DebugBitmap := ClientBitmap.Copy();
  wid := DebugBitmap.GetWidth();
  hei := DebugBitmap.GetHeight();
  DebugBitmap.SetSize(wid*2, hei);
  ClientBitmap.DrawTransparent(wid, 0, DebugBitmap);

  mats := [Self.DebugClicks, Self.DebugMovement];
  for i:=0 to High(mats) do
  begin
    SetLength(m, 0);
    SetLength(m, Length(mats[i]));
    for x:=0 to High(m) do m[x] := Copy(mats[i][x]);
    for 0 to 2 do m.Smoothen(3);
    if Length(m) = 0 then
	  continue;

    tmp.Init();
    tmp.DrawMatrix(m, 1);

    for y:=0 to tmp.GetHeight() - 1 do
      for x:=0 to tmp.GetWidth() - 1 do
        if tmp.GetPixel(x,y) <> 0 then
        begin
          heat := tmp.GetPixel(x,y);
          ACA([0,heat], 1, clr, tol, hue, sat);

          if tol < 20 then DebugBitmap.SetPixel(x+wid*i,y, AlphaColor(ClientBitmap.GetPixel(x,y), heat, 1-tol/20))
          else             DebugBitmap.SetPixel(x+wid*i,y,tmp.GetPixel(x,y));
        end;
    tmp.Free();
  end;

  ShowBitmap(DebugBitmap);
  ClientBitmap.Free();
  DebugBitmap.Free();
end;

procedure TMouse._DebugCallback(Sender: PMouse; X, Y: Integer); static;
var
  w,h: Integer;
begin
  GetClientDimensions(W,H);
  if Sender^.DebugMovement = nil then
  begin
    Sender^.DebugMovement.SetSize(W,H);
    AddOnTerminate(@Sender^._Debug);
  end;

  if InRange(x,0,W-1) and InRange(y,0,H-1) then
    Sender^.DebugMovement[y,x] += 1;
end;
{$ENDIF}


procedure TMouse.Setup();
begin
  Target.Options.MouseSpeed := 12;
  Target.Options.MouseGravity := 9;
  Target.Options.MouseWind := 5;

  Self.Distribution := EMouseDistribution.GAUSS;
  Self.CanIdle := True;

  {$IFDEF WaspLib_DEBUG_MOUSE}
  Self.OnTeleport := @Self._DebugCallback;
  {$ENDIF}
end;


procedure TMouse.Teleport(coordinate: TPoint);
begin
  Target.MouseTeleport(coordinate);
end;


property TMouse.Position: TPoint;
begin
  Result := Target.MouseXY;
end;

property TMouse.Position(value: TPoint);
begin
  Target.MouseMove(value);
end;


procedure TMouse.Hold(button: EMouseButton);
begin
  Target.MouseDown(button);
end;


procedure TMouse.Release(button: EMouseButton);
begin
  Target.MouseUp(button);
end;



procedure TMouse.Idle();
var
  t: UInt64 := RandomLeft(1000, 20000);
begin
  WriteLn(GetDebugLn('Mouse', 'Idle: ' + ToString(t) + ' ms'));
  Sleep(t);
end;


function TMouse.Miss(destination: TPoint): TPoint;
var
  range: Integer;
  miss: Double;
  Temp: Double := Self.MissChance;
begin
  Self.MissChance := 0; // prevent recursion

  try
    range := Trunc(Power(Self.Position.DistanceTo(destination), 0.80)); // how much possible range to miss
    miss := RandomMode(0.9, 0.1, 1.5); // Where miss will happen. 1 = destination.
    Result.X := Trunc((1-miss)*Self.Position.X + miss*destination.X);
    Result.Y := Trunc((1-miss)*Self.Position.Y + miss*destination.Y);

    Result := Result.Random(range);
  finally
    Self.MissChance := Temp;
  end;
end;



procedure TMouse.Move(destination: TPoint);
var
  start: TPoint;
  w, h: Integer;
begin
  if Self.CanIdle and (Self.IdleInterval > 0) then
  begin
    start := Target.MouseXY;
    w := Target.Width;
    h := Target.Height;

    if w < 0 then Exit;
    if h < 0 then Exit;

    if Self.IdleProgress = 0 then
      Self.IdleGoal := GaussRand(Self.IdleInterval, Self.IdleInterval * 0.20)
    else
    if Self.IdleProgress > Self.IdleGoal then
    begin
      Self.Idle();
      Self.IdleProgress := 0;

      if RandomBoolean(0.1) then // rarely throw a short interval in
        Self.IdleGoal := GaussRand(Self.IdleInterval / 2, Self.IdleInterval / 2 * 0.20)
      else
        Self.IdleGoal := GaussRand(Self.IdleInterval, Self.IdleInterval * 0.20);
    end;

    Self.IdleProgress += Hypot(start.X - destination.X, start.Y - destination.Y) / Hypot(w, h);
  end;

  if RandomBoolean(Self.MissChance) then
  begin
    Self.Move(Self.Miss(destination));
    if RandomBoolean(0.25) then
      Sleep(0, 5000, ERandomDir.LEFT);
  end;

  Target.MouseMove(destination);
end;

procedure TMouse.Move(circle: TCircle; forcedMove: Boolean = False; distribution: EMouseDistribution = EMouseDistribution.DEFAULT); overload;
begin
  if not forcedMove and circle.Contains(Target.MouseXY) then
    Exit;

  if distribution = EMouseDistribution.DEFAULT then
    distribution := Self.Distribution;

  case distribution of
    EMouseDistribution.RANDOM: Self.Move(circle.RandomPoint());
    EMouseDistribution.GAUSS:  Self.Move(circle.RandomPointCenter());
    EMouseDistribution.SKEWED: Self.Move(circle.RandomSkewedPoint(Self.Position));
    EMouseDistribution.ROWP:   Self.Position := circle.RandomWeightedPoint(Self.Position);
  end;
end;

procedure TMouse.Move(b: TBox; forcedMove: Boolean = False; distribution: EMouseDistribution = EMouseDistribution.DEFAULT); overload;
begin
  if not forcedMove and b.Contains(Target.MouseXY) then
    Exit;

  if distribution = EMouseDistribution.DEFAULT then
    distribution := Self.Distribution;

  case distribution of
    EMouseDistribution.RANDOM: Self.Move(b.RandomPoint());
    EMouseDistribution.GAUSS:  Self.Move(b.RandomPointCenter());
    EMouseDistribution.SKEWED: Self.Move(b.RandomSkewedPoint(Self.Position));
    EMouseDistribution.ROWP:   Self.Move(b.RandomWeightedPoint(Self.Position));
  end;
end;

procedure TMouse.Move(quad: TQuad; forcedMove: Boolean = False; distribution: EMouseDistribution = EMouseDistribution.DEFAULT); overload;
begin
  if not forcedMove and quad.Contains(Target.MouseXY) then
    Exit;

  if distribution = EMouseDistribution.DEFAULT then
    distribution := Self.Distribution;

  case distribution of
    EMouseDistribution.RANDOM: Self.Move(quad.RandomPoint());
    EMouseDistribution.GAUSS:  Self.Move(quad.RandomPointCenter());
    EMouseDistribution.SKEWED: Self.Move(quad.RandomSkewedPoint(Self.Position));
    EMouseDistribution.ROWP:   Self.Move(quad.RandomWeightedPoint(Self.Position));
  end;
end;



procedure TMouse.Click(button: EMouseButton);
begin
  Target.MouseClick(button);
end;

procedure TMouse.Click(destination: TPoint; button: EMouseButton); overload;
begin
  Self.Move(destination);
  Target.MouseClick(button);
end;

procedure TMouse.Click(circle: TCircle; button: EMouseButton; forcedMove: Boolean = False; distribution: EMouseDistribution = EMouseDistribution.DEFAULT); overload;
begin
  Self.Move(circle, forcedMove, distribution);
  Target.MouseClick(button);
end;

procedure TMouse.Click(box: TBox; button: EMouseButton; forcedMove: Boolean = False; distribution: EMouseDistribution = EMouseDistribution.DEFAULT); overload;
begin
  Self.Move(box, forcedMove, distribution);
  Target.MouseClick(button);
end;

procedure TMouse.Click(quad: TQuad; button: EMouseButton; forcedMove: Boolean = False; distribution: EMouseDistribution = EMouseDistribution.DEFAULT); overload;
begin
  Self.Move(quad, forcedMove, distribution);
  Target.MouseClick(button);
end;



procedure TMouse.Scroll(amount: Integer; down: Boolean);
begin
  if not down then
    amount := amount * -1;
  Target.MouseScroll(amount);
end;

procedure TMouse.Scroll(pt: TPoint; amount: Integer; down: Boolean); overload;
begin
  Self.Move(pt);
  Self.Scroll(amount, down);
end;

procedure TMouse.Scroll(box: TBox; amount: Integer; down: Boolean; forceMove: Boolean = False); overload;
begin
  Self.Move(box, forceMove);
  Self.Scroll(amount, down);
end;


var

  Mouse: TMouse;
