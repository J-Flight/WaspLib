(*
# WaspClient
Client to interact with the WaspScripts API and database.

The following compiler directives are available and are useful for local
development:
```pascal
{$DEFINE WASP_LOCAL_DEVELOPMENT}
{$DEFINE WASP_ACCESS_TOKEN := 'access_token'}
{$DEFINE WASP_REFRESH_TOKEN := 'refresh_token'}
{$DEFINE SCRIPT_ID := 'script_uuid'}
{$DEFINE SCRIPT_REVISION := 'script_revision'}
```
`WASP_LOCAL_DEVELOPMENT` is meant to be used with local server running the
(wasp-api)[https://github.com/WaspScripts/wasp-api], by default this server
runs on [http://localhost:3000/]

As for the others, you can get values for them by running Simba through
(wasp-launcher)[https://github.com/WaspScripts/wasp-launcher] and running
something like this:
```pascal
begin      
  WriteLn GetEnvVar('WASP_ACCESS_TOKEN');
  WriteLn GetEnvVar('WASP_REFRESH_TOKEN');
  WriteLn GetEnvVar('SCRIPT_ID');
  WriteLn GetEnvVar('SCRIPT_REVISION');
end.
```
Simply open a new tab and run that.

Things to keep in mind:
- The `WASP_REFRESH_TOKEN` you get may expire from time to time.
WaspLib automatically renews it every 5 mins and if you are using
`{$DEFINE WASP_REFRESH_TOKEN := 'refresh_token'}` you will get the new one
printed.
- Once you've done this once, your last refreshed token gets saved in a config
file, so you don't have keep refreshing tokens manually
between script runs you can set `{$DEFINE WASP_REFRESH_TOKEN := 'file'}` to load
the last one saved. Once it expires you will have to go get another one from the
launcher.
- You only get a `SCRIPT_ID` and `SCRIPT_REVISION` if you run a script through
(wasp-launcher)[https://github.com/WaspScripts/wasp-launcher]. Simply using it
to open a dev environment won't get those.
*)

{$DEFINE WL_WASPCLIENT_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

(*
## TWaspClient
Responsible for connecting to waspscripts.com database.
*)
type
  TWaspClient = record
    Script: record
      ID: String;
      Revision: UInt32;
    end;

    Client: THTTPClient;
    Server, Database, APIKey, Schema: String;

    User: record
      ID: String;
      Username: String;
    end;

    Payload: TJSONObject;
    Lock: TLock;
    IsSetup: Boolean;
    Timer: TCountDown;
    TimeRunning: TStopwatch;
  end;

procedure TWaspClient.Free();
begin
  Self.IsSetup := False;
  Async.ScheduleStop('WaspClient-RefreshToken');
end;

function TWaspClient.CreateSession(accessToken, refreshToken: String): Boolean;
var
  response: String;
  json: TJSONParser;
begin
  Self.Client.RequestHeader['Authorization'] := 'Bearer ' + accessToken;
  Self.Client.RequestHeader['RefreshToken'] := refreshToken;

  response := Self.Client.Get(Self.Server + 'session');
  WriteLn response;

  Result := InRange(Self.Client.ResponseStatus.AsInteger, 200, 299);
  if not Result then
  begin
    WriteLn GetDebugLn('WaspClient', response);
    Exit;
  end;

  json := new TJSONParser();
  json.Parse(response);

  Self.Client.RequestHeader['Authorization'] := 'Bearer ' + json.Item['access_token'].AsString;
  Self.Client.RequestHeader['RefreshToken'] := json.Item['refresh_token'].AsString;
end;

procedure TWaspClient.RefreshSession();
var
  payload, response: String;
  json: TJSONParser;
begin
  if not Self.Lock.TryEnter() then Exit;
  if not Self.IsSetup then Exit;

  payload := '{"refresh_token": "' + Self.Client.RequestHeader['RefreshToken'] + '"}';

  response := Self.Client.Post(
    Self.Database + 'auth/v1/token?grant_type=refresh_token', payload
  );

  if not InRange(Self.Client.ResponseStatus.AsInteger, 200, 299) then
  begin
    WriteLn GetDebugLn('WaspClient', response);
    Self.IsSetup := False;
    Self.Lock.Leave();
    Exit;
  end;

  json := new TJSONParser();
  json.Parse(response);

  Self.Client.RequestHeader['Authorization'] := 'Bearer ' + json.Item['access_token'].AsString;
  Self.Client.RequestHeader['RefreshToken'] := json.Item['refresh_token'].AsString;

  {$IFDEF WASP_ACCESS_TOKEN}
  FileWrite(WLEnv.ConfigsDir + 'access_token.txt', json.Item['access_token'].AsString);
  {$ENDIF}

  {$IFDEF WASP_REFRESH_TOKEN}
  FileWrite(WLEnv.ConfigsDir + 'refresh_token.txt', Self.User.RefreshToken);
  WriteLn GetDebugLn('WaspClient', 'Refresh token was refreshed: ' + Self.User.RefreshToken);
  {$ENDIF}

  with json.Item['user'] do
  begin
    Self.User.ID := Item['id'].AsString;
    Self.User.Username := Item['user_metadata'].Item['custom_claims'].Item['global_name'].AsString;
  end;
  Self.Lock.Leave();
end;

procedure TWaspClient.Setup();
var
  accessToken, refreshToken: String;
begin
  {$IFDEF WASP_LOCAL_DEVELOPMENT}
  Self.Server := 'http://localhost:3000/';
  {$ELSE}
  Self.Server := 'https://api.waspscripts.dev/';
  {$ENDIF}

  Self.Database := 'https://db.waspscripts.dev/';
  Self.APIKey := 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJzdXBhYmFzZSIsImlhdCI6MTc1MTA0MTIwMCwiZXhwIjo0OTA2NzE0ODAwLCJyb2xlIjoiYW5vbiJ9.C_KW5x45BpIyOQrnZc7CKYKjHe0yxB4l-fTSC4z_kYY';

  Self.Client := new THTTPClient();
  Self.Client.RequestHeader['Content-Type'] := 'application/json';
  Self.Client.RequestHeader['apikey'] := Self.APIKey;

  {$IFDEF WASP_ACCESS_TOKEN}
  accessToken := {$MACRO WASP_ACCESS_TOKEN};
  if accessToken = 'file' then
    accessToken := FileRead(WLEnv.ConfigsDir + 'access_token.txt');
  {$ELSE}
  accessToken := GetEnvVar('WASP_ACCESS_TOKEN');
  {$ENDIF}
  if accessToken = '' then
    Exit;

  {$IFDEF WASP_REFRESH_TOKEN}
  refreshToken := {$MACRO WASP_REFRESH_TOKEN};
  if refreshToken = 'file' then
    refreshToken := FileRead(WLEnv.ConfigsDir + 'refresh_token.txt');
  {$ELSE}
  refreshToken := GetEnvVar('WASP_REFRESH_TOKEN');
  {$ENDIF}

  if refreshToken = '' then
    Exit;

  {$IFDEF SCRIPT_ID}
  Self.Script.ID := {$MACRO SCRIPT_ID};
  {$ELSE}
  Self.Script.ID := GetEnvVar('SCRIPT_ID');
  {$ENDIF}

  if Self.Script.ID = '' then
    Exit;

  {$IFDEF SCRIPT_REVISION}
  Self.Script.Revision := StrToInt({$MACRO SCRIPT_REVISION}, 0);
  {$ELSE}
  Self.Script.Revision := StrToInt(GetEnvVar('SCRIPT_REVISION'), 0);
  {$ENDIF}

  Self.IsSetup := Self.CreateSession(accessToken, refreshToken);
  if not Self.IsSetup then
    Exit;

  Self.Payload := new TJSONObject();
  Self.Payload.AddInt('experience', 0);
  Self.Payload.AddInt('gold', 0);
  Self.Payload.AddInt('runtime', 0);

  Self.Lock := TLock.Create();
  Async.ScheduleEvery('WaspClient-RefreshToken', @Self.RefreshSession, 5 * ONE_MINUTE);
  AddOnTerminate(@Self.Free);
  AddOnTerminate(@Self.Lock.Free);
  Self.Timer.Start(5 * ONE_MINUTE);
  Self.TimeRunning.Start();
end;

function TWaspClient.SetSchema(schema: String = 'public'): Boolean;
begin
  if not Self.Lock.TryEnter() then Exit;
  if schema = 'public' then
    Self.Client.RequestHeader['Accept-Profile'] := ''
  else
    Self.Client.RequestHeader['Accept-Profile'] := schema;
  Self.Lock.Leave();
  Result := True;
end;

function TWaspClient.CheckScriptAccess(): Boolean;
var
  url: String;
begin
  if not Self.Lock.TryEnter() then Exit;
  if not Self.Script.ID.IsUUID() then Exit;

  url := Self.Database + 'storage/v1/object/authenticated/scripts/' +
         Self.Script.ID + '/000000001/script.simba';

  Result := Self.Client.Head(url) = EHTTPStatus.OK;
  Self.Lock.Leave();
end;


procedure TWaspClient.ResetPayload();
begin
  if not Self.IsSetup then Exit;
  if not Self.Lock.TryEnter() then Exit;

  Self.Payload.Item['experience'].AsInt := 0;
  Self.Payload.Item['gold'].AsInt := 0;
  Self.Payload.Item['runtime'].AsInt := 0;
  Self.Lock.Leave();
end;

procedure TWaspClient.UpdatePayload(xp, gp: Integer);
var
  item: TJSONItem;
begin
  if not Self.IsSetup then Exit;
  if not Self.Lock.TryEnter() then Exit;

  item := Self.Payload.Item['experience'];
  item.AsInt := item.AsInt + xp;
  item := Self.Payload.Item['gold'];
  item.AsInt := item.AsInt + gp;
  Self.Lock.Leave();
end;


procedure TWaspClient._SubmitStats();
var
  response: String;
  status: Integer;
  logLevel: ELogLevel;
begin
  if not Self.IsSetup then Exit;
  if not Self.Lock.TryEnter() then Exit;

  Self.Client.RequestHeader['Accept-Profile'] := 'stats';

  with Self.Payload.Item['runtime'] do
    AsInt := AsInt + Self.TimeRunning.Elapsed;
  Self.TimeRunning.Reset();
  response := Self.Client.Post(
                Self.Server + 'stats/' + Self.Script.ID + '/', Self.Payload.Format()
              );
  status := Self.Client.ResponseStatus.AsInteger;
  Self.Lock.Leave();

  if status > 299 then
    logLevel := ELogLevel.WARN;
  WriteLn GetDebugLn('WaspClient', '[' + ToStr(status) + ']: ' + response, logLevel);

  if InRange(status, 200, 299) then
    Self.ResetPayload();
end;

procedure TWaspClient.SubmitStats();
begin
  if not Self.IsSetup then Exit;
  if not Self.Timer.IsFinished then Exit;
  RunInThread(@Self._SubmitStats);
  Self.Timer.Restart();
end;

var
  WaspClient: TWaspClient;
