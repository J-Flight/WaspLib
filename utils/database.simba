
{$DEFINE WL_DATABASE_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

type
  TDatabase = record
    Name: String;
    Columns: TStringArray;
    Data: TStringMap<TStringArray>;
    Rows: TStringMap<TStringArray>;

    DataDir, CacheDir: String;
  end;

{%codetools off}
function TDatabase._ValueWeight(str: String): Integer;
var
  i: Integer;
begin
  for i := 1 to Length(str) do
    Result += Ord(str[i]);
end;
{%codetools on}


procedure TDatabase.Setup(name: String; columns: TStringArray; path, version: String);
var
  i: Integer;
  dir, tmp, column: String;
  data, rows: TStringArray;
  weights: TIntegerArray;
begin
  Self.Name := name + '.database';
  Self.CacheDir := WLEnv.CacheDir + 'databases' + PATH_SEP + name + PATH_SEP;

  //Delete old cache files if they exist
  for dir in DirList(Self.CacheDir) do
  begin
    tmp := Copy(dir, Length(dir)-Length(version)+1, Length(dir));
    if tmp = version then Continue;
    DirDelete(dir, False);
  end;

  Self.CacheDir += version + PATH_SEP;

  if not DirCreate(Self.CacheDir) then
    raise GetDebugLn(Self.Name, 'Failed to create cache directory: ' + Self.CacheDir);

  Self.DataDir := path;

  for column in columns do
  begin
    Self.Columns += column;

    //use cached files that are already sorted if they exist
    if FileExists(Self.CacheDir + column + '.txt') then
    begin
      Self.Data.Value[column] := FileReadLines(Self.CacheDir + column + '.txt');
      Self.Rows.Value[column] := FileReadLines(Self.CacheDir + column + '.rows');
      Continue;
    end;

    //no cache files found, we need to setup the column from scratch
    //check if column data file exists
    if not FileExists(Self.DataDir + column + '.txt') then
      raise GetDebugLn(Self.Name, 'Failed to find data file: ' + Self.DataDir + column + '.txt');

    //load the file data
    data := FileReadLines(Self.DataDir + column + '.txt');

    //create rows data, basically just the index of each line of the data file
    //to save time, we measure the weight of each data row for sorting later
    for i := 0 to High(data) do
    begin
      weights += Self._ValueWeight(data[i]);
      rows += ToStr(i);
    end;

    //sort both the data and the rows by the data weights
    data.Sort(weights, True);
    rows.Sort(weights, True);


    //set the column data and rows
    Self.Data.Value[column] := data;
    Self.Rows.Value[column] := rows;

    //at this point, our database column is setup.
    //when you want to look for something it works as follows:
    //- You look for the value you know on the column you know and find it's index
    //- You then retrieve row that matches that index because the Data and Rows
    //  were both sorted with the same weights, their indices match and the row you get back is the original row
    //  your value was at before sorting.
    //- After you have the original row value, you can look the column you want to get a value from
    //  search that columns rows for the matching original row number you have and save it's index
    //- You then go to your Data at that index and you have the matching data you are looking for.

    //Cache files so we don't have to sort stuff everytime

    if not FileWrite(Self.CacheDir + column + '.txt', data.Join(LINE_SEP)) then
      raise GetDebugLn(Self.Name, 'Failed to create cache file: ' + Self.CacheDir + column + '.txt');
    if not FileWrite(Self.CacheDir + column + '.rows', rows.Join(LINE_SEP)) then
      raise GetDebugLn(Self.Name, 'Failed to create cache file: ' + Self.CacheDir + column + '.rows');

    //reset variables.
    SetLength(weights, 0);
    SetLength(data, 0);
    SetLength(rows, 0);
  end;
end;




function TDatabase.Contains(value, column: String): Boolean;
begin
  Result := Self.Data.Value[column].Contains(value);
end;



function TDatabase.Get(value, column_name, result_column: String): String;
var
  idx: Integer;
  rows, data: TStringArray;
begin
  idx := Self.Data.Value[column_name].IndexOf(value);
  if idx = -1 then Exit;

  rows := Self.Rows.Value[column_name];
  data := Self.Data.Value[result_column];

  idx := Self.Rows.Value[result_column].IndexOf(rows[idx]);
  Result := data[idx];
end;


function TDatabase.GetAll(value, column_name, result_column: String): TStringArray;
var
  indices: TIntegerArray;
  idx: Integer;
  rows, data: TStringArray;
begin
  indices := Self.Data.Value[column_name].IndicesOf(value);
  if indices = [] then Exit;

  rows := Self.Rows.Value[column_name];
  data := Self.Data.Value[result_column];

  for idx in indices do
  begin
    idx := Self.Rows.Value[result_column].IndexOf(rows[idx]);
    Result += data[idx];
  end;
end;


procedure TDatabase.Insert(values: TStringArray; saveCache: Boolean = False);
var
  i, idx: Integer;
  value, column: String;
  data, rows: TStringArray;
  weights: TIntegerArray;
begin
  if Length(values) <> Length(Self.Columns) then
    raise GetDebugLn(Self.Name, 'The values being added are not the same length as the existing columns.');

  for i := 0 to High(values) do
  begin
    column := Self.Columns[i];
    value := values[i];
    idx := Self.Data.Value[column].Length;

    Self.Data.Value[column].Insert(value, idx);
    Self.Rows.Value[column].Insert(value, idx);

    data := Self.Data.Value[column];
    rows := Self.Rows.Value[column];

    for idx to High(data) do
      weights += Self._ValueWeight(data[idx]);

    Self.Data.Value[column].Sort(weights, True);
    Self.Rows.Value[column].Sort(weights, True);

    if saveCache then
    begin
      if not FileWrite(Self.CacheDir + column, Self.Data.Value[column].Join(LINE_SEP)) then
        raise GetDebugLn(Self.Name, 'Failed to create cache file: ' + Self.CacheDir + column);
      if not FileWrite(Self.CacheDir + column + '.rows', Self.rows.Value[column].Join(LINE_SEP)) then
        raise GetDebugLn(Self.Name, 'Failed to create cache file: ' + Self.CacheDir + column + '.rows');
    end;
  end;
end;
