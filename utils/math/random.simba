{$DEFINE WL_RANDOM_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

type
  ERandomDir = enum(LEFT, MEAN, RIGHT);

function RandomBoolean(): Boolean;
begin
  Result := Boolean(Random(0,1));
end;

function RandomBoolean(probability: Double): Boolean; overload;
begin
  Result := Random() <= probability;
end;

procedure Sleep(min, max: UInt32; dir: ERandomDir = ERandomDir.LEFT); overload;
begin
  case dir of
    ERandomDir.LEFT:  Sleep(RandomLeft(min, max));
    ERandomDir.MEAN:  Sleep(Random(min, max));
    ERandomDir.RIGHT: Sleep(RandomRight(min, max));
  end;
end;

function TPoint.RandomBetween(other: TPoint): TPoint;
var
  r: Double;
begin
  r := System.Random();
  Result.X := Self.X + Round(r * (other.X - Self.X));
  Result.Y := Self.Y + Round(r * (other.Y - Self.Y));
end;


function TPointArray.RandomMean(): TPoint;
var
  sorted: TPointArray;
begin
  if Length(Self) = 0 then Exit;
  Result := Self.SortFrom(Self.Mean())[RandomLeft(0, High(Self))];
end;


function TCircle.RandomPointInSectorWithRadialBias(AngleMin, AngleMax: Double; Bias: Double): TPoint;
var
  Angle: Double;
  RndRadiusNormalized: Double; // Random radius in [0, 1]
  RndRadius: Double;
  P: TPoint;
begin
  // Generate a random angle within the specified sector
  Angle := AngleMin + Random * (AngleMax - AngleMin);

  // Generate a random normalized radius [0, 1]
  // This is the core of the radial bias for the crescent shape
  //
  // Bias = 0: behaves like Sqrt(Random) for area uniform distribution
  // RndRadiusNormalized := Sqrt(Random);
  //
  // Bias = 1: RndRadiusNormalized will always be 1 (points on edge)
  // RndRadiusNormalized := 1.0;
  //
  // Intermediate Bias: Blend between uniform area and edge.
  // The expression `1 - Sqrt(1 - Random)` biases towards 1.
  // The expression `Sqrt(Random)` biases towards 0.
  // We'll blend these based on `Bias`.

  // A simple blend for radial bias:
  // (1-Bias) * Sqrt(Random) + Bias * (1 - Sqrt(1 - Random))  // This biases towards larger radii
  // or a simpler `Power(Random, Bias)` where Bias < 1 for outer bias.
  // Let's use an interpolated version to control the "thickness" of the crescent.

  // Linear interpolation between interior distribution and edge-biased distribution
  // The `Random` here produces a uniform [0,1] value.
  // `Power(Random, (1-Bias)*4 + 0.1)` : If Bias is 1, Power is 0.1 (strong outer bias). If Bias is 0, Power is 4.1 (strong inner bias)
  // This can be tricky. Let's use a simpler, more direct approach:

  // Option 1: Blend between area distribution and edge distribution
  RndRadiusNormalized := (1 - Bias) * Sqrt(Random) + Bias * (1 - Sqrt(1 - Random));
  // The `1 - Sqrt(1 - Random)` part generates values biased towards 1.0

  // Option 2: Using `Power(Random, Exponent)`
  // Exponent > 1 (e.g., 2, 3) biases towards 0 (center)
  // Exponent < 1 (e.g., 0.5, 0.2) biases towards 1 (edge)
  // We want the bias to increase with the `Bias` parameter.
  // A higher `Bias` should mean a smaller exponent to push points outwards.
  // Let's map Bias [0,1] to Exponent [2, 0.1] (adjust 2 and 0.1 for desired range)
  // var Exponent: Double;
  // Exponent := 2 - Bias * 1.9; // 2 when Bias=0, 0.1 when Bias=1
  // RndRadiusNormalized := Power(Random, Exponent);


  // Apply the normalized radius to the actual circle radius
  RndRadius := Self.Radius * RndRadiusNormalized;

  // Calculate the coordinates relative to the circle's center
  P.X := Self.X + Round(RndRadius * Cos(Angle));
  P.Y := Self.Y + Round(RndRadius * Sin(Angle));

  Result := P;
end;


(*
## TQuad.RandomWeightedPoint
```pascal
function TQuad.RandomWeightedPoint(from: TPoint; force: Double=-0.9; smoothness: Single = PI / 12): TPoint;
```
Originally known as "ROWP", short for `Random Olly Weighted Point`.
Generates a random point based on a rough formula that Olly came up with for
weighting points towards `from` point.

Final implementation and math done by slacky.

Force ranges from -1 (close to) to 1 (away from), where 0 is mean, but with a bit of a skewiness...
*)
function TQuad.RandomWeightedPoint(from: TPoint; force: Double = -0.9; smoothness: Single = PI / 12): TPoint;
var
  pt, edge: TPoint;
  t, dist, cutoff: Double;
begin
  cutoff := RandCutoff;
  RandCutoff := 5.0 / 1.5;
  pt := Self.RandomPointCenter();
  edge := Self.NearestEdge(pt);

  dist := Hypot(pt.X - edge.X, pt.Y - edge.Y);
  t := ArcTan2(pt.Y-from.Y, pt.X-from.X) + (Random()-0.5) * smoothness;

  RandCutoff := 5.0;
  Result.X := Round(pt.x + Cos(t) * RandomMode(dist * force, 0, dist));
  Result.Y := Round(pt.y + Sin(t) * RandomMode(dist * force, 0, dist));

  RandCutoff := cutoff;
end;

(*
## TQuad.RandomSkewedPoint
```pascal
function TQuad.RandomSkewedPoint(from: TPoint; force: Double = 0.35): TPoint;
```
Generates a random point within the bounds of the TQuad, the point generated is skewed towards towards the `from`-point.
The last parameter `force` defines how much the generated point is to be skewed towards or away from `from` - Expects value in the range 0..2

- force = 0: Result weighs heavily towrads the edge closest to `From`
- force = 1: Result in the middle of box is most common
- force = 2: Result weighs heavily towrads the edge furthest away from `From`
*)
function TQuad.RandomSkewedPoint(from: TPoint; force: Double = 0.35): TPoint;
var
  bounds: TBox;
  center, skewed: TPoint;
  r, angle, cutoff: Double;
begin
  bounds := Self.Bounds;

  if from.X < bounds.X1 then from.X := bounds.X1 else if from.X > bounds.X2 then from.X := bounds.X2;
  if from.Y < bounds.Y1 then from.Y := bounds.Y1 else if from.Y > bounds.Y2 then from.Y := bounds.Y2;

  center := Self.Mean;

  r := Hypot(from.X - center.X, from.Y - center.Y) * force;
  angle := ArcTan2(center.Y - from.Y, center.X - from.X);

  skewed.X := from.X + Round(Cos(angle) * r);
  skewed.Y := from.Y + Round(Sin(angle) * r);

  cutoff := RandCutoff;
  RandCutoff := 4.0;

  Result.X := Round(RandomMode(skewed.X, bounds.X1, bounds.X2));
  Result.Y := Round(RandomMode(skewed.Y, bounds.Y1, bounds.Y2));

  RandCutoff := cutoff;
end;


(*
## TBox.RandomWeightedPoint
```pascal
function TBox.RandomWeightedPoint(from: TPoint; force: Double=-0.9; smoothness: Single = PI / 12): TPoint;
```
Same as {ref}`TQuad.RandomWeightedPoint` but for `TBox`.
*)
function TBox.RandomWeightedPoint(from: TPoint; force: Double = -0.9; smoothness: Double = PI / 12): TPoint;
begin
  Result := TQuad.CreateFromBox(Self).RandomWeightedPoint(from, force, smoothness);
end;

(*
## TBox.RandomSkewedPoint
```pascal
function TBox.RandomSkewedPoint(from: TPoint; force: Double = 0.35): TPoint;
```
Generates a random point within the bounds of the TBox, the point generated is skewed towards towards the `from`-point.
The last parameter `force` defines how much the generated point is to be skewed towards or away from `from` - Expects value in the range 0..2

- force = 0: Result weighs heavily towrads the edge closest to `From`
- force = 1: Result in the middle of box is most common
- force = 2: Result weighs heavily towrads the edge furthest away from `From`
*)
function TBox.RandomSkewedPoint(from: TPoint; force: Double = 0.35): TPoint;
var
  c: TPoint;
  cutoff, x, r: Double;
begin
  if from.x < Self.x1 then from.x := Self.x1 else if from.x > Self.x2 then from.x := Self.x2;
  if from.y < Self.y1 then from.y := Self.y1 else if from.y > Self.y2 then from.y := Self.y2;

  c :=  Point((Self.X2 + Self.X1) div 2, (Self.Y2 + Self.Y1) div 2);
  r := Hypot(from.x-c.x, from.y-c.y) * force;
  x := ArcTan2(c.y-from.y, c.x-from.x);

  from.x += Round(Cos(x) * r);
  from.y += Round(Sin(x) * r);

  cutoff := RandCutoff;
  RandCutoff := 4.0;
  Result.x := Round(RandomMode(from.x, Self.X1, Self.X2));
  Result.y := Round(RandomMode(from.y, Self.Y1, Self.Y2));
  RandCutoff := cutoff;
end;

