(*
# WebGraph
Responsible for handling webwalking or any other graph logic you may need.

It's partially based on the original webgraph logic by [slacky](https://slacky.one/)
but it was written from scratch by Torwent.

It's important to note that most types and methods are for internal usage and
you shouldn't really have to interact with it.
*)

{$DEFINE WL_WEBGRAPH_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

{$R-}

{$IFDEF RANGECHECKS}
begin
  WriteLn GetDebugLn('WebGraph', 'Range checks are enabled for webgraphs, these should be disabled in production!', ELogLevel.WARN);
end;
{$ENDIF}

type
(*
(TWebGraph)=
## type TWebGraph
Type representing a webgraph, for more information on what a graph is in this
context visit this [wikipedia page](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics))
*)
  TWebGraph = record
    Nodes: TPointArray;
    Paths: T2DIntegerArray;
    WalkableSpace: TPointArray;
    WalkableClusters, ObjectClusters: T2DPointArray;
    Blocking: TIntegerArray;
    Tree: TKDPointTree;
  end;

  PWebGraph = ^TWebGraph;

(*
## TWebGraph.Setup
```pascal
procedure TWebGraph.Setup();
```
It sets up `TWebGraph.Tree`, a {ref}`TKDPointTree` used to compare distances between
nodes very fast.
*)
procedure TWebGraph.Setup();
begin
  Self.Tree := TKDPointTree.Create(Self.Nodes.Copy());
end;


(*
## TWebGraph.Copy
```pascal
function TWebGraph.Copy(): TWebGraph;
```
Performs a unique copy of the `TWebGraph` which you can modify without modifying the original.
Useful for debugging graphs when you need to keep the original unchanged, e.g.
with the {ref}`Map Debugger`.
*)
function TWebGraph.Copy(): TWebGraph;
begin
  Result.Nodes := System.Copy(Self.Nodes);
  Result.WalkableSpace := System.Copy(Self.WalkableSpace);
  Result.WalkableClusters := System.Copy(Self.WalkableClusters);
  Result.ObjectClusters := System.Copy(Self.ObjectClusters);
  Result.Setup();
end;


(*
## TWebGraph.BlockArea
```pascal
procedure TWebGraph.BlockArea(area: TBox; inside: Boolean = True);
```
Blocks an area of the `TWebGraph` so no nodes in the specified `area` are returned
when finding paths.

For example, this is how you could block the space where wintertodt is so
you don't get paths through the chasm:
```pascal
Map.Setup([ERSChunk.WINTERTODT]);
Map.Loader.Graph.BlockArea([6478, 34358, 6565, 34445]);
```
*)
procedure TWebGraph.BlockArea(area: TBox; inside: Boolean = True);
var
  i, c: Integer;
begin
  SetLength(Self.Blocking, Length(Self.Nodes));

  if inside then
  begin
    for i := 0 to High(Self.Nodes) do
    if area.Contains(Self.Nodes[i]) then
    begin
      Self.Blocking[c] := i;
      Inc(c);
    end;
  end
  else
  begin
    for i := 0 to High(Self.Nodes) do
      if (not Area.Contains(Self.Nodes[i])) then
      begin
        Self.Blocking[c] := i;
        Inc(c);
      end;
  end;

  SetLength(Self.Blocking, c);
end;


(*
## TWebGraph.NearNodesIndices
```pascal
function TWebGraph.NearNodesIndices(pt: TPoint; amount: Integer): TIntegerArray;
```
Returns the indices of the `amount` of nearest nodes to `pt` on the webgraph
that can be walked to to and from `pt`.

The result returned is sorted by shortest distance to `pt`.
*)
function TWebGraph.NearNodesIndices(pt: TPoint; amount: Integer): TIntegerArray;
var
  i, n: Integer;
  weights: TDoubleArray;
  tpa: TPointArray;
begin
  tpa := Self.Tree.KNearest(pt, amount);
  for i := 0 to High(tpa) do
    if Self.WalkableClusters.InSameTPA(pt, tpa[i]) then
    begin
      n := Self.Nodes.IndexOf(tpa[i]);
      if n = -1 then Continue;
      Result += n;
      weights += pt.DistanceTo(tpa[i]);
    end;

  if Result = [] then
    for i := 0 to High(tpa) do
    begin
      n := Self.Nodes.IndexOf(tpa[i]);
      if n = -1 then Continue;
      Result += n;
      weights += pt.DistanceTo(tpa[i]);
    end;

  Result.Sort(weights, True);
end;


(*
## TWebGraph.FindPath
```pascal
function TWebGraph.FindPath(start, finish: Integer; rnd: Double = 0): TIntegerArray;
```
Finds a path between `start` and `finish` with the ability to introduce some
randomness through `rnd`.

This is basically a weighted BFS algorithm.

For more information on the algorithm read the [wikipedia page on breadth-first search](https://en.wikipedia.org/wiki/Breadth-first_search).
*)
function TWebGraph.FindPath(start, finish: Integer; rnd: Double = 0): TIntegerArray;
type TNode = record Indices: TIntegerArray; Score: Double; end;
var queue: array of TNode;

  function GetNextShortest(): TNode;
  var
    i, node: Integer;
  begin
    Result := queue[0];
    for i := 1 to High(queue) do
      if queue[i].Score < Result.Score then
      begin
        node   := i;
        Result := queue[i];
      end;
    Delete(queue, node, 1);
  end;

var
  visited: TBooleanArray;
  cIdx, pathIdx, i: Integer;
  current, node: TNode;
  p, q: TPoint;
  hyp: Double;
begin
  queue   := [[[start],0]];
  SetLength(visited, Length(Self.Nodes));

  for i in Self.Blocking do
    visited[i] := True;

  while Length(queue) <> 0 do
  begin
    current := GetNextShortest();
    cIdx := current.Indices[High(current.Indices)];

    if visited[cIdx] then
      Continue;

    visited[cIdx] := True;

    if cIdx = finish then
      Exit(current.Indices);

    p := Self.Nodes[cIdx];

    for pathIdx in Self.Paths[cIdx] do
    begin
      if visited[pathIdx] then
        Continue;

      node.Indices := current.Indices + pathIdx;

      q := Self.Nodes[pathIdx];
      hyp := Hypot(p.X-q.X, p.Y-q.Y);
      node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 1;
      queue += node;
    end;
  end;
end;

(*
## TWebGraph.PathBetween
```pascal
function TWebGraph.PathBetween(a, b: TPoint; rnd: Double = 0; attempts: Integer = 3): TPointArray;
```
Returns a path between `a` and `b` with the ability to introduce some randomness
through `rnd`.

The returned path comes in the form of a `TPointArray`.
*)
function TWebGraph.PathBetween(a, b: TPoint; rnd: Double = 0; attempts: Integer = 3): TPointArray;
var
  i, j: Integer;
  nS, nG, indices: TIntegerArray;
begin
  nS := Self.NearNodesIndices(a, attempts);
  nG := Self.NearNodesIndices(b, attempts);

  if nS[0] = nG[0] then
    Exit([a, b]);

  if (Length(nG) = 1) and (Self.Paths[nG[0]] = []) then
    raise GetDebugLn('WebGraph', 'Points ' + ToStr(a) + ' and ' + ToStr(b) + ' don''t connect! No paths available.');

  for i := 0 to High(nS) do
  begin
    if nS[i] = -1 then
      Continue;
    for j := 0 to High(nG) do
    begin
      if nG[j] = -1 then
        Continue;
      if nS[i] = nG[j] then Continue;

      indices := Self.FindPath(nS[i],nG[j], rnd);
      if Length(indices) > 0 then
        Break(2);
    end;
  end;

  if Length(indices) = 0 then
    raise GetDebugLn('WebGraph', 'Points ' + ToStr(a) + ' and ' + ToStr(b) + ' don''t connect!');

  Result += a;
  for i in indices do
    Result += Self.Nodes[i];
  Result += b;
end;


(*
## TWebGraph.PathToNear
```pascal
function TWebGraph.PathToNear(a: TPoint; out b: TPoint; rnd: Double = 0): TPointArray;
```
Returns a path between `a` and and whatever the nearest node to `b` is with the
ability to introduce some randomness through `rnd`.

The nearest node to `b` is also returned through `b`.

The returned path comes in the form of a `TPointArray`.
*)
function TWebGraph.PathToNear(a: TPoint; out b: TPoint; rnd: Double = 0): TPointArray;
var
  i: Integer;
  cluster: TPointArray;
  best: TIntegerArray;
begin
  for i := 0 to High(Self.WalkableClusters) do
    if Self.WalkableClusters[i].Contains(a) then
    begin
      cluster := Self.WalkableClusters[i];
      Break;
    end;

  if cluster = [] then
    raise GetDebugLn('WebGraph', 'Can''t find player cluster containg: ' + ToStr(a));

  best := Self.NearNodesIndices(b, 12);
  for i := 0 to High(best) do
  begin
    b := Self.Nodes[best[i]];
    if cluster.Contains(b) then
      Exit(Self.PathBetween(a, b, rnd, 2));
  end;
end;


(*
## TWebGraph.AddNode
```pascal
function TWebGraph.AddNode(pt: TPoint; fromNode: Integer): Boolean;
```
Adds a new node to the `TWebGraph` with a connection to `fromNode`.

You can specify it's coordinate through `pt`.
*)
function TWebGraph.AddNode(pt: TPoint; fromNode: Integer): Boolean;
var
  i: Integer;
begin
  if fromNode < 0 then
    Exit(False);

  i := Length(Self.Nodes);
  SetLength(Self.Nodes, i+1);
  SetLength(Self.Paths, i+1);
  Self.Nodes[i] := pt;

  Self.Paths[fromNode] += i;
  Self.Paths[i] += fromNode;
  Result := True;
end;


(*
## TWebGraph.ConnectNodes
```pascal
procedure TWebGraph.ConnectNodes(a,b: Integer);
procedure TWebGraph.ConnectNodes(a,b: TPoint); overload;
procedure TWebGraph.ConnectNodes(a: Integer; b: TPoint); overload;
```
Connects nodes `a` and `b`.

If either `a` or `b` are `TPoints`, they must match exactly the coordinates of a
node in the graph.

Using indices is always better for performance but overtime they may change if
the shape of the graph changes.
*)
procedure TWebGraph.ConnectNodes(a,b: Integer);
begin
  if not Self.Paths[a].Contains(b) then
    Self.Paths[a] += b;
  if not Self.Paths[b].Contains(a) then
    Self.Paths[b] += a;
end;

procedure TWebGraph.ConnectNodes(a,b: TPoint); overload;
var
  i, idxA, idxB: Integer;
begin
  idxA := -1;
  idxB := -1;

  for i := 0 to High(Self.Nodes) do
  begin
    if (idxA = -1) and (Self.Nodes[i] = a) then
      idxA := i
    else if (idxB = -1) and (Self.Nodes[i] = b) then
      idxB := i;

    if (idxA <> -1) and (idxB <> -1) then
      Break;
  end;

  Self.ConnectNodes(idxA,idxB);
end;

procedure TWebGraph.ConnectNodes(a: Integer; b: TPoint); overload;
var
  i: Integer;
begin
  i := Self.Nodes.IndexOf(b);
  if i = -1 then Exit;

  Self.ConnectNodes(a, i);
end;

(*
## TWebGraph.ConnectNodesEx
```pascal
procedure TWebGraph.ConnectNodesEx(a,b: TPoint; notEqual: Boolean = False);
```
Connects the closest node to `a` to the closest node to `b`.

This is similar to {ref}`TWebGraph.ConnectNodes` when using `TPoints` but unlike
it, your points don't have to be the exact same as the nodes in the graph.

Overall, this is the most flexible and easiest method to use but it might not
connect exactly the nodes you want at times.
*)
procedure TWebGraph.ConnectNodesEx(a,b: TPoint; notEqual: Boolean = False);
var
  p, q: TPoint;
begin
  p := Self.Tree.Nearest(a, notEqual);
  q := Self.Tree.Nearest(b, notEqual);

  Self.ConnectNodes(p,q);
end;


(*
## TWebGraph.DeleteNode
```pascal
function TWebGraph.DeleteNode(node: Integer): Integer;
```
Deletes a `Node` from a `TWebGraph` along with all the connections to it.
*)
function TWebGraph.DeleteNode(node: Integer): Integer;
var
  i,j,n,curr: Integer;
  marked: TIntegerArray;
begin
  marked += node;
  repeat
    curr := marked.Pop;

    for n in Self.Paths[curr] do
    begin
      Self.Paths[n].Remove(curr);
      if Self.Paths[n] = [] then
        marked += n;
    end;

    // offset remainding nodes
    for i:=0 to High(Self.Paths) do
      for j:=0 to High(Self.Paths[i]) do
        if Self.Paths[i][j] > curr then
          Dec(Self.Paths[i][j]);

    for i:=0 to High(marked) do
      if marked[i] > curr then Dec(marked[i]);

    // remove the node itself
    Delete(Self.Paths, curr, 1);
    Delete(Self.Nodes, curr, 1);
    Result += 1;
  until Length(marked) = 0;
end;

(*
## TWebGraph.DeleteNodes
```pascal
procedure TWebGraph.DeleteNodes(b: TBox);
```
It's very similar to {ref}`TWebGraph.BlockNodes` but unlike it, what this does
is permanent. Blocking nodes could be used to selectively toggle nodes on/off,
this permanently removes them.

For example, this is how you could block the space where wintertodt is so
you don't get paths through the chasm:
```pascal
Map.Setup([ERSChunk.WINTERTODT]);
Map.Loader.Graph.DeleteNodes([6478, 34358, 6565, 34445]);
```
*)
procedure TWebGraph.DeleteNodes(b: TBox);
var
  i: Integer;
begin
  for i := High(Self.Nodes) downto 0 do
    if b.Contains(Self.Nodes[i]) then
      Self.DeleteNode(i);
end;


(*
## TWebGraph.Merge
```pascal
procedure TWebGraph.Merge(graph: TWebGraph);
```
Merges `graph` into the current `TWebGraph`.
*)
procedure TWebGraph.Merge(graph: TWebGraph);
var
  i, j, len: Integer;
begin
  len := Length(Self.Nodes);

  for i := 0 to High(graph.Nodes) do
  begin
    Self.Nodes += graph.Nodes[i];
    Self.Paths += graph.Paths[i];

    for j := 0 to High(Self.Paths[len+i]) do
      Self.Paths[len+i,j] += len;
  end;

  Self.WalkableSpace    += graph.WalkableSpace;
  Self.WalkableClusters += graph.WalkableClusters;
  Self.ObjectClusters   += graph.ObjectClusters;
end;


(*
## TWebGraph.Draw
```pascal
procedure TWebGraph.Draw(img: TImage);
procedure TWebGraph.Draw(canvas: TImageBoxCanvas); overload;
```
Used for `TWebGraph` debugging.
*)
procedure TWebGraph.Draw(img: TImage);
var
  i,j: Integer;
begin
  if Self.Nodes = [] then Exit;

  img.DrawColor := $00EAEA;
  for i := 0 to High(Self.Paths) do
    for j := 0 to High(Self.Paths[i]) do
      img.DrawLine(Self.Nodes[i], Self.Nodes[Self.Paths[i, j]]);

  img.DrawColor := $0101CC;
  for i := 0 to High(Self.Nodes) do
    img.DrawBox(TBox.Create(Self.Nodes[i], 1, 1));
end;

procedure TWebGraph.Draw(canvas: TImageBoxCanvas); overload;
var
  i,j: Integer;
begin
  if Self.Nodes = [] then Exit;

  for i := 0 to High(Self.Paths) do
    for j := 0 to High(Self.Paths[i]) do
      canvas.DrawLine(Self.Nodes[i], Self.Nodes[Self.Paths[i, j]], $00EAEA);

  for i := 0 to High(Self.Nodes) do
    canvas.DrawBoxFilled(TBox.Create(Self.Nodes[i], 1, 1), $0101CC);
end;
{$R+}
