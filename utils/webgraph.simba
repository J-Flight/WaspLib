(*
# WebGraph
Responsible for handling webwalking or any other graph logic you may need.

It's partially based on the original webgraph logic by [slacky](https://slacky.one/)
but it was written from scratch by Torwent.
*)

{$DEFINE WL_WEBGRAPH_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

type
(*
## EGraphNode
```pascal
EGraphNode = enum(NORMAL, NAMED, DOOR, LADDER, AGILITY, OBSTACLE, OTHER, BLOCKED);
```
Enum representing the type of nodes in a `TWebGraph`.
*)
  EGraphNode = enum(NORMAL, NAMED, DOOR, LADDER, AGILITY, OBSTACLE, OTHER, BLOCKED);
  EGraphNodeArray = array of EGraphNode;

  TWebGraph = record
    Nodes: TPointArray;
    Paths: T2DIntegerArray;
    Data: EGraphNodeArray;
    Names: TStringArray;

    WalkableSpace: TPointArray;
    WalkableClusters, ObjectClusters: T2DPointArray;
    Tree: TKDPointTree;
  end;

procedure TWebGraph.Setup();
begin
  Self.Tree := TKDPointTree.Create(System.Copy(Self.Nodes));
end;

function TWebGraph.Copy(): TWebGraph;
begin
  Result.Nodes    := System.Copy(Self.Nodes);
  Result.Paths    := System.Copy(Self.Paths);
  Result.Data     := System.Copy(Self.Data);
  Result.Names    := System.Copy(Self.Names);

  Result.WalkableSpace    := System.Copy(Self.WalkableSpace);
  Result.WalkableClusters := System.Copy(Self.WalkableClusters);
  Result.ObjectClusters   := System.Copy(Self.ObjectClusters);
  Result.Tree := TKDPointTree.Create(System.Copy(Result.Nodes));
end;

procedure TWebGraph.BlockArea(area: TBox; inside: Boolean = True);
var
  i: Integer;
begin
  if inside then
  begin
    for i := 0 to High(Self.Nodes) do
      if area.Contains(Self.Nodes[i]) then
        Self.Data[i] := EGraphNode.BLOCKED;
    Exit;
  end;

  for i := 0 to High(Self.Nodes) do
    if not area.Contains(Self.Nodes[i]) then
      Self.Data[i] := EGraphNode.BLOCKED;
end;


function TWebGraph.NearestNode(pt: TPoint): TPoint;
begin
  Result := Self.Tree.Nearest(pt, False);
  if not Self.WalkableClusters.InSameTPA(pt, Result) then
    raise GetDebugLn('WebGraph', 'No near nodes were found around point ' + ToStr(pt));
end;

function TWebGraph.NearNodes(pt: TPoint; amount: Integer): TPointArray;
begin
  Result := Self.Tree.KNearest(pt, amount);
end;


function TWebGraph.NearestNodeIndex(pt: TPoint): Integer;
var
  q: TPoint;
begin
  q := Self.Tree.Nearest(pt, False);
  if not Self.WalkableClusters.InSameTPA(pt, q) then
    raise GetDebugLn('WebGraph', 'No near nodes were found around point ' + ToStr(pt));
  Result := Self.Nodes.IndexOf(q);
end;

function TWebGraph.NearNodesIndices(pt: TPoint; amount: Integer): TIntegerArray;
var
  i: Integer;
  weights: TDoubleArray;
  tpa: TPointArray;
begin
  tpa := Self.NearNodes(pt, amount);

  for i := 0 to High(tpa) do
    if Self.WalkableClusters.InSameTPA(pt, tpa[i]) then
    begin
      Result += Self.Nodes.IndexOf(tpa[i]);
      weights += pt.DistanceTo(tpa[i]);
    end;

  if Result = [] then
    raise GetDebugLn('WebGraph', 'No near nodes were found around point ' + ToStr(pt));

  Result.Sort(weights, True);
end;


function TWebGraph.FindPath(start, finish: Integer; rnd:Double=0): TIntegerArray;
type
  TNode = record
    Indices: TIntegerArray;
    Score: Double;
  end;
var
  queue: array of TNode;
  visited: TBooleanArray;
  cIdx, pathIdx, i: Integer;
  current, node: TNode;
  p, q: TPoint;
  hyp: Double;

  function GetNextShortest(): TNode;
  var i, node: Integer;
  begin
    Result := queue[0];
    for i := 1 to High(queue) do
      if queue[i].Score < Result.Score then
      begin
        node   := i;
        Result := queue[i];
      end;
    Delete(queue, node, 1);
  end;
begin
  queue   := [[[start],0]];
  SetLength(visited, Length(Self.Nodes));

  while Length(queue) <> 0 do
  begin
    current := GetNextShortest();
    cIdx := current.Indices[High(current.Indices)];
    if (Self.Data[cIdx] = EGraphNode.BLOCKED) or visited[cIdx] then
      Continue;
    visited[cIdx] := True;

    if (cIdx = finish) then
      Exit(current.Indices);

    p := Self.Nodes[cIdx];
    for pathIdx in Self.Paths[cIdx] do
    begin
      if not visited[pathIdx] then
      begin
        q := Self.Nodes[pathIdx];
        node.Indices := current.Indices + pathIdx;

        hyp := Hypot(p.x-q.x, p.y-q.y);
        node.Score   := current.Score + hyp + (hyp*Random()*Rnd-Rnd/2);
        queue += node;
      end;
    end;
  end;
end;




function TWebGraph.NearestWalkablePoint(p: TPoint): TPoint;
var
  pArea, obj, tpa, bestObj: TPointArray;
  pAreaClusters: T2DPointArray;
  i, bestLength, tempLength: Integer;
begin
  pArea := TPointArray.CreateFromCircle(p, 20, True).Intersection(Self.WalkableSpace);
  pAreaClusters := pArea.Cluster(1);

  if Self.ObjectClusters = [] then Exit(pArea.NearestPoint(p));

  obj := [];
  for i := 0 to High(Self.ObjectClusters) do
  begin
    if not Self.ObjectClusters[i].Bounds().Contains(p) then Continue;
    if Self.ObjectClusters[i].Contains(p) then
    begin
      obj := Self.ObjectClusters[i];
      {$IFDEF DEBUG_WALKER}
      WriteLn('Point was inside object! with edges: ', obj);
      {$ENDIF}
      Break;
    end;
  end;

  if obj = [] then Exit(pArea.NearestPoint(p));

  for i := 0 to High(pAreaClusters) do
  begin
    tpa := pAreaClusters[i].Intersection(obj);
    tempLength := Length(tpa);
    if tempLength > bestLength then
    begin
      bestLength := tempLength;
      bestObj := tpa;
    end;
  end;
  Result := bestObj.NearestPoint(p);

  {$IFDEF DEBUG_WALKER}
  WriteLn('Found nearest walkable point as: ',result);
  {$ENDIF}
end;



function TWebGraph.PathBetweenEx(a, b: TPoint; out data: EGraphNodeArray; rnd: Double = 0; attempts: Integer = 3; safe: Boolean = True): TPointArray;
var
  i, j: Integer;
  nS, nG, indices: TIntegerArray;
begin
  if not Self.WalkableSpace.Contains(a) or not Self.WalkableSpace.Contains(b) then
  begin
    a := RSTranslator.NormalizeDoor(a);
    b := RSTranslator.NormalizeDoor(b);

    if not Self.WalkableSpace.Contains(a) then
      a := Self.NearestWalkablePoint(a);
    if not Self.WalkableSpace.Contains(b) then
      b := Self.NearestWalkablePoint(b);
  end;

  nS := Self.NearNodesIndices(a, attempts);
  nG := Self.NearNodesIndices(b, attempts);

  if nS[0] = nG[0] then
  begin
    data := [EGraphNode.NORMAL, EGraphNode.NORMAL];
    Exit([a, b]);
  end;

  if (Length(nG) = 1) and (Length(Self.Paths[nG[0]]) = 0) then
    raise GetDebugLn('WebGraph', 'Points ' + ToStr(a) + ' and ' + ToStr(b) + ' don''t connect!');

  for i := 0 to High(nS) do
    for j := 0 to High(nG) do
    begin
      if nS[i] = nG[j] then
        Continue;
      indices := Self.FindPath(nS[i],nG[j], rnd);
      if Length(indices) > 0 then
        Break(2);
    end;

  if safe and (Length(indices) = 0) then
    Exit;

  if Length(indices) = 0 then
    raise GetDebugLn('WebGraph', 'Points ' + ToStr(a) + ' and ' + ToStr(b) + ' don''t connect!');

  Result += a;
  data := [EGraphNode.NORMAL];
  for i in indices do
  begin
    Result += Self.Nodes[i];
    data += Self.Data[i];
  end;
  Result += b;
  data += EGraphNode.NORMAL;
end;

function TWebGraph.PathBetween(a, b: TPoint; rnd: Double = 0; attempts: Integer = 3; safe: Boolean = True): TPointArray;
var
  data: EGraphNodeArray;
begin
  Result := Self.PathBetweenEx(a,b,data,rnd,attempts,safe);
end;



function TWebGraph.FindObjectPath(me: TPoint; out pt: TPoint): TPointArray;
var
  i: Integer;
  cluster, best: TPointArray;
begin
  for i := 0 to High(Self.WalkableClusters) do
    if Self.WalkableClusters[i].Contains(me) then
      cluster := Self.WalkableClusters[i];

  if cluster = [] then
    raise GetDebugLn('WebGraph', 'Can''t find player cluster containg: ' + ToStr(me));

  best := Self.NearNodes(pt, 12);
  for i := 0 to High(best) do
  begin
    pt := best[i];

    if cluster.Contains(pt) then
    begin
      try
        Result := Self.PathBetween(me, pt, 0.2, 2);
        if Result = [] then
        begin
          if me.DistanceTo(pt) <= 52 then Exit([pt]);
          RaiseException('Path empty');
        end;
      except
        if me.DistanceTo(pt) <= 52 then Exit([pt]);
        raise GetDebugLn('WebGraph', 'Can''t find a walkable path to ' + ToStr(pt) + ' object.');
      end;
      Break;
    end;
  end;
end;



function TWebGraph.InvalidConnection(p,q: TPoint): Boolean;

  function LinesIntersect(p,q:array[0..1] of TPoint; out i:TPoint): Boolean;
  var
    dx,dy,d: TPoint;
    dt,s,t: Double;
    function Det(a,b: TPoint): Int64;
    begin
      Result := a.x*b.y - a.y*b.x;
    end;
  begin
    dx := [p[0].x - p[1].x, q[0].x - q[1].x];
    dy := [p[0].y - p[1].y, q[0].y - q[1].y];
    dt := det(dx, dy);
    if dt = 0 then Exit(False);
    d := [Det(p[0],p[1]), Det(q[0],q[1])];
    i.x := Round(Det(d, dx) / dt);
    i.y := Round(Det(d, dy) / dt);
    s := (dx.x * (q[0].y-p[0].y) + dy.x * (p[0].x-q[0].x)) / dt;
    t := (dx.y * (p[0].y-q[0].y) + dy.y * (q[0].x-p[0].x)) / (-dt);
    Result := (s > 0) and (s < 1) and (t > 0) and (t < 1);
  end;

var
  i,n: Integer;
  l1,l2: array[0..1] of TPoint;
  _: TPoint;
begin
  l1 := [p,q];
  for i:=0 to High(self.Paths) do
  begin
    l2[0] := self.Nodes[i];
    for n in self.Paths[i] do
    begin
      l2[1] := self.Nodes[n];
      if (l1[0] = l2[0]) and (l1[1] = l2[1]) then
        Continue;
      if LinesIntersect(l1,l2,_) then
        Exit(True);
    end;
  end;
end;


function TWebGraph.AddNode(p: TPoint; FromNode: Integer): Boolean;
var
  c: Integer;
begin
  if (FromNode <> -1) and (Self.InvalidConnection(p, Self.Nodes[FromNode])) then
    Exit(False);

  c := Length(Self.Nodes);
  SetLength(Self.Nodes, c+1);
  SetLength(Self.Paths, c+1);
  SetLength(Self.Names, c+1);
  Self.Nodes[c] := p;

  if FromNode <> -1 then
  begin
    Self.Paths[FromNode] += c;
    Self.Paths[c] += FromNode;
  end;

  Result := True;
end;


function TWebGraph.ConnectNodes(a,b: Integer): Boolean;
begin
  if b in Self.Paths[a] then
  begin
    Self.Paths[a].Remove(b);
    Self.Paths[b].Remove(a);
  end else
  begin
    Self.Paths[a] += b;
    Self.Paths[b] += a;
  end;

  Result := True;
end;

function TWebGraph.ConnectNodes(a,b: TPoint): Boolean; overload;
var
  i, j: Integer;
begin
  i := Self.Nodes.IndexOf(a);
  if i = -1 then Exit;

  j := Self.Nodes.IndexOf(b);
  if j = -1 then Exit;

  Result := Self.ConnectNodes(i,j);
end;

function TWebGraph.ConnectNodes(a: Integer; b: TPoint): Boolean; overload;
var
  i: Integer;
begin
  i := Self.Nodes.IndexOf(b);
  if i = -1 then Exit;

  Result := Self.ConnectNodes(a, i);
end;

function TWebGraph.ConnectNodesEx(a,b: TPoint): Boolean;
var
  i, j: Integer;
begin
  i := Self.NearestNodeIndex(a);
  j := Self.NearestNodeIndex(b);
  Result := Self.ConnectNodes(i,j);
end;


function TWebGraph.DeleteNode(node: Integer): Integer;
var
  i,j,n,curr: Integer;
  marked: TIntegerArray;
begin
  marked += node;
  repeat
    curr := marked.Pop;

    for n in Self.Paths[curr] do
    begin
      Self.Paths[n].Remove(curr);
      if Self.Paths[n] = [] then
        marked += n;
    end;

    // offset remainding nodes
    for i:=0 to High(Self.Paths) do
      for j:=0 to High(Self.Paths[i]) do
        if Self.Paths[i][j] > curr then
          Dec(Self.Paths[i][j]);

    for i:=0 to High(marked) do
      if marked[i] > curr then Dec(marked[i]);

    // remove the node itself
    Delete(Self.Paths, curr, 1);
    Delete(Self.Nodes, curr, 1);
    Result += 1;
  until Length(marked) = 0;
end;

procedure TWebGraph.DeleteNodes(b: TBox);
var
  i: Integer;
begin
  for i := High(Self.Nodes) downto 0 do
    if b.Contains(Self.Nodes[i]) then
    begin
      Self.DeleteNode(i);
      i := High(Self.Nodes) + 1;
    end;
end;


procedure TWebGraph.Merge(graph: TWebGraph);
var
  i, j, len: Integer;
begin
  len := Length(Self.Nodes);

  for i := 0 to High(graph.Nodes) do
  begin
    Self.Nodes += graph.Nodes[i];
    Self.Paths += graph.Paths[i];

    for j := 0 to High(Self.Paths[len+i]) do
      Self.Paths[len+i,j] += len;

    Self.Data += graph.Data[i];
    Self.Names += graph.Names[i];
  end;

  Self.WalkableSpace    += graph.WalkableSpace;
  Self.WalkableClusters += graph.WalkableClusters;
  Self.ObjectClusters   += graph.ObjectClusters;
end;


procedure TWebGraph.Draw(img: TImage);
var
  i,j: Integer;
begin
  if Self.Nodes = [] then Exit;

  img.DrawColor := $00EAEA;
  for i := 0 to High(Self.Paths) do
    for j := 0 to High(Self.Paths[i]) do
      img.DrawLine(Self.Nodes[i], Self.Nodes[Self.Paths[i, j]]);

  for i := 0 to High(Self.Nodes) do
  begin
    case Self.Data[i] of
      EGraphNode.DOOR:  img.DrawColor := $FF105F;
      EGraphNode.NAMED: img.DrawColor := $FF7F00;
      EGraphNode.NORMAL: img.DrawColor := $0101CC;
      else img.DrawColor := $FF00FF;
    end;
    img.DrawBox(TBox.Create(Self.Nodes[i], 1, 1));
  end;

end;

procedure TWebGraph.Draw(canvas: TImageBoxCanvas); overload;
var
  i,j: Integer;
begin
  if Self.Nodes = [] then Exit;

  for i := 0 to High(Self.Paths) do
    for j := 0 to High(Self.Paths[i]) do
    begin
      if Self.Paths[i, j] > High(Self.Nodes) then Continue;
      canvas.DrawLine(Self.Nodes[i], Self.Nodes[Self.Paths[i, j]], $00EAEA);
    end;

  for i := 0 to High(Self.Nodes) do
  begin
    case Self.Data[i] of
      EGraphNode.DOOR:
      begin
        canvas.DrawCross(Self.Nodes[i], 4, $FF105F);
        canvas.DrawBox(TBox.Create(Self.Nodes[i], 1, 1), $FF105F);
      end ;
      EGraphNode.NAMED: canvas.DrawBox(TBox.Create(Self.Nodes[i], 1, 1), $FF7F00);
      EGraphNode.NORMAL: canvas.DrawBox(TBox.Create(Self.Nodes[i], 1, 1), $0101CC);
      else canvas.DrawBox(TBox.Create(Self.Nodes[i], 1, 1), $FF00FF);
    end;
  end;
end;
