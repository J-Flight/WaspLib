(*
# WebGraph
Responsible for handling webwalking or any other graph logic you may need.

It's partially based on the original webgraph logic by [slacky](https://slacky.one/)
but it was written from scratch by Torwent.

It's important to note that most types and methods are for internal usage and
you shouldn't really have to interact with it.
*)

{$DEFINE WL_WEBGRAPH_INCLUDED}
{$INCLUDE_ONCE WaspLib/utils.simba}

{$R-}

{$IFDEF RANGECHECKS}
begin
  WriteLn GetDebugLn('WebGraph', 'Range checks are enabled for webgraphs, these should be disabled in production!', ELogLevel.WARN);
end;
{$ENDIF}

type
(*
(EGraphNode)=
## type EGraphNode
```pascal
EGraphNode = enum(NORMAL, DOOR, STAIRS, SHORTCUT, OBSTACLE, TRANSPORT, TELEPORT, FAIRYRING, BLOCKED);
```
Enum representing the type of nodes in a `TWebGraph`.
*)
  EGraphNode = enum(
    NORMAL, DOOR, STAIRS, SHORTCUT, OBSTACLE, TRANSPORT, TELEPORT, FAIRYRING,
    BLOCKED
  );

(*
(TGraphNodeFunction)=
## type TGraphNodeFunction
Boolean method type for a {ref}`TGraphNode` `Check` and `Handle` functions.

These are functions a {ref}`TGraphNode` can have to:
- `Check` to check if we can go through the node, e.g. check a level requirement
- `Handle` to handle going through the node, e.g. cast a teleport.

Here is a simple example of a `Check` and a `Handle` functions for a falador teleport:
```pascal
function TTransporter.CheckTeleportFalador(): Boolean;
begin
  if Stats.GetLevel(ERSSkill.MAGIC) < 31 then Exit;
  Result := Magic.Open() and Magic.ContainsSpell(ERSSpell.FALADOR_TELEPORT);
end;

function TTransporter.DoTeleportFalador(): Boolean;
begin
  if Magic.CastSpell(ERSSpell.FALADOR_TELEPORT, 'Cast') then
    Result := SleepUntil(Self.Position().InRange([8752, 36716], 60), 300, 5000);
end;
```
*)
  TGraphNodeFunction = function (): Boolean  of object;

(*
(TGraphNode)=
## type TGraphNode
Type representing a {ref}`TWebGraph` node.
*)
  TGraphNode = record
    Node: TPoint;
    Typ: EGraphNode;
    Check, Handle: TGraphNodeFunction;
  end;

(*
## TGraphNode.Create
```pascal
function TGraphNode.Create(pt: TPoint; typ: EGraphNode = EGraphNode.NORMAL; check, handle: TGraphNodeFunction = nil): TGraphNode; static;
```
Function to create a {ref}`TGraphNode`.
*)
function TGraphNode.Create(pt: TPoint; typ: EGraphNode = EGraphNode.NORMAL; check, handle: TGraphNodeFunction = nil): TGraphNode; static;
begin
  Result.Node := pt;
  Result.Typ := typ;
  Result.Check := @check;
  Result.Handle := @handle;
end;

type
  TGraphNodeArray = array of TGraphNode;

function TGraphNodeArray.Offset(pt: TPoint): TGraphNodeArray;
var
  i: Integer;
begin
  for i := 0 to High(Self) do
    Result += [Self[i].Node.Offset(pt), Self[i].Typ];
end;

function TGraphNodeArray.IndexOf(value: TPoint): Integer; overload;
begin
  for Result := 0 to High(Self) do
    if Self[Result].Node = value then
      Exit;
  Result := -1;
end;

function TGraphNodeArray.NearestIndex(pt: TPoint): Integer;
var
  i: Integer;
  dist, best: Double;
begin
  best := $FFFFFF;
  for i := 1 to High(Self) do
  begin
    dist := Self[i].Node.DistanceTo(pt);

    if (dist < best) then
    begin
      best := dist;
      Result := i;
    end;
  end;
end;

function TGraphNodeArray.PolylineLength(): Double;
var
  i: Integer;
begin
  if Length(Self) < 2 then Exit;
  for i := 0 to High(Self)-1 do
    Result += Self[i].Node.DistanceTo(Self[i+1].Node);
end;

type
(*
(TWebGraph)=
## type TWebGraph
Type representing a webgraph, for more information on what a graph is in this
context visit this [wikipedia page](https://en.wikipedia.org/wiki/Graph_(discrete_mathematics))
*)
  TWebGraph = record
    Nodes: TGraphNodeArray;
    Paths: T2DIntegerArray;

    WalkableSpace: TPointArray;
    WalkableClusters, ObjectClusters: T2DPointArray;
    Tree: TKDPointTree;
  end;

  PWebGraph = ^TWebGraph;

(*
## TWebGraph.Setup
```pascal
procedure TWebGraph.Setup();
```
It sets up `TWebGraph.Tree`, a {ref}`TKDPointTree` used to compare distances between
nodes very fast.
*)
procedure TWebGraph.Setup();
var
  tpa: TPointArray;
  node: TGraphNode;
begin
  for node in Self.Nodes do
    tpa += node.Node;
  Self.Tree := TKDPointTree.Create(tpa);
end;


(*
## TWebGraph.Copy
```pascal
function TWebGraph.Copy(): TWebGraph;
```
Performs a unique copy of the `TWebGraph` which you can modify without modifying the original.
Useful for debugging graphs when you need to keep the original unchanged, e.g.
with the {ref}`Map Debugger`.
*)
function TWebGraph.Copy(): TWebGraph;
begin
  Result.Nodes := System.Copy(Self.Nodes);
  Result.WalkableSpace := System.Copy(Self.WalkableSpace);
  Result.WalkableClusters := System.Copy(Self.WalkableClusters);
  Result.ObjectClusters := System.Copy(Self.ObjectClusters);
  Result.Setup();
end;


(*
## TWebGraph.BlockArea
```pascal
procedure TWebGraph.BlockArea(area: TBox; inside: Boolean = True);
```
Blocks an area of the `TWebGraph` so no nodes in the specified `area` are returned
when finding paths.

For example, this is how you could block the space where wintertodt is so
you don't get paths through the chasm:
```pascal
Map.Setup([ERSChunk.WINTERTODT]);
Map.Loader.Graph.BlockArea([6478, 34358, 6565, 34445]);
```
*)
procedure TWebGraph.BlockArea(area: TBox; inside: Boolean = True);
var
  i: Integer;
begin
  if inside then
  begin
    for i := 0 to High(Self.Nodes) do
      if area.Contains(Self.Nodes[i].Node) then
        Self.Nodes[i].Typ := EGraphNode.BLOCKED;
    Exit;
  end;

  for i := 0 to High(Self.Nodes) do
    if not area.Contains(Self.Nodes[i].Node) then
      Self.Nodes[i].Typ := EGraphNode.BLOCKED;
end;


(*
## TWebGraph.NearNodesIndices
```pascal
function TWebGraph.NearNodesIndices(pt: TPoint; amount: Integer): TIntegerArray;
```
Returns the indices of the `amount` of nearest nodes to `pt` on the webgraph
that can be walked to to and from `pt`.

The result returned is sorted by shortest distance to `pt`.
*)
function TWebGraph.NearNodesIndices(pt: TPoint; amount: Integer): TIntegerArray;
var
  i, n: Integer;
  weights: TDoubleArray;
  tpa: TPointArray;
begin
  tpa := Self.Tree.KNearest(pt, amount);
  for i := 0 to High(tpa) do
    if Self.WalkableClusters.InSameTPA(pt, tpa[i]) then
    begin
      n := Self.Nodes.IndexOf(tpa[i]);
      if n = -1 then Continue;
      Result += n;
      weights += pt.DistanceTo(tpa[i]);
    end;

  if Result = [] then
    for i := 0 to High(tpa) do
    begin
      n := Self.Nodes.IndexOf(tpa[i]);
      if n = -1 then Continue;
      Result += n;
      weights += pt.DistanceTo(tpa[i]);
    end;

  Result.Sort(weights, True);
end;


(*
## TWebGraph.FindPath
```pascal
function TWebGraph.FindPath(start, finish: Integer; rnd: Double = 0): TIntegerArray;
```
Finds a path between `start` and `finish` with the ability to introduce some
randomness through `rnd`.

This is basically a weighted BFS algorithm.

For more information on the algorithm read the [wikipedia page on breadth-first search](https://en.wikipedia.org/wiki/Breadth-first_search).
*)
function TWebGraph.FindPath(start, finish: Integer; rnd: Double = 0): TIntegerArray;
type TNode = record Indices: TIntegerArray; Score: Double; end;
var queue: array of TNode;

  function GetNextShortest(): TNode;
  var
    i, node: Integer;
  begin
    Result := queue[0];
    for i := 1 to High(queue) do
      if queue[i].Score < Result.Score then
      begin
        node   := i;
        Result := queue[i];
      end;
    Delete(queue, node, 1);
  end;

var
  visited, checked: TBooleanArray;
  cIdx, pathIdx, i: Integer;
  current, node: TNode;
  p, q: TPoint;
  hyp: Double;
begin
  queue   := [[[start],0]];
  SetLength(visited, Length(Self.Nodes));
  SetLength(checked, Length(Self.Nodes));

  for i := 0 to High(Self.Nodes) do
    visited[i] := Self.Nodes[i].Typ = EGraphNode.BLOCKED;

  while Length(queue) <> 0 do
  begin
    current := GetNextShortest();
    cIdx := current.Indices[High(current.Indices)];

    if visited[cIdx] then
      Continue;

    visited[cIdx] := True;

    if cIdx = finish then
      Exit(current.Indices);

    p := Self.Nodes[cIdx].Node;

    for pathIdx in Self.Paths[cIdx] do
    begin
      if visited[pathIdx] then
        Continue;

      q := Self.Nodes[pathIdx].Node;
      node.Indices := current.Indices + pathIdx;

      hyp := Hypot(p.X-q.X, p.Y-q.Y);

      if @Self.Nodes[pathIdx].Check = nil then
      begin
        case Self.Nodes[pathIdx].Typ of
          EGraphNode.NORMAL: node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 1;
          EGraphNode.DOOR:   node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 10;
          else node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 100;
        end;
        queue += node;
        Continue;
      end;

      if checked[pathIdx] or Self.Nodes[pathIdx].Check() then
      begin
        checked[pathIdx] := True;
        case Self.Nodes[pathIdx].Typ of
          EGraphNode.DOOR: node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 10;
          EGraphNode.TELEPORT, EGraphNode.FAIRYRING: node.Score := current.Score + hyp*0.8 + 5;
          else node.Score := current.Score + hyp + (hyp*Random()*rnd-rnd/2) + 10;
        end;
        queue += node;
        Continue;
      end;

      visited[pathIdx] := True;
    end;
  end;
end;

(*
## TWebGraph.PathBetween
```pascal
function TWebGraph.PathBetween(a, b: TPoint; rnd: Double = 0; attempts: Integer = 3): TGraphNodeArray;
```
Returns a path between `a` and `b` with the ability to introduce some randomness
through `rnd`.

The returned path comes in the form of a `TGraphNodeArray`.
*)
function TWebGraph.PathBetween(a, b: TPoint; rnd: Double = 0; attempts: Integer = 3): TGraphNodeArray;
var
  nodeA, nodeB: TGraphNode;
  i, j: Integer;
  nS, nG, indices: TIntegerArray;
begin
  nS := Self.NearNodesIndices(a, attempts);
  nG := Self.NearNodesIndices(b, attempts);

  nodeA := [a, EGraphNode.NORMAL];
  nodeB := [b, EGraphNode.NORMAL];

  if nS[0] = nG[0] then
    Exit([nodeA, nodeB]);

  if (Length(nG) = 1) and (Self.Paths[nG[0]] = []) then
    raise GetDebugLn('WebGraph', 'Points ' + ToStr(a) + ' and ' + ToStr(b) + ' don''t connect! No paths available.');

  for i := 0 to High(nS) do
  begin
    if nS[i] = -1 then
      Continue;
    for j := 0 to High(nG) do
    begin
      if nG[j] = -1 then
        Continue;
      if nS[i] = nG[j] then Continue;

      indices := Self.FindPath(nS[i],nG[j], rnd);
      if Length(indices) > 0 then
        Break(2);
    end;
  end;

  if Length(indices) = 0 then
    raise GetDebugLn('WebGraph', 'Points ' + ToStr(a) + ' and ' + ToStr(b) + ' don''t connect!');

  Result += nodeA;
  for i in indices do
    Result += Self.Nodes[i];
  Result += nodeB;
end;


(*
## TWebGraph.PathToNear
```pascal
function TWebGraph.PathToNear(a: TPoint; out b: TPoint; rnd: Double = 0): TGraphNodeArray;
```
Returns a path between `a` and and whatever the nearest node to `b` is with the
ability to introduce some randomness through `rnd`.

The nearest node to `b` is also returned through `b`.

The returned path comes in the form of a `TGraphNodeArray`.
*)
function TWebGraph.PathToNear(a: TPoint; out b: TPoint; rnd: Double = 0): TGraphNodeArray;
var
  i: Integer;
  cluster: TPointArray;
  best: TIntegerArray;
begin
  for i := 0 to High(Self.WalkableClusters) do
    if Self.WalkableClusters[i].Contains(a) then
    begin
      cluster := Self.WalkableClusters[i];
      Break;
    end;

  if cluster = [] then
    raise GetDebugLn('WebGraph', 'Can''t find player cluster containg: ' + ToStr(a));

  best := Self.NearNodesIndices(b, 12);
  for i := 0 to High(best) do
  begin
    b := Self.Nodes[best[i]].Node;
    if cluster.Contains(b) then
      Exit(Self.PathBetween(a, b, rnd, 2));
  end;
end;


(*
## TWebGraph.AddNode
```pascal
function TWebGraph.AddNode(pt: TPoint; typ: EGraphNode; fromNode: Integer): Boolean;
```
Adds a new node to the `TWebGraph` with a connection to `fromNode`.

You can specify it's coordinate through `pt` and it's type through `typ`.
*)
function TWebGraph.AddNode(pt: TPoint; typ: EGraphNode; fromNode: Integer): Boolean;
var
  i: Integer;
begin
  if fromNode < 0 then
    Exit(False);

  i := Length(Self.Nodes);
  SetLength(Self.Nodes, i+1);
  SetLength(Self.Paths, i+1);
  Self.Nodes[i] := [pt, typ, nil];

  Self.Paths[fromNode] += i;
  Self.Paths[i] += fromNode;
  Result := True;
end;


(*
## TWebGraph.ConnectNodes
```pascal
procedure TWebGraph.ConnectNodes(a,b: Integer);
procedure TWebGraph.ConnectNodes(a,b: TPoint); overload;
procedure TWebGraph.ConnectNodes(a: Integer; b: TPoint); overload;
```
Connects nodes `a` and `b`.

If either `a` or `b` are `TPoints`, they must match exactly the coordinates of a
node in the graph.

Using indices is always better for performance but overtime they may change if
the shape of the graph changes.
*)
procedure TWebGraph.ConnectNodes(a,b: Integer);
begin
  if not Self.Paths[a].Contains(b) then
    Self.Paths[a] += b;
  if not Self.Paths[b].Contains(a) then
    Self.Paths[b] += a;
end;

procedure TWebGraph.ConnectNodes(a,b: TPoint); overload;
var
  i, idxA, idxB: Integer;
begin
  idxA := -1;
  idxB := -1;

  for i := 0 to High(Self.Nodes) do
  begin
    if (idxA = -1) and (Self.Nodes[i].Node = a) then
      idxA := i
    else if (idxB = -1) and (Self.Nodes[i].Node = b) then
      idxB := i;

    if (idxA <> -1) and (idxB <> -1) then
      Break;
  end;

  Self.ConnectNodes(idxA,idxB);
end;

procedure TWebGraph.ConnectNodes(a: Integer; b: TPoint); overload;
var
  i: Integer;
begin
  i := Self.Nodes.IndexOf(b);
  if i = -1 then Exit;

  Self.ConnectNodes(a, i);
end;

(*
## TWebGraph.ConnectNodesEx
```pascal
procedure TWebGraph.ConnectNodesEx(a,b: TPoint; notEqual: Boolean = False);
```
Connects the closest node to `a` to the closest node to `b`.

This is similar to {ref}`TWebGraph.ConnectNodes` when using `TPoints` but unlike
it, your points don't have to be the exact same as the nodes in the graph.

Overall, this is the most flexible and easiest method to use but it might not
connect exactly the nodes you want at times.
*)
procedure TWebGraph.ConnectNodesEx(a,b: TPoint; notEqual: Boolean = False);
var
  p, q: TPoint;
begin
  p := Self.Tree.Nearest(a, notEqual);
  q := Self.Tree.Nearest(b, notEqual);

  Self.ConnectNodes(p,q);
end;


(*
## TWebGraph.DeleteNode
```pascal
function TWebGraph.DeleteNode(node: Integer): Integer;
```
Deletes a `TGraphNode` from a `TWebGraph` along with all the connections to it.
*)
function TWebGraph.DeleteNode(node: Integer): Integer;
var
  i,j,n,curr: Integer;
  marked: TIntegerArray;
begin
  marked += node;
  repeat
    curr := marked.Pop;

    for n in Self.Paths[curr] do
    begin
      Self.Paths[n].Remove(curr);
      if Self.Paths[n] = [] then
        marked += n;
    end;

    // offset remainding nodes
    for i:=0 to High(Self.Paths) do
      for j:=0 to High(Self.Paths[i]) do
        if Self.Paths[i][j] > curr then
          Dec(Self.Paths[i][j]);

    for i:=0 to High(marked) do
      if marked[i] > curr then Dec(marked[i]);

    // remove the node itself
    Delete(Self.Paths, curr, 1);
    Delete(Self.Nodes, curr, 1);
    Result += 1;
  until Length(marked) = 0;
end;

(*
## TWebGraph.DeleteNodes
```pascal
procedure TWebGraph.DeleteNodes(b: TBox);
```
It's very similar to {ref}`TWebGraph.BlockNodes` but unlike it, what this does
is permanent. Blocking nodes could be used to selectively toggle nodes on/off,
this permanently removes them.

For example, this is how you could block the space where wintertodt is so
you don't get paths through the chasm:
```pascal
Map.Setup([ERSChunk.WINTERTODT]);
Map.Loader.Graph.DeleteNodes([6478, 34358, 6565, 34445]);
```
*)
procedure TWebGraph.DeleteNodes(b: TBox);
var
  i: Integer;
begin
  for i := High(Self.Nodes) downto 0 do
    if b.Contains(Self.Nodes[i].Node) then
      Self.DeleteNode(i);
end;


(*
## TWebGraph.AddLinkEx
```pascal
procedure TWebGraph.AddLinkEx(a, b: TPoint; typeA, typeB: EGraphNode; checkA, checkB, handleA, handleB: TGraphNodeFunction; connectA, connectB: Boolean);
```
Adds 2 nodes and a connection between them to the `TWebGraph`.

This differs from {ref}`TWebGraph.ConnectNodes` in that you can make the nodes
have `Check` and `Handle` {ref}`TGraphNodeFunction`s.
*)
procedure TWebGraph.AddLinkEx(a, b: TPoint; typeA, typeB: EGraphNode; checkA, checkB, handleA, handleB: TGraphNodeFunction; connectA, connectB: Boolean);
var
  i, j, n: Integer;
  tpa: TPointArray;
begin
  i := Length(Self.Nodes);
  SetLength(Self.Nodes, i+2);
  SetLength(Self.Paths, i+2);

  Self.Nodes[i]   := TGraphNode.Create(a, typeA, @checkA, @handleA);
  Self.Nodes[i+1] := TGraphNode.Create(b, typeB, @checkB, @handleB);

  if connectA then
    Self.Paths[i] += i+1;
  if connectB then
    Self.Paths[i+1] += i;

  tpa := Self.Tree.KNearest(a, 8, True);
  for j := 0 to High(tpa) do
  begin
    if tpa[j] = b then
      Continue;
    if not Self.WalkableClusters.InSameTPA(a, tpa[j]) then
      Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then
      Continue;
    Self.Paths[i] += n;
    Self.Paths[n] += i;
  end;

  tpa := Self.Tree.KNearest(b, 8, True);
  for j := 0 to High(tpa) do
  begin
    if tpa[j] = a then
      Continue;
    if not Self.WalkableClusters.InSameTPA(b, tpa[j]) then
      Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then
      Continue;
    Self.Paths[i+1] += n;
    Self.Paths[n] += i+1;
  end;
end;


(*
## TWebGraph.AddUniLink
```pascal
procedure TWebGraph.AddUniLink(a, b: TPoint; typ: EGraphNode; check, handle: TGraphNodeFunction);
procedure TWebGraph.AddUniLink(a, b: TPoint; typ: EGraphNode; checkA, checkB, handleA, handleB: TGraphNodeFunction); overload;
```
Wrapper around {ref}`TWebGraph.AddLinkEx` to add 2 nodes with a single way
connection from `a` to `b` like a teleport for example.
*)
procedure TWebGraph.AddUniLink(a, b: TPoint; typ: EGraphNode; check, handle: TGraphNodeFunction);
begin
  Self.AddLinkEx(a, b, typ, typ, @check, @check, @handle, @handle, True, False);
end;

procedure TWebGraph.AddUniLink(a, b: TPoint; typ: EGraphNode; checkA, checkB, handleA, handleB: TGraphNodeFunction); overload;
begin
  Self.AddLinkEx(a, b, typ, typ, @checkA, @checkB, @handleA, @handleB, True, False);
end;


(*
## TWebGraph.AddDualLink
```pascal
procedure TWebGraph.AddDualLink(a, b: TPoint; typ: EGraphNode; check, handle: TGraphNodeFunction);
procedure TWebGraph.AddDualLink(a, b: TPoint; typ: EGraphNode; checkA, checkB, handleA, handleB: TGraphNodeFunction); overload;
```
Wrapper around {ref}`TWebGraph.AddLinkEx` to add 2 nodes with a two way
connection between `a` and `b` like an agility shortcut or a door for example.
*)
procedure TWebGraph.AddDualLink(a, b: TPoint; typ: EGraphNode; check, handle: TGraphNodeFunction);
begin
  Self.AddLinkEx(a, b, typ, typ, @check, @check, @handle, @handle, True, True);
end;

procedure TWebGraph.AddDualLink(a, b: TPoint; typ: EGraphNode; checkA, checkB, handleA, handleB: TGraphNodeFunction); overload;
begin
  Self.AddLinkEx(a, b, typ, typ, @checkA, @checkB, @handleA, @handleB, True, True);
end;


(*
## TWebGraph.AddTeleport
```pascal
procedure TWebGraph.AddTeleport(pt: TPoint; check, handle: TGraphNodeFunction);
```
Similar to {ref}`TWebGraph.AddUniLink` but made specifically for teleports.
*)
procedure TWebGraph.AddTeleport(pt: TPoint; check, handle: TGraphNodeFunction);
var
  i, j, n: Integer;
  tpa: TPointArray;
begin
  i := Length(Self.Nodes);
  Self.Nodes += TGraphNode.Create(pt, EGraphNode.TELEPORT, @check, @handle);
  SetLength(Self.Paths, Length(Self.Nodes));

  tpa := Self.Tree.KNearest(pt, 12);
  for j := 0 to High(tpa) do
  begin
    if not Self.WalkableClusters.InSameTPA(pt, tpa[j]) then
      Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then Continue;
    Self.Paths[i] += n;
    Self.Paths[n] += i;
  end;

  for j := 0 to High(Self.Nodes)-1 do
  begin
    if Self.Nodes[i].Node.InRange(Self.Nodes[j].Node, 120) then
      Continue;
    Self.Paths[j] += i;
  end;
end;


(*
## TWebGraph.AddFairyRing
```pascal
procedure TWebGraph.AddFairyRing(pt: TPoint);
```
Similar to {ref}`TWebGraph.AddDualLink` but made specifically for fairy rings.
*)
procedure TWebGraph.AddFairyRing(pt: TPoint);
var
  i, j, n: Integer;
  tpa: TPointArray;
begin
  i := Length(Self.Nodes);
  Self.Nodes += TGraphNode.Create(pt, EGraphNode.FAIRYRING, nil);
  SetLength(Self.Paths, Length(Self.Nodes));

  tpa := Self.Tree.KNearest(pt, 8);
  for j := 0 to High(tpa) do
  begin
    if not Self.WalkableClusters.InSameTPA(pt, tpa[j]) then
      Continue;

    n := Self.Nodes.IndexOf(tpa[j]);
    if n = -1 then Continue;
    Self.Paths[i] += n;
    Self.Paths[n] += i;
  end;

  for j := 0 to High(Self.Nodes) do
    if Self.Nodes[j].Typ = EGraphNode.FAIRYRING then
    begin
      Self.Paths[j] += i;
      Self.Paths[i] += j;
    end;
end;


(*
## TWebGraph.Merge
```pascal
procedure TWebGraph.Merge(graph: TWebGraph);
```
Merges `graph` into the current `TWebGraph`.
*)
procedure TWebGraph.Merge(graph: TWebGraph);
var
  i, j, len: Integer;
begin
  len := Length(Self.Nodes);

  for i := 0 to High(graph.Nodes) do
  begin
    Self.Nodes += graph.Nodes[i];
    Self.Paths += graph.Paths[i];

    for j := 0 to High(Self.Paths[len+i]) do
      Self.Paths[len+i,j] += len;
  end;

  Self.WalkableSpace    += graph.WalkableSpace;
  Self.WalkableClusters += graph.WalkableClusters;
  Self.ObjectClusters   += graph.ObjectClusters;
end;


(*
## TWebGraph.Draw
```pascal
procedure TWebGraph.Draw(img: TImage);
procedure TWebGraph.Draw(canvas: TImageBoxCanvas); overload;
```
Used for `TWebGraph` debugging.
*)
procedure TWebGraph.Draw(img: TImage);
var
  i,j: Integer;
begin
  if Self.Nodes = [] then Exit;

  img.DrawColor := $00EAEA;
  for i := 0 to High(Self.Paths) do
    if Self.Nodes[i].Typ <> EGraphNode.TELEPORT then
      for j := 0 to High(Self.Paths[i]) do
        if Self.Nodes[Self.Paths[i, j]].Typ <> EGraphNode.TELEPORT then
          img.DrawLine(Self.Nodes[i].Node, Self.Nodes[Self.Paths[i, j]].Node);

  for i := 0 to High(Self.Nodes) do
  begin
    case Self.Nodes[i].Typ of
      EGraphNode.DOOR:  img.DrawColor := $FF105F;
      EGraphNode.TELEPORT: img.DrawColor := $FF7F00;
      EGraphNode.NORMAL: img.DrawColor := $0101CC;
      else img.DrawColor := $FF00FF;
    end;
    img.DrawBox(TBox.Create(Self.Nodes[i].Node, 1, 1));
  end;

end;

procedure TWebGraph.Draw(canvas: TImageBoxCanvas); overload;
var
  i,j: Integer;
  color: TColor;
begin
  if Self.Nodes = [] then Exit;

  for i := 0 to High(Self.Paths) do
    if Self.Nodes[i].Typ <> EGraphNode.TELEPORT then
      for j := 0 to High(Self.Paths[i]) do
        if Self.Nodes[Self.Paths[i, j]].Typ <> EGraphNode.TELEPORT then
        begin
          if Self.Paths[i, j] > High(Self.Nodes) then Continue;
          canvas.DrawLine(Self.Nodes[i].Node, Self.Nodes[Self.Paths[i, j]].Node, $00EAEA);
        end;

  for i := 0 to High(Self.Nodes) do
  begin
    case Self.Nodes[i].Typ of
      EGraphNode.DOOR: color := $FF105F;
      EGraphNode.TELEPORT: color := $FF7F00;
      EGraphNode.NORMAL: color := $0101CC;
      else color :=  $FF00FF;
    end;
    canvas.DrawBoxFilled(TBox.Create(Self.Nodes[i].Node, 1, 1), color);
  end;
end;
{$R+}
